<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Notes, SpringBoot Guide]]></title>
    <url>%2F2018%2F03%2F09%2Fspringboot-guide-notes%2F</url>
    <content type="text"><![CDATA[MVCThe Model encapsulates the application data and in general they will consist of POJO. The View is responsible for rendering the model data and in general it generates HTML output that the client’s browser can interpret. The Controller is responsible for processing user requests and building an appropriate model and passes it to the view for rendering. Original MVC Spring MVC Dependency Injection (DI)The technology that Spring is most identified with is the Dependency Injection (DI) flavor of Inversion of Control.The Inversion of Control (IoC) is a general concept, and it can be expressed in many different ways.Dependency Injection is merely one concrete example of Inversion of Control. What is dependency injection exactly? Let’s look at these two words separately. Here the dependency part translates into an association between two classes. For example, class A is dependent of class B. Now, let’s look at the second part, injection. All this means is, class B will get injected into class A by the IoC. BeanWhat is BeanThe objects that form the backbone of your application and that are managed by the Spring IoC container are called beans. A bean is an object that is instantiated, assembled, and otherwise managed by a Spring IoC container. These beans are created with the configuration metadata that you supply to the container. Dependency Injection Type &amp; Description Constructor-based dependency injectionConstructor-based DI is accomplished when the container invokes a class constructor with a number of arguments, each representing a dependency on the other class. Setter-based dependency injectionSetter-based DI is accomplished by the container calling setter methods on your beans after invoking a no-argument constructor or no-argument static factory method to instantiate your bean. @Configuration &amp; @Bean AnnotationsAnnotating a class with the @Configuration indicates that the class can be used by the Spring IoC container as a source of bean definitions.The @Bean annotation tells Spring that a method annotated with @Bean will return an object that should be registered as a bean in the Spring application context. The @Import Annotation (Optional)The @Import annotation allows for loading @Bean definitions from another configuration class. Specifying Bean ScopeThe default scope is singleton, but you can override this with the @Scope annotation. AOPWhat is AOPAspect-Oriented Programming entails breaking down program logic into distinct parts called so-called concerns.The functions that span multiple points of an application are called cross-cutting concerns and these cross-cutting concerns are conceptually separate from the application’s business logic.There are various common good examples of aspects like logging, auditing, declarative transactions, security, caching, etc. Comparison with DIThe key unit of modularity in OOP is the class, whereas in AOP the unit of modularity is the aspect.Dependency Injection helps you decouple your application objects from each other and AOP helps you decouple cross-cutting concerns from the objects that they affect.AOP is like triggers in programming languages such as Perl, .NET, Java, and others. Spring AOP module provides interceptors to intercept an application.For example, when a method is executed, you can add extra functionality before or after the method execution. Reference Spring Boot Reference 1.5.9.RELEASE Guide Spring Boot Docs 1.5.9.RELEASE API Spring Framework Documentation Spring Web MVC framework 某忘记名字的网站 知乎]]></content>
      <categories>
        <category>Doing</category>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Notes, 大型网站技术架构]]></title>
    <url>%2F2017%2F10%2F27%2Flarge-site-architecture-notes%2F</url>
    <content type="text"><![CDATA[OverviewEvolution of Large Site ArchitectureCharacteristics high concurrency, huge traffic high availability vast data users from everywhere, complex situation of network bad environment of security quick demands changing, frequently releasing progessive development Development Progress begin separate application and data service use cache use application cluster separate read and write of database use reverse proxy and CDN use distributed file system and distributed database use NoSQL and search engine separate bussiness use distributed services Values key is to be flexible to the bussiness major pusher is bussiness developing Wrong Thinking follow solutions of the gaints blindly be technical just for techniques try to solve all problems with techniques Models of Large Site ArchitectureLayer (horizontal) application layer: be responsible for specific bussiness and view showing (view, bussiness logic) service layer: provide service for application layer (data interfaces, logic processing) data layer: provide service data accessing and storage Split (vertical)split different functionalites and services into aggregated and decoupled modules. Distributeddistributedly deploy the layered and splitted modules in different servers. distributed applications and services distributed static resources distributed data and storage distributed computing distributed configuration distributed lock distributed file system Clustercluster the independent deployed server, i.e., many servers deployed the same application consists of a cluster. Cache CDN reverse proxy local cache in application server distributed cache Asynchronizationdistributed message queue, is a typical producer-consumer model improve system availability speed up the response of website reduce the peek of concurrent accessing Redundancy cold backup: storage archived in fixed period hot backup: separate read and write of database, real-time synchronization disaster recovery data center Automation automatic releasing automatic source control automatic testing automatic security dection automatic deployment automatic monitoring automatic alerting automatic failure transferring automatic failure recoverring automatic downgrading automatic resource allocating Security password verification code encryption filtering risk control Architecture Model of Weibo Keys of Large Site ArchitecturePerformance response time throughput system performance monitor (top) Availability available time (99.99%) redundancy pre-released verification gray releasing Scalabilityeasy to add and remove servers in cluster Extensibility event driven architecture distributed service SecurityArchitectureHigh-performance ArchitectureDifferent Views of Website Performance user developerthe performance of application itself and relevant subsystem.response latency, system throughput, concurrency, and system stability maintainerinfrastructure performance, resource utilization Metrics of Performance response time number of concurrencynumber of total users &gt;&gt; number of online users &gt;&gt; number of concurrent users throughputTPS(transaction per second), QPS(query per second), HPS(HTTP request per second) system performance monitor (top)system load, number of objects and threads, memory and CPU used, disk and netword I/Otop: there floating number, recent 1min, 10mins, 15mins average running processes Ways of Profiling performance testing load testing stress testing stability testing performance report Strategy of Performance Optimization performance analysis performance optimization Web Front Performance Optimization browser reduce the number of HTTP requests browser cache enable compression put CSS at the front of page, and JS at the bottom reduce the transferring of Cookie CDN (Content Distribute Network) reverse proxy Application Server Performance Optimizationdistributed cache cache principle (80%-20% law) use cache properly infrequently modified (read:write ≥ 2:1) hot piece set expired time cache availability cache warm uppreload the hot pieces cache penetratingsituation that requires to nonexistent data in high concurrency, one way is to cache it (nonexistent-null) architecture of distributed cache JBoss Cache: update synchronously (enterprise use) Memcached: no communication between servers communication protocol: TCP, UDP, HTTPcommunication serializating protocol: text(XML, JSON), binary(Google Protobuffer) memcached use TCP for communication protocol, and it defines its own text serializating protocol. memcached’s server communication module is based on Libevent. memory management chunk-based allocationfind a minimal chunk that can save the data LRU asynchronizatonuse message queue to reduce the peek cluster code optimization multi-threadnumber of threads = $\frac{task execution time}{task execution time-IO waiting time}\times CPU cores$ thread-safestateless object, local object, lock resource reusingsingleton, object pool data structurehashtable: originlal-MD5-&gt;info figureprint-HASH-&gt;hashcode garbage collectionobject created in Eden-Young GC-&gt;From-Young GC-&gt;To-Young GC-&gt;From-…threshold times Young GC-&gt;Old-&gt;Full GC storage performance optimization mechanical hard disk vs. solid state hard drive B+ tree vs. LSM treeN-branch search tree: at most 3 level, (maybe 5 disk IOs to update, 3 to get the index, 1 to read, 1 to write)N-level mergeable search tree: write operations do in memory, and create a new record in the $C_0$ tree RAID vs. HDFS High-availability ArchitectureLayered Architectureapplication layer &lt;- service layer &lt;- data layermore complicated: High-availability Application failure transferring through load balancing session managemanta session is a semi-permanent interactive information interchange, i.e., a dialogue session copy session binding use cookie to record session session server High-availability Service managed in priority time-out setting asynchronous call downgrade-abled service idempotent designi.e., repeated call can be handled properly. High-availability DataCAP Principe consistency availablity partition tolerance consistency data strong consistencydata is always consistent in all the physical copies data user consistencydata may be not consistent in all the physical copies, but itcan be accessed as a consistent and right one for user througherror correction and verification. data final consistencydata may be not consistent in all the physical copies, and itmay be not accessed consistently. but after some time, it can becorrected to user consistency. Data BackupFailure Transferring failure confirmation access transferring data recovering Quality Insuranceautomatic releasing(gray releasing) automatic testing pre-releasing verification source control master developing, branch releasing master releasing, branch developing website monitoring user behavior log collectiontools based on Storm (real-time computing framework) server performance monitoring running data report website monitoring control system alerting failure transferring automatic downgrading High-scalability ArchitecturePhysical Separation（clustering) Load Balancing HTTP redirection protocol DNS (domain name resolution) reverse proxy IP data link layerLVS (Linux Virtual Server) load balancing algorithms round robin weighted round robin random least connections source hashing Distributed Cachememchached access model consistent hashing to solve the influence of cache load =&gt; virtual nodes (a server to 150 nodes) Distributed Database spread tables into different database serversput table into slices, then spread into different database servers database products of data slices: Amoeba, Cobar NoSQL abandon 2 basis of relation database:SQL based on relation algebra,and transaction consistency guarantee [atomicity, consistency, isolation, durability] (ACID) strengthen characteristics that large site concerned:high-availability, high-scalability Apache HBase High-extensibility Architecture event driven architecture distributed message queueApache ActiveMQ distributed services web service and enterprise distributed service distributed service frameworklarge site need simple and efficient distributed serviceframework to build its service oriented architecture (SOA)it is said that Facebook manages its distributed service based onThrift (an opensource remote service call framework)Alibaba-Dubbo extensible data structureNoSQL ColumnFamily (first in Google Bigtable) open platform to build website ecosystem Security ArchitectureWebsite attack and defenseXSS(Cross Site Script) attack reflective type persistent type solution: filter, HttpOnly Injection attackSQL injection, OS injection SQL injection: open source(table name is public), error echoed, blind injection solution: filter, parameter binding CSRF(Cross Site Request Forgety) attack solution: form token, verification code, referer check other attack error echoed HTML comment file uploading path traversal web application firewallModSecurity website security scanning Encryption and Key Security Management one-way hashing encryptionMD5, SHARainbow Table to try to decrypt MD5 symmetric encryptionDES, RC asymmetric encryptionRSAinformation security transmission, digital signature key security management Infomation filtering and Anti-spam text matchingdouble array trie, multi-level hashtable (simpler) classification algorithmNative Bayes, TAN, Association Rule Clustering System (ARCS) blacklisthashtable, bloomfilter Risk Control rule engine statistics model CasesTaobaoAt first, Ma Yun bought a C2C website, then LAMP: MVC: decouple view and bussiness logicORM (Object-relational mapping): decouple objects and relational database Taobao didn’t use the hot Struts and Hibernate,but choose to develop its own MVC frameword Webx, and to use IBatis for ORM.Taobao also used Weblogic for application server, Oracle for database. They are commercial softwares. Then, to use Spring instead of EJB, free JBoss instead of Weblogic At last, abandon Oracle, IBM, EMC, and back to open source MySQL and NoSQL Wikipediabased on LAMP Wikipedia’s web frontthe key architecture of is Squid cluster: Wikipedia’s backend cache the format that application can be used directly cache servers store the session objects memcached’s connection is cheap, and create one when needed increase memory to improve MySQL use RAIO0 to speed up disk accessing set ACID of database at a some low level if Master database sever crashed, switch to Slave,the close the write service, i.e., close the edition of users. Doris (enormous distributed KV storage) Seckilling Systemchanllenge strike for the current bussiness high load of high concurrency increasing bandwidth the URL to place an order solution independently deploy seckilling system static page for seckilling product rent netword bandwidth for seckilling dynamically generate random URL for placing order architecture Failure Analysisdisk space increases surprisinglyset log level to DEBUG by mistake. high load of databasea SQL executes in the index page. timeout failure in high concurrencya singleton object need the unique lock to execute for a long time. high load of database caused by cacheclose the cache servers when releasing. application start out of synchronizationApache and JBoss start at the same time.JBoss first, and curl to validate, then Apache. big files occupy the disk IOseparate different sizes or types of files. abuse of releasing environmentssomeone did performance testing in releasing environments. non-standard releasing procedureforget to uncomment some codes.commit after diff checking. bad programming habitsNullPointerException throws.forget to check whether the object is null. Postscript]]></content>
      <categories>
        <category>Doing</category>
        <category>Distributed</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Miscellany and Summary, Notes(9), Effective C++]]></title>
    <url>%2F2017%2F10%2F17%2Feffective-cpp-miscellany-and-summary%2F</url>
    <content type="text"><![CDATA[Miscellany and Summary(I read a Chinese version of the book, any translation problem plz point out. Pay attention to compiler warnings be serious to compiler warnings. but shouldn’t over rely on compiler warnings. Familiarize yourself with the standard libraryFamiliarize yourself with BoostSummaryIt is about 4 months since I started to read the book.I’m so sorrow that I can’t put the ways into practice, although it is quite fascinating.What I’m eager to do is to write the beautiful code.Keep patient, and what learned will settle.]]></content>
      <categories>
        <category>Doing</category>
        <category>CPP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Customizing new and delete, Notes(8), Effective C++]]></title>
    <url>%2F2017%2F10%2F12%2Feffective-cpp-customizing-new-and-delete%2F</url>
    <content type="text"><![CDATA[Customizing new and delete(I read a Chinese version of the book, any translation problem plz point out. Understand the behavior of the new-handlerwell-designed new-handler should do: make more memory to be used, i.e., more likely to let the next operator new be successful. install another new-handler, i.e., let operator new call set_new_handler. uninstall new-handler, i.e., pass nullptr to operator new. throw bad_alloc (or derived from bad_alloc) error. no return (usually call abort or exit). implement the new_handler of class: class Widget { public: static std::new_handler set_new_handler(std::new_handler p) throw(); static void* operator new(std::size_t size) throw(std::bad_alloc); private: static std::new_handler currentHandler; }; std::new_handler Widget::currentHandler = 0; std::new_handler Widget::set_new_handler(std::new_handler p) throw() { std::new_hanlder old = currentHandler; currentHandler = p; return old; } class NewHandlerHolder { public: explicit NewHandlerHolder(std::new_handler nh) : handler(nh) {} ~NewHandlerHolder() { std::set_new_handler(handler); } private: std::new_handler handler; NewHandlerHolder(const NewHandlerHolder&amp;); NewHandlerHolder&amp; operator=(const NewHandlerHolder&amp;); }; void* Widget::operator new(std::size_t new) throw(std::bad_alloc) { newhandlerholder h(std::set_new_handler(currenthandler)); return ::oeprator new(size); } reuse the code above due to the same implementation for different classes: template&lt;typename T&gt; class NewHandlerSupport { public: static std::new_handler set_new_handler(std::new_handler p) throw(); static void* operator new(std::size_t size) throw(std::bad_alloc); private: static std::new_handler currentHandler; }; template&lt;typename T&gt; std::new_handler NewHandlerSupport&lt;T&gt;::currentHandler = 0; template&lt;typename T&gt; std::new_handler NewHandlerSupport::set_new_handler(std::new_handler p) throw() { std::new_hanlder old = currentHandler; currentHandler = p; return old; } template&lt;typename T&gt; void* NewHandlerSupport::operator new(std::size_t new) throw(std::bad_alloc) { newhandlerholder h(std::set_new_handler(currenthandler)); return ::oeprator new(size); } // curiously recurring template pattern, &quot;mixin&quot; style class Widget: public NewHandlerSupport&lt;Widget&gt; { // ... } nothrow new:it is limited, only adapted to memory allocated, and intermediate constructor called may throw exception. Widget* pw1 = new Widget; // if fails, throw bad_alloc Widget* pw2 = new(std::nothrow) Widget; // if fails, return nullptr Understand when it makes sense to replace new and delete to check the wrong usage. to improve the efficiency of allocation and deallocation. to collect the log of usage. to decrease the additional space cost caused by default memory manager. to improve the suboptimal alignment. to make related objects clustered. to obtain non-traditional behaviors. Adhere to convention when writing new and delete operator new should have an infinite loop which tries to allocate memory. void* operator new(std::size_t size) throw(std::bad_alloc) { using namespace std; if(size == 0) { size = 1; } while(true) { // Try to allocate &quot;size&quot; bytes if(allocation is ok) return (a pointer to the memory allocated); new_handler globalHandler = set_new_handler(0); set_new_handler(globalHandler); if(globalHandler) (*globalHandler)(); else throw bad_alloc(); } } operator delete should do nothing when passed by nullptr, “Class version” should handle the “wrong apply that requires the bigger size than the true size”. class Base { public: static void* operator new(std::size_t size) throw(std::bad_alloc); static void operator delete(void* rawMemoty, std::size_t size) throw(); }; void* Base::operator new(std::size_t size) throw(std::bad_alloc) { if(size != sizeof(Base)) return ::operator new(size); // ... } void Base::operator delete(void* rawMemory, std::size_t size) throw() { if(rawMemory == 0) return; if(size != sizeof(Base)) { ::operator delete(rawMemory); return; } // ... } Write placement delete if you write placement new when write Widget* pw = new Widget;, two functions are called, one is operator new, one is Widget’s default construtor.if the constructor throws, the memory allocated by the first one should be recovered, or it will be memory leak.so the corresponding operator delete should be provided correctly. when write a placement operator new, plz be sure to write a placement operator delete. void* operator new(std::size_t) throw(std::bad_alloc); // normal new void* operator new(std::size_t, void*) throw(); // placement new void* operator new(std::size_t, const std::nothrow_t&amp;) throw(); // nothrow new when declaring placement new and placement delete, plz do not hide the normal version intendedly or unconsciously. class StandardNewDeleteForms { public: // normal new/delete static void* operator new(std::size_t size) throw std::bad_alloc) { return ::operator new(size); } static void operator delete(void* pMemory) throw() { ::operator delete(pMemory); } // placement new/delete static void* operator new(std::size_t size, void* ptr) throw() { ::operator new(size, ptr); } static void operator delete(void* pMemory, void* ptr) throw() { ::operator delete(pMemory, ptr); } // nothrow new/delete static void* operator new(std::size_t size, const std::nothrow_t&amp; nt) throw() { return ::operator new(size, nt); } static void operator delete(void* pMemory, const std::nothrow_t&amp;) throw() { ::operator delete(pMemory); } }; class Widget: public StandardNewDeleteForms { public: // inherit normal new/delete using StandardNewDeleteForms::operator new; using StandardNetDeleteForms::operator delete; // customized placement new/delete static void* operator new(std::size_t size, std::ostream&amp; logStream) throw(std::bad_alloc); static void operator delete(void* memory, std::ostream&amp; logStream) throw(); };]]></content>
      <categories>
        <category>Doing</category>
        <category>CPP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Templates and Generic Programming, Notes(7), Effective C++]]></title>
    <url>%2F2017%2F10%2F09%2Feffective-cpp-templates-and-generic-programming%2F</url>
    <content type="text"><![CDATA[Templates and Generic Programming(I read a Chinese version of the book, any translation problem plz point out. Understand implicit interfaces and compile-time polymorphism classes and templates both support interfaces and polymorphism. as for classes, interfaces is explicit, based on function signatures,and their polymorphism happen in run-time via virtual functions. as for templates, interfaces is implicit, based on valid expressions,and their polymorphism happen in compile-time via template instantiation and function overloading resolution. Understand the two meanings of typenamedependent names: the names appeared in template and dependent on some template parameter.nested dependent names: the dependent name nested in class.C::const_iterator is a nested dependent type name. C::const_iterator* x, what if const_iterator is a static member variable and x is a global variable? keyword class and typename are the same when declare template parameters. use typename to indentify the nested dependent name,but it mustn’t modify the base class in base class lists and member initialization lists. template&lt;typename T&gt; class Derived: public Base&lt;T&gt;::Nested { public: explicit Derived(int x): Basee&lt;T&gt;::Nested(x) { typename Base&lt;T&gt;::Nested tmp; } }; Know how to access names in templatized base classes use this-&gt; to refer to the member names of base class templates in derived class templates. use base class modifier, Base::name Factor parameter-independent code out of templates templates can generate a couple of classes and functions,so any template code should not be dependent on some template parameter which can cause code bloat. code bloat caused by non-type template parameters can be removed via replacing them withfunction parameter or using class member variable. code bload caused by type parameters can be reduced via sharing the implementationwhen the instantiation types are with completely same binary representations,such as strongly typed pointers (T*) to untyped pointers (void*). template&lt;typename T, std::size_t&gt; class SquareMatrix { public: void invert(); }; /***************************************************/ template&lt;typename T&gt; class SquareMatrixBase { protected: SquareMatrixBase(std::size_t n, T* pMem) : size(n), pData(pMem) {} void setDataPtr(T* ptr) { pData = ptr; } void invert() {} private: std::size_t size; T* pData; }; template&lt;typename T, std::size_t n&gt; class SquareMatrix: private SquareMatrixBase&lt;T&gt; { public: SquareMatrix() : SquareMatrixBase&lt;T&gt;(n, 0), pData(new T[n * n]) { this-&gt;setDataPtr(pData.get()); } void invert() { SquareMatrixBase&lt;T&gt;::invert(); } private: std::unique_ptr&lt;T[]&gt; pData; // T data[n * n]; // maybe it is your choice }; // in the first version, the matrix size is a compile-time constant, and // it can be optimized as immediate operand in generated instructions. // while the second version, resulting in smaller executable size, it can reduce // the size of working set of the program, and strengthen the locality of reference in cache. // well, only profiling matters!!! Use member function templates to accept “all compatible types” use member function templates to generate the functions which accept “all compatible types”. you need to declare normal copy constructor and copy assignment operator when using member function templates. or the compiler will generate one which may be not what you want. template&lt;typename T&gt; class SmartPtr { public: SmartPtr(const SmartPtr&amp; r); template&lt;typename U&gt; SmartPtr(const SmartPtr&lt;U&gt;&amp; other) // Make it more like a real pointer : heldPtr(other.get()) {} T* get() const { return heldPtr; } private: T* heldPtr; }; Define non-member functions inside templates when type conversions are desiredtemplate&lt;typename T&gt; class Rational; template&lt;typename T&gt; const Rational&lt;T&gt; doMutiply(const Rational&lt;T&gt;&amp; lhs, const Rational&lt;T&gt;&amp; rhs); template&lt;typename T&gt; class Rational { public: // use a helper to avoid the affect of inlining friend Rational&lt;T&gt; operator*(const Rational&lt;T&gt;&amp; lhs, const Rational&lt;T&gt;&amp; rhs) { return doMultiply(lhs, rhs); } }; Use traits classes for information about types traits classes make “type-related information” be available in compile-time,which is implemented by templates and template specializations. traits classes can execute the if...else test in compile-time via overloading. struct input_iterator_tag {}; struct output_iterator_tag {}; struct forward_iterator_tag: public input_iterator_tag {}; struct bidirectional_iterator_tag: public forward_iterator_tag {}; struct random_access_iterator_tag: public bidirectional_iterator_tag {}; template&lt;typename IterT, typename DistT&gt; void doAdvance(IterT&amp; iter, DistT d, std::random_access_iterator_tag) { iter += d; } template&lt;typename IterT, typename DistT&gt; void doAdvance(IterT&amp; iter, DistT d, std::bidirectional_iterator_tag) { if(d &gt;= 0) { while(d--) ++iter; } else { while(d++) --iter; } } // it can also accept forward_iterator_tag template&lt;typename IterT, typename DistT&gt; void doAdvance(IterT&amp; iter, DistT d, std::input_iterator_tag) { if(d &lt; 0) { throw std::out_of_range(&quot;Negative distance&quot;); } while(d--) ++iter; } template&lt;typename T&gt; void advance(IterT&amp; iter, DistT d) { doAdvance(iter, d, typename std::iterator_traits&lt;IterT&gt;::iterator_category()); } Be aware of templatee metaprogramming TMP is Turing-complete, and TMP loops is recursive template instantiation. // It may be implemented by `enum hack` in lower version of cpp compiler. template&lt;std::size_t n&gt; struct factorial { static const std::size_t value = n * factorial&lt;n - 1&gt;::value; }; template&lt;&gt; struct factorial&lt;0&gt; { static const std::size_t value = 1; }; TMP can be used: validate type informations or some others. optimize matrix operations, such as expression templates. generate custom design patterns for users. (TMP-based policy-based design) -&gt; generative programming]]></content>
      <categories>
        <category>Doing</category>
        <category>CPP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Inheritance and Object-Oriented Design, Notes(6), Effective C++]]></title>
    <url>%2F2017%2F09%2F11%2Feffective-cpp-inheritance-and-object-oriented-design%2F</url>
    <content type="text"><![CDATA[Inheritance and Object-Oriented Design(I read a Chinese version of the book, any translation problem plz point out. Make sure public inheritance models “is-a”class Bird { // ... }; class FlyingBird: public Bird { public: virtual void fly(); // ... }; class Penguin: public Bird { // ... }; public inheritance means everything must be suitable for derived class if it is suitable for base class,because every derived class object is a base class object. is a square a rectangle? Avoid hiding inherited namesCPP name-hiding rules:all the functions of base class with the same name as derived class will be hiden,even if the parameter lists is different. it is both suitable for virtual and non-virtual functions. CPP name-lookup rules:local -&gt; derived -&gt; namespace of derived -&gt; base -&gt; namespace of base -&gt; global but if you use public inheritance without inheriting the overloaded functions, it violates the “is-a” relation between base and derived class. using declarationintroduce all the functions of specific name of base class to derived class,it is ok for public inheritance.```cppclass Base {private: int x;public: virtual void mf1() = 0; virtual void mf1(int); virtual void mf2(); void mf3(); void mf3(double);}; class Derived: public Base {public: using Base::mf1; using Base::mf3; virtual void mf1(); void mf3(); void mf4();}; what if for partially inheriting the functions? * forwarding function use for private inheritance. ```cpp class Base { public: virtual void mf1() = 0; virtual void mf1(int); }; class Derived: private Base { public: virtual void mf1() { // Forwarding function Base::mf1(); // Implicitly inline } }; Differentiate between inheritance of interface and inhertiace of implementation pure virtual functions: only inherit interface. impure virtual functions: inherit interface and a default implementation. non-virtual functons: inherit interface and a forced implementation. invariant far more than specialization. Consider alternatives to virtual functions use Non-Virtual Interface to implement Template Method pattern.advantages: do something before and after the operation, like mutex, log entry, validation of constraints.class GameCharacter { public: // This non-virtual function is a wrapper for the virtual function. int healthValue() const { // ... int retVal = doHealthValue(); // ... return retVal; } private: virtual int doHealthValue() const { // ... } }; use Function Pointers to implement Strategy pattern.class GameCharacter; int defaultHealthCalc(const GameCharacter&amp; gc); class GameCharacter { public: typedef int (*HealthCalcFunc)(const GameCharacter&amp;); explicit GameCharacter(HealthCalcFunc hcf = defaultHealthCalc) : healthFunc(hcf) {} int healthValue() const { return healthFunc(*this); } private: HealthCalcFunc healthFunc; }; advantages:different entities of same type can have different function pointers.function pointers can be changed in run-time.disadvantages:once needing to access the non-public members, you have to weaken the encapsulation of class. class EvilBadGuy: public GameCharacter { public: explicit EvilBadGuy(HealthCalcFunc hcf = defaultHealthCalc) : healthFunc(hcf) {} }; int loseHealthQuickly(const GameCharacter&amp;); int loseHealthSlowly(const GameCharacter&amp;); EvilBadGuy ebg1(loseHealthQuickly); EvilBadGuy ebg2(loseHealthSlowly); with std::function:call accept all the callable entities compatible with target signature (implicit conversion).with std::bind:bind a member function with an object. class GameCharacter; int defaultHealthCalc(const GameCharacter&amp; gc); class GameCharacter { public: typedef std::function&lt;int (const GameCharacter&amp;)&gt; HealthCalcFunc; explicit GameCharacter(HealthCalcFunc hcf = defaultHealthCalc) : healthFunc(hcf) {} int healthValue() const { return healthFunc(*this); } private: HealthCalcFunc healthFunc; }; class EvilBadGuy: public GameCharacter { // ... }; short calcHealth(const GameCharacter&amp;); struct HealthCalculator { int operator()(const GameCharacter&amp;）const {} }; class GameLevel { public: float health(const GameCharacter&amp;) const; }; EvilBadGuy ebg1(calcHealth); // Function pointer EvilBadGuy ebg2(HealthCalculator()); // Functor GameLevel currentLevel; EvilBadGuy ebg3(std::bind(&amp;GameLevel::health, currentLevel, std::placeholders::_1)); classical Strategy pattern (with virtual functions)make HealthCalcFunc be a seperate hierarchy of inheritance.```cppclass GameCharacter;class HealthCalcFunc {public: virtual int calc(const GameCharacter&amp; gc) const { }} defaultHealthCalc; class GameCharacter {public: explicit GameCharacter(HealthCalcFunc_ phcf = &amp;defaultHealthCalc) : pHealthFunc(phcf) {} int healthValue() const { return pHealthFun-&gt;(_this); }private: HealthCalcFunc* pHealthFunc;}; ### Never redefine an inherited non-virtual function ### Never redefine a function&#39;s inherited default parameter value * virtual functions is dynamically bound, but default parameter values is statically bound. * static type is the type declared, and dynamic type is the type pointed to currently. * use **NVI (non-virtual interface)** to substitute it. ```cpp class Shape { public: enum ShapeColor { Red, Green, Blue }; void draw(ShapeColor color = Red) const { doDraw(color); } private: virtual void doDraw(ShapeColor color) const = 0; }; class Rectangle: public Shape { public: // ... private: virtual void doDraw(ShapeColor color) const; }; Model “has-a” or “is-implemented-in-terms-of” through composition composition has many synonyms: layering, containment, aggregation, embedding. in application domain, composition means “has-a”, but in inplementation domain, it means “is-implemented-in-terms-of”. Use private inheritance judiciously private inheritance is a technique of implementation. private inheritance means only implementation is inherited and interfaces should be omitted. private inheritance is ok, when you want to redefine the inherited virtual functions. class Timer { public: explicit Timer(int tickFrequency); virtual void onTick() const; }; // Althrough Widget reuse Timer, it exposes `onTick` to the user class Widget: private Timer { private: virtual void onTick() const; }; // This one is kind of complicated, but it can prevent from using WidgetTimer // in the derived classes of Widget, (something like Java `final`, C# `sealed`) // Once changed to WidgetTimer*, it can also lower the compilation dependency class Widget { public: class WidgetTimer: public Timer { public: virtual void onTick() const; }; WidgetTimer timer; }; when facing space optimization, private inheritance may be the best choice.empty class: with no non-static variables, no virtual functions and no virtual base classes.EBO (empty class optimization) will let your base class take no space. Use multiple inheritance judiciouslyclass File { // ... }; class InputFile: public File { // ... }; class OutputFile: public File { // ... }; class IOFile: public InputFile, public OutputFile { // ... }; MI will copy the data through each inheritance path (such as File::name). once not, make the class with the data to be a virtual base class, and all the classes intermediately inherited virtual inherit it. class File { // ... }; class InputFile: virtual public File { // ... }; class OutputFile: virtual public File { // ... }; class IOFile: public InputFile, public OutputFile { // ... }; the initialization of virtual base class is granted to the most derived class. virtual inheritance will increase the cost of size, speed, and initialization(assignment).the virtual base classes with no data will be best-pratical situation. MI has some usages: one is the combination of “public inheritance inherits some interface class” and “private inheritance inherits some helper class for implementation”.class CPerson: public IPerson, private PersonInfo;]]></content>
      <categories>
        <category>Doing</category>
        <category>CPP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Implementations, Notes(5), Effective C++]]></title>
    <url>%2F2017%2F09%2F05%2Feffective-cpp-implementations%2F</url>
    <content type="text"><![CDATA[Implementations(I read a Chinese version of the book, any translation problem plz point out. Postpone variable definitions as long as possible until initial values can be providedMinimize casting old-style casts C style cast: (T)expression function style cast: T(expression) CPP style casts const_cast: cast away the constness. dynamic_cast: safe downcasting, to decide which type a object belongs to in the inheritance hierarchy. reinterpret_cast: low-level cast. static_cast: force implicit conversions. tips: dynamic_casts maybe implement based on the comparision on string names of classes. try to hide the cast in a function, then provide to customers, once it is a must. do use the CPP style cast. Avoid returning “handles” to object internalshandles: references, pointers, iteratorstry to use a copy class GUIObject { ... }; const Rectangle boundingBox(const GUIObject&amp; obj); GUIobject* pgo; // The temporary Point is destructed when the statement is over, // and the pUpperLeft is dangling. const Point* pUpperLeft = &amp;(boundingBox(*pgo).upperLeft()); Strive for exception-safe codewhen exception throws, exception-safe code will guarantee:class PrettyMenu { public: void changeBackground(std::istream&amp; imgSrc); private: Mutex mutex; Image* bgImage; int imageChanges; }; void PrettyMenu::changeBackground(std::istream&amp; imgSrc) { lock(&amp;mutex); delete bgImage; ++imageChanges; bgImage = newImage(imgSrc); unlock(&amp;mutex); } no resources leak.if new Image(imgSrc) throws, mutex will never release. no data break.if new Image(imgSrc) throw, bgImg will point to a deleted object.and the behavior of imageChanges will be weird, which it changed or not. exception-safe functions provide 3 guarantees: basic promise.when exception throws, everything is in a valid state, but the users can’t predict it. strong guarantee.when exception throws, the program remains unchanged. nothrow guaranteeint doSomething() throw();though the function throws nothing, it is not guaranteed. aka., if throws, it will be a fatal error, unexpected will be called (Google set_unexpected for detail).all the properties of the functions is decided by implementation, not the declaration. copy and swap// pimpl idiom struct PMImpl { std::shared_ptr&lt;Image&gt; bgImage; int imageChanges; }; class PrettyMenu { private: Mutex mutex; std::shared_ptr&lt;PMImpl&gt; pImpl; } void PrettyMenu::changeBackground(std::istream&amp; imgSrc) { using std::swap; Lock m1(&amp;mutex); // Use resource-managing class to manipulate mutex std::shared_ptr&lt;PMImpl&gt; pNew(new PMImpl(*pImpl)); // Copy pNew-&gt;bgImage.reset(new Image(imgSrc)); // Update the copy swap(pImpl, pNew); // Swap } even if strong guarantee can be implemented by copy and swap, but it is not implementable to all the functions. and watch the cost of copy. exception-safety is decided by the weakest one of all the functions. once you have no choice but to set no any guarantee (when you call the old code), document it. Understand the ins and outs of inlining inline just applys for inling to compiler, not forcing to do so. inline the minimal, frequently called functions. inline functions usually put in headers. because inlining happens in compiling period, compiler needs to know what they look like. the functions calls virtual functions will be never inlined, because virtual functions can only be known in run-time. think over before inling construtors and destrutors. maybe there are complicated codes generated by compilers. Minimize compilation dependencies between filespimpl idiom -&gt; handle classes // Person.h #include &lt;string&gt; #include &quot;datefwd.h&quot; #include &quot;addressfwd.h&quot; class Person { public: Person(const std::string&amp; name, const Date&amp; birthday, const Address&amp; addr); std::string name() const; std::string birthDate() const; std::string address() const; private: std::shared_ptr&lt;PersonImpl&gt; pImpl; }; // Person.cpp #include &quot;Person.h&quot; #include &quot;PersonImpl.h&quot; Person::Person(const std::string&amp; name, const Date&amp; birthday, const Address&amp; addr) : pImpl(new PersonImpl(name, birthday, addr)) {} std::string Person::name() const { return pImpl-&gt;name(); } abstract base class -&gt; interface class class Person { public: virtual ~Person(); virtual std::string name() const = 0; virtual std::string birthDate() const = 0; virtual std::string address() const = 0; static std::shared_ptr&lt;Person&gt; create(const std::string&amp; name, const Date&amp; birthday, const Address&amp; addr); }; class RealPerson: public Person { public: RealPerson(const std::string&amp; name, const Date&amp; birthday, const Address&amp; addr) : name(name), birthday(birthday), addr(addr) {} virtual ~RealPerson() {} std::string name() const; std::string birthDate() const; std::string address() const; }; std::shared_ptr&lt;Person&gt; create(const std::string&amp; name, const Date&amp; birthday, const Address&amp; addr) { return std::shared_ptr&lt;Person&gt;(new RealPerson(name, birthday, addr)); } don’t use objects, if object references or object pointers achieves. replace class definitions with class declarations as much as possible. provide declaration and definition with different headers. use handle classes and interface classes to minimize changes for users during the develpment of program.but replace with concrete classes, when the great difference in speed or size compared to coupling between classes.]]></content>
      <categories>
        <category>Doing</category>
        <category>CPP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Designs and Declarations, Notes(4), Effective C++]]></title>
    <url>%2F2017%2F09%2F04%2Feffective-cpp-designs-and-declarations%2F</url>
    <content type="text"><![CDATA[Designs and Declarations(I read a Chinese version of the book, any translation problem plz point out. Make interfaces easy to use correctly and hard to use incorrectly introduce a new type.Data d(Month(9), Day(4), Year(2017)); restrict some invalid operations on types.add const is a useful way.```cppif(a * b = c) // … // It will avoid the problem above.const Type operator*(const Type&amp; a, const Type&amp; b); * predefine all the valid values, if we want type safety. ```cpp class Month { public: static Month Jan() { return Month(1); } static Month Feb() { return Month(2); } // ... static Month Dec() { return Month(12); } // ... private: explicit Month(int m); // ... }; make interfaces be compatible with built-in types, aka. providing the interfaces of consistent behaviors. force users to use smart pointers. e.g., factory function returns a smart pointer.std::shared_ptr&lt;Investment&gt; createInvestment(); Treat class design as type designQuestions to think: create and destroy initialize and assign pass by value -&gt; copy constructor valid values -&gt; invariants(约束) inheritance conversion functions and operators access specifiers undeclared interface ??? generalization -&gt; templates really need a new type? maybe some non-member functions or templates achieve the goal. Prefer pass-by-reference-to-const to pass-by-value avoid any construction and destructions, more efficient. avoid the slicing problem brought by derived class upcast to base class. pass-by-value is proper for built-in types, e.g., STL iterators and functors. Don’t try to return a reference when you must return an objecttry the one that behave correctly, and throw the responsibility to the compilers. Prefer non-member, non-friend functions to member functionsa natural way, let tool function be a non-member function and put inside the same namespace where the classes it operates is.then, for future expansion of more tool functions, sperate them in new headers but in the same namespaces.increase encapsulation, packaging flexibility, and function expansibility. // webbrowser.h // Main functionalities of webbrowser. namespace WebBrowserStuff { class WebBrowser { public: // ... void clearCache(); void clearHistory(); void removeCookies(); // ... }; void clearBrowser(WebBrowser&amp; wb) { wb.clearCache(); wb.clearHistory(); wb.removeCookies(); } } // webbrowser_bookmarks.h namespace WebBrowserStuff { // Some tool functions related to bookmarks. // ... } // webbrowser_cookies.h namespace WebBrowserStuff { // Some tool functions related to cookies. // ... } Declare non-member functions when type conversions should apply to all parameters The parameter can be a participant of implicit type conversion, only when the parameter is in parameter list. friend should be avoided when it can be.Observation: non-member functions is the opposite of member ones, not the friend functions. Consider support for a non-throwing swapfor pointer to implementation (pimpl), more efficient way is to do: provide a public member swap function, this function should never throw, because it is the insurance for exception safety.moreover, the default swap is used for built-in types and the built-in types never throws, we should keep consistent. provide a non-member swap which calls the member swap in the namespace where your class or template is. provide a std::swap total template specilization, if you’re trying to design a class not a class template.class Widget { public: void swap(Widget&amp; other) { using std::swap; swap(pImpl, other.pImpl); } }; namespace std { template&lt;&gt; // Total template specilization void swap&lt;Widget&gt;(Widget&amp; a, Widget&amp; b) { a.swap(b); } } we are not allowed to change anything in namespace std, but we can create specialization.it is a UB, if you insist on doing so. CPP points out, we can only paritially specialized class templates, function templates is not allowed. so provide non-member swap for function templates. namespace WidgetStuff { template&lt;typename T&gt; class Widget { ... }; template&lt;typename T&gt; // Non-member function void swap(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b) { a.swap(b); } } when calling swap, please ensure a using std::swap, then call swap directly without any namespace specifier.let the compiler to find a proper one.CPP name lookup rules (argument-dependent lookup or Koenig lookup rule):try to find a specific swap of T in global scope or the namespace where T is, then the generic one (std::swap).template&lt;typename T&gt; void doSomething(T&amp; obj1, T&amp; obj2) { using std::swap; // ... swap(obj1, obj2); // ... }]]></content>
      <categories>
        <category>Doing</category>
        <category>CPP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Resource Management, Notes(3), Effective C++]]></title>
    <url>%2F2017%2F08%2F31%2Feffective-cpp-resource-management%2F</url>
    <content type="text"><![CDATA[Resource Management(I read a Chinese version of the book, any translation problem plz point out. Use objects to manage resources Priciples put into managing object when acquired resources(Resource Acquistion Is Initialization; RAII). managing object uses destructor to ensure the resources is released. Methods auto_ptronce be assigned, the right side one is null.so the feature of abnormal assignment operator makes that it can’t be put into containers. referencing-counting smart pointer (RCSP)it can’t break cycles of references.it seems they’re in the “used” status when 2 unused objects point to each other. Think carefully about copying behavior in resource-managing classes create a class to do this. no copying. -&gt; =delete or inherit from uncopyable reference-count in the low-level resources (shared_ptr).class Lock { public: explicit Lock(Mutex* pm): mutexPtr(pm, unlock) { lock(mutexPtr.get()); } } private: std::shared_ptr&lt;Mutex&gt; mutexPtr; }; deep copying.copy wrapped resources when copying the resource-managing object. transfer the ownership of low-level resources (auto_pr). Provide access to raw resources in resource-managing classesSometimes we need to provide compatibility to C APIs. provide a get() to access the raw pointer, safer.```cpp// C APIs.FontHandle getFont();void releaseFont(FontHandle fh); Class Font {public: explicit Font(FontHandle fh): f(fh) {} ~Font() { releaseFont(f); } // … FontHandle get() const { return f; } // …private: FontHandle f; // Raw font resources}; * provide implicit conversion function may offer convenience to customers. but the opportunities of unexpected error is increased. ```cpp class Font { public: // ... operator FontHandle() const { return f; } // .. } Font f1(getFont()); // It is intended to copy a Font object // but f1 is copied after it is implicitly conversed to FontHandle FontHandle f2 = f1; no contradiction with encapsulation, just to ensure resource releasing. Use the same form in corresponding uses of new and deletenew-&gt;deletenew[]-&gt;delete[] Tips:use containers to reduce the risk misusing delete when releasing memory of typedefined array.typedef std::string stringArray[4]; std::string* pal = new stringArray; delete pal; // Undefined Behavior delete pal[]; // Good Stored newed objects in smart pointers in standalone statements look at the code below:```cppint priority();void processWidget(std::shared_ptr pw, int priority); processWidget(std::shared_ptr(new Widget), priority()); * it is free for the compiler to reorder the operations inside one statement, what if in this order: `new Widget -&gt; priority() -&gt; shared_ptr` * once `priority()` throws, the newed pointer will be lost and memory leak may happen. * the compiler can&#39;t reorder the operations between statements, so the code below avoids the risk above. ```cpp std::shared_ptr&lt;Widget&gt; pw(new Widget); processWidget(pw, priority());]]></content>
      <categories>
        <category>Doing</category>
        <category>CPP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Notes, Hive Tutorial]]></title>
    <url>%2F2017%2F08%2F25%2Fhive-tut-notes%2F</url>
    <content type="text"><![CDATA[Last Modified: 2017-08-28 16:49:00 Acknowledge What is Hive?Hive is a data warehouse infrastructure tool to process structured data in Hadoop. It resides on top of Hadoop to summarize Big Data, and makes querying and analyzing easy. Official Hive TutorialTutorial IntroductionHive - Introduction Big Data Hadoop MapReduce HDFS Tools Sqoop Pig Hive Hivesee the link above for details SyntaxSyntax is omitted, see the reference for details Views And IndexesDifference between view and index Select JoinsInner Join vs Outer JoinInner Join vs Natural Join, Natural Join is just short syntax for a specific Inner Join JOIN (same as INNER JOIN)JOIN clause is used to combine and retrieve the records from multiple tables.(It only shows the matched result) LEFT OUTER JOINLEFT OUTER JOIN returns all the rows from the left table, even if there are no matches in the right table. This means, if the ON clause matches 0 (zero) records in the right table, the JOIN still returns a row in the result, but with NULL in each column from the right table. RIGHT OUTER JOINRIGHT OUTER JOIN returns all the rows from the right table, even if there are no matches in the left table. If the ON clause matches 0 (zero) records in the left table, the JOIN still returns a row in the result, but with NULL in each column from the left table. FULL OUTER JOINFULL OUTER JOIN combines the records of both the left and the right outer tables that fulfil the JOIN condition. The joined table contains either all the records from both the tables, or fills in NULL values for missing matches on either side. ReferenceLearn HiveHive Language Manual]]></content>
      <categories>
        <category>Doing</category>
        <category>Hive</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Notes, Most Useful Shell Command]]></title>
    <url>%2F2017%2F08%2F25%2Fmost-useful-shell-commands%2F</url>
    <content type="text"><![CDATA[Last Modified: 2017-08-25 10:57:10 TODO: grep expect awk sed xargs expect]]></content>
      <categories>
        <category>Doing</category>
        <category>Shell</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Solutions, Leetcode Shell Problems]]></title>
    <url>%2F2017%2F08%2F07%2Fleetcode-shell-problems-solution%2F</url>
    <content type="text"><![CDATA[Last Modified: 2017-08-25 10:53:10 193. Valid Phone Numbers 195. Tenth Line 192. Word Frequency 194. Tranpose File 193. Valid Phone NumbersYou may assume that a valid phone number must appear in one of the following two formats: (xxx) xxx-xxxx or xxx-xxx-xxxx. (x means a digit) # Read from the file file.txt and output all valid phone numbers to stdout. grep -E &#39;^(([0-9]{3}-[0-9]{3}-[0-9]{4})|(\([0-9]{3}\) [0-9]{3}-[0-9]{4}))$&#39; file.txt 195. Tenth LineHow would you print just the 10th line of a file? # Read from the file file.txt and output the tenth line to stdout. line_num=0 while read line &amp;&amp; ((line_num &lt; 10)); do line_num=$line_num+1 if ((line_num == 10)); then echo $line break fi done &lt; file.txt 192. Word Frequency# Read from the file words.txt and output the word frequency list to stdout. declare -A freq while read word; do ((++freq[$word])) done &lt; &lt;(tr -s &quot; &quot; &quot;\n&quot; &lt; words.txt) # echo ${words[*]} for word in ${!freq[*]}; do echo $word ${freq[$word]} done | sort -k 2nbr it seems that there some problems with shell array… ➜ ~ a+=1 ➜ ~ a+=1 ➜ ~ echo ${a[*]} 11 ➜ ~ for i in ${a[*]}; do for&gt; echo $i for&gt; done 11 ➜ ~ for i in ${a[@]}; do for&gt; echo $i for&gt; done 11 ➜ ~ for i in &quot;${a[@]}&quot;; do for&gt; echo $i for&gt; done 11 ➜ ~ for i in &quot;${a[*]}&quot;; do for&gt; echo $i for&gt; done 11 ➜ ~ echo ${a[1]} 1 ➜ ~ echo ${a[2]} 1 ➜ ~ echo &#39;num of elemets=&#39;${#a[*]} num of elemets=2 # it looks rather werid... so avoid using it... 194. Tranpose FileGiven a text file file.txt, transpose its content.You may assume that each row has the same number of columns and each field is separated by the &#39; &#39; character.For example, if file.txt has the following content: name age alice 21 ryan 30 # Output the following: name alice ryan age 21 30 # Read from the file file.txt and print its transposed content to stdout. awk &#39; { for(i = 1; i &lt;= NF; ++i) { if(1 == NR) { s[i] = $i; } else { s[i] = s[i] &quot; &quot; $i } } } END { for(i = 1; s[i] != &quot;&quot;; ++i) { print s[i]; } }&#39; file.txt]]></content>
      <categories>
        <category>Doing</category>
        <category>Shell</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Notes, Effective Go]]></title>
    <url>%2F2017%2F08%2F04%2Feffective-go-notes%2F</url>
    <content type="text"><![CDATA[Last Modified: 2017-08-23 11:46:10 Hard to say, I finished Go, for about 20 days (except busy for 1 week and training for 1 week). Such a long time, 1 week to learn a new language, having known a little about concurrency. Not so bad. AcknowledgeGo is a new language. Although it borrows ideas from existing languages, it has unusual properties that make effective Go programs different in character from programs written in its relatives.The notes below was written from the view of a CPP programmer. and a hello world package main import &quot;fmt&quot; func main() { fmt.Println(&quot;Hello, World&quot;) } SyntaxBasics function func swap(x, y string) (string, string) { return y, x } func split(sum int) (x, y int) { x = sum * 4 / 9 y = sum - x return } variable var c, python, java bool var i, j int = 1, 2 var c, python, java = true, false, &quot;no!&quot; k := 3 // only can be used inside function basic types bool string int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr byte // alias for uint8 rune // alias for int32 // represents a Unicode code point float32 float64 complex64 complex128 // The int, uint, and uintptr types are usually 32 bits wide on 32-bit systems and 64 bits wide on 64-bit systems. var blocks var ( ToBe bool = false MaxInt uint64 = 1&lt;&lt;64 - 1 z complex128 = cmplx.Sqrt(-5 + 12i) ) zero valuesVariables declared without an explicit initial value are given their zero value.0 for numeric types,false for the boolean type, and&quot;&quot; (the empty string) for strings. type conversions var i int = 42 var f float64 = float64(i) var u uint = uint(f) // more simply i := 42 f := float64(i) u := uint(f) type inference var i int j := i // j is an int 3 i := 42 // int f := 3.142 // float64 g := 0.867 + 0.5i // complex128 constants const Pi = 2.14 const Truth bool = true // numeric constants are high-precision values. const ( Big = 1 &lt;&lt; 100 Small = Big &gt;&gt; 99 ) Flow control for for i := 0; i &lt; 10; i++ { // do something } for ; i &lt; 10; { // do something } // C&#39;s `while` is spelled `for` in Go i := 0 for i &lt; 10 { // do something } // loop forever for { // do something } if if i &lt; 10 { // do something } else { // do something } if i &lt; 10 { // do something } else if i &lt; 100 { // do something } // if with a short statement // variables declared by the statement are only in scope until the end of the if. if v := 1; v &lt; 10 { // do something } exercise-loops-and-functions.go package main import ( &quot;fmt&quot; &quot;math&quot; ) func Sqrt(x float64) float64 { var cur float64 = x for nxt := 0.0; math.Abs(nxt - cur) &gt; 1e-8; { t := cur - (cur * cur - x) / (2 * cur) nxt = cur cur = t } return cur } func main() { fmt.Println(Sqrt(2)) } switch // a case body breaks automatically, unless it ends with a &#39;fallthrough&#39; statement. fmt.Print(&quot;Go runs on &quot;) switch os := runtime.GOOS; os { case &quot;darwin&quot;: fmt.Println(&quot;OS X.&quot;) case &quot;linux&quot;: fmt.Println(&quot;Linux.&quot;) default: // freebsd, openbsd, // plan9, windows... fmt.Printf(&quot;%s.&quot;, os) } // switch with no condition t := time.Now() switch { case t.Hour() &lt; 12: fmt.Println(&quot;Good morning!&quot;) case t.Hour() &lt; 17: fmt.Println(&quot;Good afternoon.&quot;) case t.Hour() &lt; 24: fmt.Println(&quot;One more&quot;) fallthrough default: fmt.Println(&quot;Good evening.&quot;) } defer // deferred function calls are pushed onto a stack. // when a function returns, its deferred calls are executed in last-in-first-out order. func main() { fmt.Println(&quot;counting&quot;) for i := 0; i &lt; 3; i++ { defer fmt.Println(i) } fmt.Println(&quot;done&quot;) } /* counting done 2 1 0 */ More types pointers // the type *T is a pointer to a T value. // its zero value is nil. var p *int i := 42 p = &amp;i fmt.Println(*p) // read i through the pointer p *p = 21 // set i through the pointer p struct type Vertex struct { X int Y int } var v Vertex = Vertex{2, 3} // v := VertexP{2, 3} p := &amp;v // pointer to structs v.x = 1e9 p.X = 1e9 // implicit conversion ??? // struct literals var ( v1 = Vertex{1, 2} // has type Vertex v2 = Vertex{X: 1} // Y:0 is implicit v3 = Vertex{} // X:0 and Y:0 p = &amp;Vertex{1, 2} // has type *Vertex ) array var prime [6]int = [6]int{2, 3, 5, 7, 11, 13} slices // slices are like references to arrays var s []int = primes[1:4] // array literal [3]bool{true, true, false} // slice literal []bool{true, true, false} // slice defaults // the default is zero for the low bound and the length of the slice for the high bound. // these slice expressions are equivalent: a[0:10] a[:10] a[0:] a[:] // nil slices // A nil slice has a length and capacity of 0 and has no underlying array. var s []int fmt.Println(s, len(s), cap(s)) if s == nil { fmt.Println(&quot;nil!&quot;) } /* [] 0 0 nil! */ slice length and capacity package main import &quot;fmt&quot; func main() { s := []int{2, 3, 5, 7, 11, 13} printSlice(s) // Slice the slice to give it zero length. s = s[:0] printSlice(s) // Extend its length. s = s[:4] printSlice(s) // Drop its first two values. s = s[2:] printSlice(s) } func printSlice(s []int) { fmt.Printf(&quot;len=%d cap=%d %v\n&quot;, len(s), cap(s), s) } /* len=6 cap=6 [2 3 5 7 11 13] len=0 cap=6 [] len=4 cap=6 [2 3 5 7] len=2 cap=4 [5 7] */ creating a slice with makeslices can be created with the built-in make function;this is how you create dynamically-sized arrays. b := make([]int, 0, 5) // len(b)=0, cap(b)=5 slices of slices board := [][]string{ []string{&quot;_&quot;, &quot;_&quot;, &quot;_&quot;}, []string{&quot;_&quot;, &quot;_&quot;, &quot;_&quot;}, []string{&quot;_&quot;, &quot;_&quot;, &quot;_&quot;}, } for i := 0; i &lt; len(board); i++ { fmt.Printf(&quot;%s\n&quot;, strings.Join(board[i], &quot; &quot;)) } apending to a slice // func append(s []T, vs ...T) []T var s []int s = append(s, 1) s = append(s, 2, 3, 4) // append slice x := []int{1,2,3} y := []int{4,5,6} x = append(x, y...) range var pow = []int{1, 2, 4, 8, 16, 32, 64, 128} for i, v := range pow { fmt.Printf(&quot;2**%d = %d\n&quot;, i, v) } // skip the index or value pow := make([]int, 10) for i := range pow { pow[i] = 1 &lt;&lt; uint(i) // == 2**i } for _, value := range pow { fmt.Printf(&quot;%d\n&quot;, value) } exercise-slices.go package main import &quot;golang.org/x/tour/pic&quot; func Pic(dx, dy int) [][]uint8 { var pic [][]uint8 = make([][]uint8, dy) for i := 0; i &lt; dy; i++ { pic[i] = make([]uint8, dx) for j := 0; j &lt; dx; j++ { pic[i][j] = uint8(i ^ j); } } return pic } func main() { pic.Show(Pic) } mapsThe zero value of a map is nil. A nil map has no keys, nor can keys be added. type Vertex struct { Lat, Long float64 } var m map[string]Vertex m = make(map[string]Vertex) m[&quot;Bell Labs&quot;] = Vertex{ 40.68433, -74.39967, } fmt.Println(m[&quot;Bell Labs&quot;]) // map literals var m = map[string]Vertex{ &quot;Bell Labs&quot;: Vertex{ 40.68433, -74.39967, }, &quot;Google&quot;: Vertex{ 37.42202, -122.08408, }, } // If the top-level type is just a type name, you can omit it from the elements of the literal. var m = map[string]Vertex{ &quot;Bell Labs&quot;: {40.68433, -74.39967}, &quot;Google&quot;: {37.42202, -122.08408}, } // mutating maps // insert or update an element in map m: m[key] = elem // retrieve an element: elem = m[key] // delete an element: delete(m, key) // test that a key is present with a two-value assignment: elem, ok = m[key] exercise-maps.go package main import ( &quot;golang.org/x/tour/wc&quot;; &quot;strings&quot; ) func WordCount(s string) map[string]int { word := strings.Split(s, &quot; &quot;) var mp map[string]int = make(map[string]int) for i := 0; i &lt; len(word); i++ { mp[word[i]] += 1 } return mp } func main() { wc.Test(WordCount) } funtion values func compute(fn func(float64, float64) float64) float64 { return fn(3, 4) } func main() { hypot := func(x, y float64) float64 { return math.Sqrt(x*x + y*y) } fmt.Println(hypot(5, 12)) fmt.Println(compute(hypot)) fmt.Println(compute(math.Pow)) } closure a closure is a function value that references variables from outside its body.the function may access and assign to the referenced variables; in this sense the function is “bound” to the variables. // each closure is bound to its own sum variable. func adder() func(int) int { sum := 0 return func(x int) int { sum += x return sum } } func main() { pos, neg := adder(), adder() for i := 0; i &lt; 3; i++ { fmt.Println( pos(i), neg(-2*i), ) } } /* 0 0 1 -2 3 -6 */ function-closures.go package main import &quot;fmt&quot; // fibonacci is a function that returns // a function that returns an int. func fibonacci() func() int { var f0, f1 int = 0, 1 return func() int { ret := f0 f0, f1 = f1, f0 + f1 return ret } } func main() { f := fibonacci() for i := 0; i &lt; 10; i++ { fmt.Println(f()) } } Methods and interfacesmethods go does not have classes. However, you can define methods on types. a method is a function with a special receiver argument. the receiver appears in its own argument list between the func keyword and the method name type Vertex struct { X, Y float64 } func (v Vertex) Abs() float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) } declare a method on non-struct types type Vertex struct { X, Y float64 } func (v Vertex) Abs() float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) } func (v *Vertex) Scale(f float64) { v.X = v.X * f v.Y = v.Y * f } func main() { v := Vertex{3, 4} v.Scale(10) fmt.Println(v.Abs()) } In general, all methods on a given type should have either value or pointer receivers, but not a mixture of both. interfacesan interface type is defined as a set of method signatures.a value of interface type can hold any value that implements those methods. interfaces are implemented implicitlyimplicit interfaces decouple the definition of an interface from its implementation, which could then appear in any package without prearrangement. interface valuesan interface value holds a value of a specific underlying concrete type.it can be thought of as a tuple of a value and a concrete type: (value, type) interface values can be with nil underlying values. type I interface { M() } type T struct { S string } // This method means type T implements the interface I, // but we don&#39;t need to explicitly declare that it does so. func (t T) M() { if t == nil { fmt.Println(&quot;&lt;nil&gt;&quot;) return } fmt.Println(t.S) } func describe(i I) { fmt.Printf(&quot;(%v, %T)\n&quot;, i, i) } func main() { var i I describe(i) // nil interface value -&gt; run-time error var t *T i = t describe(i) // nil receiver -&gt; OK i.M() i = &amp;T{&quot;hello&quot;} describe(i) i.M() } empty interfacean empty interface may hold values of any type. (every type implements at least zero methods.)empty interfaces are used by code that handles values of unknown type. var i interface{} i = 42 i = &quot;hello&quot; type assertions // if i does not hold a type T, the statement will trigger a panic. t := i.(T) // if i does not hold a type T, ok will be false // and t will be the zero value of type T, and no panic occurs. t, ok := i.(T) type switches package main import &quot;fmt&quot; func do(i interface{}) { switch v := i.(type) { case int: fmt.Printf(&quot;Twice %v is %v\n&quot;, v, v*2) case string: fmt.Printf(&quot;%q is %v bytes long\n&quot;, v, len(v)) default: fmt.Printf(&quot;I don&#39;t know about type %T!\n&quot;, v) } } func main() { do(21) do(&quot;hello&quot;) do(true) } Stringers and error // a Stringer is a type that can describe itself as a string. type Stringer interface { String() string } // the error type is a built-in interface similar to fmt.Stringer type error interface { Error() string } // for example, fmt.Println will call the two interfaces exercise-stringer.go package main import &quot;fmt&quot; type IPAddr [4]byte // TODO: Add a &quot;String() string&quot; method to IPAddr. func (t *IPAddr) String() string { return fmt.Sprintf(&quot;%v.%v.%v.%v&quot;, t[0], t[1], t[2], t[3]) } func main() { hosts := map[string]IPAddr{ &quot;loopback&quot;: {127, 0, 0, 1}, &quot;googleDNS&quot;: {8, 8, 8, 8}, } for name, ip := range hosts { fmt.Println(ip.String()) fmt.Printf(&quot;%v: %v\n&quot;, name, ip) } } exercise-errors.go package main import ( &quot;fmt&quot; ) type ErrNegativeSqrt float64 func (e ErrNegativeSqrt) Error() string { return fmt.Sprintf(&quot;cannot Sqrt negative number: %v&quot;, float64(e)) } func Sqrt(x float64) (float64, error) { if x &lt; 0 { return 0, ErrNegativeSqrt(x) } z := 1.0 for i := 0; i &lt; 10; i++ { z = z - (z * z - x) / (2 * z), y } return z, nil } func main() { fmt.Println(Sqrt(2)) fmt.Println(Sqrt(-2)) } readersinterface io.Reader::Readfunc (T) Read(b []byte) (n int, err error) exercise-reader.go package main import &quot;golang.org/x/tour/reader&quot; type MyReader struct{} // TODO: Add a Read([]byte) (int, error) method to MyReader. func (t MyReader) Read(b []byte) (int, error) { for i := 0; i &lt; len(b); i++ { b[i] = &#39;A&#39; } return len(b), nil } func main() { reader.Validate(MyReader{}) } exercise-rot-reader.go package main import ( &quot;io&quot; &quot;os&quot; &quot;strings&quot; ) type rot13Reader struct { r io.Reader } func (r rot13Reader) Read(b []byte) (n int, err error) { insideR := r.r if n, err = insideR.Read(b); err != nil { return } for i := 0; i &lt; n; i++ { if b[i] &gt;= &#39;a&#39; &amp;&amp; b[i] &lt;= &#39;z&#39; { b[i] = (b[i] - &#39;a&#39; + 13) % 26 + &#39;a&#39; } else if b[i] &gt;= &#39;A&#39; &amp;&amp; b[i] &lt;= &#39;Z&#39; { b[i] = (b[i] - &#39;A&#39; + 13) % 26 + &#39;A&#39; } } return } func main() { s := strings.NewReader(&quot;Lbh penpxrq gur pbqr!&quot;) r := rot13Reader{s} io.Copy(os.Stdout, &amp;r) } exercise-images.go package main import ( &quot;golang.org/x/tour/pic&quot; &quot;image&quot; &quot;image/color&quot; ) /* type Image interface { ColorModel() color.Model Bounds() Rectangle At(x, y int) color.Color } */ type Image struct{ Width, Height int } func (img Image) ColorModel() color.Model { return color.RGBAModel } func (img Image) Bounds() image.Rectangle { return image.Rect(0, 0, img.Width, img.Height) } func (img Image) At(x, y int) color.Color { return color.RGBA{uint8(x * y), uint8((x + y) / 2), 100, 255} } func main() { m := Image{100, 100} pic.ShowImage(m) } ConcurrencygoroutinesA goroutine is a lightweight thread managed by the Go runtime.go f(x, y, z) starts a new goroutine running f(x, y, z).The evaluation of f, x, y, and z happens in the current goroutine and the execution of f happens in the new goroutine.Goroutines run in the same address space, so access to shared memory must be synchronized. channelsChannels are a typed conduit(pipe) through which you can send and receive values with the channel operator, &lt;-.By default, sends and receives block until the other side is ready. This allows goroutines to synchronize without explicit locks or condition variables. // (The data flows in the direction of the arrow.) // Like maps and slices, channels must be created before use: ch := make(chan int) ch &lt;- v // Send v to channel ch. v := &lt;-ch // Receive from ch, and // assign value to v. buffered ChannelsChannels can be buffered. Provide the buffer length as the second argument to make to initialize a buffered channel:ch := make(chan int, 100)Sends to a buffered channel block only when the buffer is full. Receives block when the buffer is empty. range and closev, ok := &lt;-chok is false if there are no more values to receive and the channel is closed.The loop for i := range c receives values from the channel repeatedly until it is closed. Note: Only the sender should close a channel, never the receiver. Sending on a closed channel will cause a panic. Another note: Channels aren’t like files; you don’t usually need to close them.Closing is only necessary when the receiver must be told there are no more values coming, such as to terminate a range loop. func fibonacci(n int, c chan int) { x, y := 0, 1 for i := 0; i &lt; n; i++ { c &lt;- x x, y = y, x+y } close(c) } func main() { c := make(chan int, 10) go fibonacci(cap(c), c) for i := range c { fmt.Println(i) } } selectThe select statement lets a goroutine wait on multiple communication operations.A select blocks until one of its cases can run, then it executes that case.It chooses one at random if multiple are ready. Use a default case to try a send or receive without blocking: func fibonacci(c, quit chan int) { x, y := 0, 1 for { select { case c &lt;- x: x, y = y, x+y case &lt;-quit: fmt.Println(&quot;quit&quot;) return } default: // receiving from c would block } } func main() { c := make(chan int) quit := make(chan int) go func() { for i := 0; i &lt; 10; i++ { fmt.Println(&lt;-c) } quit &lt;- 0 }() fibonacci(c, quit) } sync.MutexWe’ve seen how channels are great for communication among goroutines.But what if we don’t need communication? What if we just want to make sure only one goroutine can access a variable at a time to avoid conflicts?This concept is called mutual exclusion, and the conventional name for the data structure that provides it is mutex.Go’s standard library provides mutual exclusion with sync.Mutex and its two methods:Lock, Unlock type SafeCounter struct { v map[string]int mux sync.Mutex } // Inc increments the counter for the given key. func (c *SafeCounter) Inc(key string) { c.mux.Lock() // Lock so only one goroutine at a time can access the map c.v. c.v[key]++ c.mux.Unlock() } // Value returns the current value of the counter for the given key. func (c *SafeCounter) Value(key string) int { c.mux.Lock() // Lock so only one goroutine at a time can access the map c.v. defer c.mux.Unlock() return c.v[key] } exercise-equivalent-binary-trees.go package main import ( &quot;golang.org/x/tour/tree&quot; &quot;fmt&quot; ) // Walk walks the tree t sending all values // from the tree to the channel ch. func Walk(t *tree.Tree, ch chan int) { defer close(ch) var walker func(t *tree.Tree) walker = func(t *tree.Tree) { if t == nil { return } walker(t.Left) ch &lt;- t.Value walker(t.Right) } walker(t) } // Same determines whether the trees // t1 and t2 contain the same values. func Same(t1, t2 *tree.Tree) bool { ch1 := make(chan int) ch2 := make(chan int) go Walk(t1, ch1) go Walk(t2, ch2) for x1 := range ch1 { x2, ok2 := &lt;-ch2 if !ok2 || x1 != x2 { return false } } return true } func main() { fmt.Println(Same(tree.New(1), tree.New(1))) fmt.Println(Same(tree.New(1), tree.New(2))) } exercise-web-crawler.go package main import ( &quot;fmt&quot; &quot;sync&quot; ) type Fetcher interface { // Fetch returns the body of URL and // a slice of URLs found on that page. Fetch(url string) (body string, urls []string, err error) } type Cache struct { visited map[string]bool mtx sync.Mutex } type Response struct { url string body string } // Crawl uses fetcher to recursively crawl // pages starting with url, to a maximum of depth. func Crawl(url string, depth int, fetcher Fetcher, result chan Response, cache Cache) { // TODO: Fetch URLs in parallel. // TODO: Don&#39;t fetch the same URL twice. // This implementation doesn&#39;t do either: defer close(result) if depth &lt;= 0 { return } cache.mtx.Lock() if cache.visited[url] { cache.mtx.Unlock() return } cache.visited[url] = true cache.mtx.Unlock() body, urls, err := fetcher.Fetch(url) if err != nil { fmt.Println(err) return } result &lt;- Response{url, body} // fmt.Printf(&quot;found: %s %q\n&quot;, url, body) for _, u := range urls { tempResult := make(chan Response) go Crawl(u, depth-1, fetcher, tempResult, cache) for re := range tempResult { result &lt;- re } } return } func main() { result := make(chan Response) go Crawl(&quot;http://golang.org/&quot;, 4, fetcher, result, Cache{visited:make(map[string]bool)}) for re := range result { fmt.Printf(&quot;found: %s %q\n&quot;, re.url, re.body) } } // fakeFetcher is Fetcher that returns canned results. type fakeFetcher map[string]*fakeResult type fakeResult struct { body string urls []string } func (f fakeFetcher) Fetch(url string) (string, []string, error) { if res, ok := f[url]; ok { return res.body, res.urls, nil } return &quot;&quot;, nil, fmt.Errorf(&quot;not found: %s&quot;, url) } // fetcher is a populated fakeFetcher. var fetcher = fakeFetcher{ &quot;http://golang.org/&quot;: &amp;fakeResult{ &quot;The Go Programming Language&quot;, []string{ &quot;http://golang.org/pkg/&quot;, &quot;http://golang.org/cmd/&quot;, }, }, &quot;http://golang.org/pkg/&quot;: &amp;fakeResult{ &quot;Packages&quot;, []string{ &quot;http://golang.org/&quot;, &quot;http://golang.org/cmd/&quot;, &quot;http://golang.org/pkg/fmt/&quot;, &quot;http://golang.org/pkg/os/&quot;, }, }, &quot;http://golang.org/pkg/fmt/&quot;: &amp;fakeResult{ &quot;Package fmt&quot;, []string{ &quot;http://golang.org/&quot;, &quot;http://golang.org/pkg/&quot;, }, }, &quot;http://golang.org/pkg/os/&quot;: &amp;fakeResult{ &quot;Package os&quot;, []string{ &quot;http://golang.org/&quot;, &quot;http://golang.org/pkg/&quot;, }, }, } Language specificationFormatting gofmt ? IndentationWe use tabs for indentation and gofmt emits them by default. Use spaces only if you must. Line lengthGo has no line length limit. Don’t worry about overflowing a punched card. If a line feels too long, wrap it and indent with an extra tab. ParenthesesGo needs fewer parentheses than C and Java: control structures (if, for, switch) do not have parentheses in their syntax. Also, the operator precedence hierarchy is shorter and clearer, so x&lt;&lt;8 + y&lt;&lt;16 means what the spacing implies, unlike in the other languages. Commentary Go provides C-style /* */ block comments and C++-style // line comments. Line comments are the norm; Block comments appear mostly as package comments, but are useful within an expression or to disable large swaths of code. Every exported (capitalized) name in a program should have a doc comment. Doc comments work best as complete sentences, which allow a wide variety of automated presentations. The first sentence should be a one-sentence summary that starts with the name being declared. Names Package namesBy convention, packages are given lower case, single-word names; there should be no need for underscores or mixedCaps. For example, the package in src/encoding/base64 is imported as &quot;encoding/base64&quot; but has name base64, not encoding_base64 and not encodingBase64. Clear and Concise Namering.Newonce.Do Getters and SettersIf you have a field called owner (lower case, unexported), the getter method should be called Owner (upper case, exported), not GetOwner.owner := obj.Owner() if owner != user { obj.SetOwner(user) } Interface namesBy convention, one-method interfaces are named by the method name plus an -er suffix or similar modification to construct an agent noun: Reader, Writer, Formatter, CloseNotifier etc. MixedCapsFinally, the convention in Go is to use MixedCaps or mixedCaps rather than underscores to write multiword names. Semicolons Like C, Go’s formal grammar uses semicolons to terminate statements, but unlike in C, those semicolons do not appear in the source. If the last token before a newline is an identifier, the lexer always inserts a semicolon after the token. This could be summarized as, “if the newline comes after a token that could end a statement, insert a semicolon”. // identifiers break continue fallthrough return ++ -- ) } One consequence of the semicolon insertion rules is that you cannot put the opening brace of a control structure (if, for, switch, or select) on the next line.If you do, a semicolon will be inserted before the brace, which could cause unwanted effects. // right if i &lt; f() { g() } // wrong if i &lt; f() { g() } Redeclaration and reassignmentIn a := declaration a variable v may appear even if it has already been declared, provided: this declaration is in the same scope as the existing declaration of v (if v is already declared in an outer scope, the declaration will create a new variable), the corresponding value in the initialization is assignable to v, and there is at least one other variable in the declaration that is being declared a new. f, err := os.Open(name) d, err := f.Stat() Data Allocation with newnew(T) returns a pointer to a newly allocated zero value of type T. Allocation with makemake(T, args) serves a purpose different from new(T).It creates slices, maps, and channels only, and it returns an initialized (not zeroed) value of type T (not *T).The reason for the distinction is that these three types represent, under the covers, references to data structures that must be initialized before use. ArraysThere are major differences between the ways arrays work in Go and C. In Go, Arrays are values. Assigning one array to another copies all the elements. In particular, if you pass an array to a function, it will receive a copy of the array, not a pointer to it. The size of an array is part of its type. The types [10]int and [20]int are distinct. The value property can be useful but also expensive;If you want C-like behavior and efficiency, you can pass a pointer to the array.But even this style isn’t idiomatic Go. Use slices instead. The blank identifierThe blank identifier can be assigned or declared with any value of any type, with the value discarded harmlessly. Unused imports and variables import ( &quot;fmt&quot; &quot;io&quot; &quot;log&quot; &quot;os&quot; ) var _ = fmt.Printf // For debugging; delete when done. var _ io.Reader // For debugging; delete when done. func main() { fd, err := os.Open(&quot;test.go&quot;) if err != nil { log.Fatal(err) } // TODO: use fd. _ = fd } Import for side effectimport _ &quot;net/http/pprof&quot;This form of import makes clear that the package is being imported for its side effects, because there is no other possible use of the package: in this file, it doesn’t have a name. (If it did, and we didn’t use that name, the compiler would reject the program.) Interface checksIf it’s necessary only to ask whether a type implements an interface, without actually using the interface itself, perhaps as part of an error check, use the blank identifier to ignore the type-asserted value: if _, ok := val.(json.Marshaler); ok { fmt.Printf(&quot;value %v of type %T implements json.Marshaler\n&quot;, val, val) } One place this situation arises is when it is necessary to guarantee within the package implementing the type that it actually satisfies the interface.If a type—for example, json.RawMessage needs a custom JSON representation, it should implement json.Marshaler, but there are no static conversions that would cause the compiler to verify this automatically.If the type inadvertently fails to satisfy the interface, the JSON encoder will still work, but will not use the custom implementation.To guarantee that the implementation is correct, a global declaration using the blank identifier can be used in the package: var _ json.Marshaler = (*RawMessage)(nil) Concurrencyconcurrency: structuring a program as independently executing components.parallelism: executing calculations in parallel for efficiency on multiple CPUs. Channels of channels// TODO ParallelizationEither run your job with environment variable GOMAXPROCS set to the number of cores to use or import the runtime package and call runtime.GOMAXPROCS(NCPU).A helpful value might be runtime.NumCPU(), which reports the number of logical CPUs on the local machine. A leaky buffer// TODO Errors PanicPanic that in effect creates a run-time error that will stop the program.It’s always better to let things continue to run rather than taking down the whole program. One possible counterexample is during initialization: if the library truly cannot set itself up, it might be reasonable to panic, so to speak. var user = os.Getenv(&quot;USER&quot;) func init() { if user == &quot;&quot; { panic(&quot;no value for $USER&quot;) } } RecoverWhen panic is called, including implicitly for run-time errors such as indexing a slice out of bounds or failing a type assertion, it immediately stops execution of the current function and begins unwinding the stack of the goroutine, running any deferred functions along the way.If that unwinding reaches the top of the goroutine’s stack, the program dies. However, it is possible to use the built-in function recover to regain control of the goroutine and resume normal execution.One application of recover is to shut down a failing goroutine inside a server without killing the other executing goroutines. func server(workChan &lt;-chan *Work) { for work := range workChan { go safelyDo(work) } } func safelyDo(work *Work) { defer func() { if err := recover(); err != nil { log.Println(&quot;work failed:&quot;, err) } }() do(work) } // TODO: the rest of contents… A web serverLet’s finish with a complete Go program, a web server.This one is actually a kind of web re-server. Google provides a service at http://chart.apis.google.com that does automatic formatting of data into charts and graphs.It’s hard to use interactively, though, because you need to put the data into the URL as a query.The program here provides a nicer interface to one form of data: given a short piece of text, it calls on the chart server to produce a QR code, a matrix of boxes that encode the text. That image can be grabbed with your cell phone’s camera and interpreted as, for instance, a URL, saving you typing the URL into the phone’s tiny keyboard.Here’s the complete program. package main import ( &quot;flag&quot; &quot;html/template&quot; &quot;log&quot; &quot;net/http&quot; ) var addr = flag.String(&quot;addr&quot;, &quot;:1718&quot;, &quot;http service address&quot;) // Q=17, R=18 var templ = template.Must(template.New(&quot;qr&quot;).Parse(templateStr)) func main() { flag.Parse() http.Handle(&quot;/&quot;, http.HandlerFunc(QR)) err := http.ListenAndServe(*addr, nil) if err != nil { log.Fatal(&quot;ListenAndServe:&quot;, err) } } func QR(w http.ResponseWriter, req *http.Request) { templ.Execute(w, req.FormValue(&quot;s&quot;)) } const templateStr = ` &lt;html&gt; &lt;head&gt; &lt;title&gt;QR Link Generator&lt;/title&gt; &lt;/head&gt; &lt;body&gt; {{if .}} &lt;img src=&quot;http://chart.apis.google.com/chart?chs=300x300&amp;cht=qr&amp;choe=UTF-8&amp;chl={{.}}&quot; /&gt; &lt;br&gt; {{.}} &lt;br&gt; &lt;br&gt; {{end}} &lt;form action=&quot;/&quot; name=f method=&quot;GET&quot;&gt;&lt;input maxLength=1024 size=70 name=s value=&quot;&quot; title=&quot;Text to QR Encode&quot;&gt;&lt;input type=submit value=&quot;Show QR&quot; name=qr&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; ` ReferenceGo Official SiteA Tour of GoEffective GoThe Go Programming Language Specification]]></content>
      <categories>
        <category>Doing</category>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Notes, Shell Script]]></title>
    <url>%2F2017%2F07%2F31%2Fshell-script-notes%2F</url>
    <content type="text"><![CDATA[Last Modified: 2017-08-11 11:18:00 Acknowledge What is shell script?A shell script is a file containing a series of commands. The first shell scripthello_world.sh #!/bin/bash # The line above is called a shebang. # Every shell script should include this as its first line. # This is our first script. echo &#39;Hello World!&#39; make it executable```shellls -l hello_world-rw-r–r– 1 me me 63 2009-03-07 10:10 hello_worldchmod 755 hello_worldls -l hello_world-rwxr-xr-x 1 me me 63 2009-03-07 10:10 hello_world ./hello_wordHello World! &lt;!--- more ---&gt; ### Build a program ```shell #!/bin/bash # Program to output a system information page TITLE=&quot;System Information Report For $HOSTNAME&quot; CURRENT_TIME=$(date +&quot;%x %r %Z&quot;) TIME_STAMP=&quot;Generated $CURRENT_TIME, by $USER&quot; echo &quot;&lt;HTML&gt; &lt;HEAD&gt; &lt;TITLE&gt;$TITLE&lt;/TITLE&gt; &lt;/HEAD&gt; &lt;BODY&gt; &lt;H1&gt;$TITLE&lt;/H1&gt; &lt;P&gt;$TIME_STAMP&lt;/P&gt; &lt;/BODY&gt; &lt;/HTML&gt;&quot; here documentscommand &lt;&lt; token text token By default, single and double quotes within here documents lose their special meaning to the shell. If we change the redirection operator from “&lt;&lt;” to “&lt;&lt;-“, the shell will ignore leading tab characters in the here document. This allows a here document to be indented, which can improve readability.#!/bin/bash # Program to output a system information page TITLE=&quot;System Information Report For $HOSTNAME&quot; CURRENT_TIME=$(date +&quot;%x %r %Z&quot;) TIME_STAMP=&quot;Generated $CURRENT_TIME, by $USER&quot; cat &lt;&lt; _EOF_ &lt;HTML&gt; &lt;HEAD&gt; &lt;TITLE&gt;$TITLE&lt;/TITLE&gt; &lt;/HEAD&gt; &lt;BODY&gt; &lt;H1&gt;$TITLE&lt;/H1&gt; &lt;P&gt;$TIME_STAMP&lt;/P&gt; &lt;/BODY&gt; &lt;/HTML&gt; _EOF_ Top-down designshell functionfunction name { commands return } and name () { commands return } local variable#!/bin/bash i=0 function hello { local i=1 echo &#39;local i = &#39;$i echo &#39;Hello World&#39; } hello echo &#39;global i = &#39;$i keep program runnable#!/bin/bash # Program to output a system information page TITLE=&quot;System Information Report For $HOSTNAME&quot; CURRENT_TIME=$(date +&quot;%x %r %Z&quot;) TIME_STAMP=&quot;Generated $CURRENT_TIME, by $USER&quot; report_uptime () { echo &quot;Function report_uptime executed.&quot; return } report_disk_space () { echo &quot;Function report_disk_space executed.&quot; return } report_home_space () { echo &quot;Function report_home_space executed.&quot; return } cat &lt;&lt; _EOF_ &lt;HTML&gt; &lt;HEAD&gt; &lt;TITLE&gt;$TITLE&lt;/TITLE&gt; &lt;/HEAD&gt; &lt;BODY&gt; &lt;H1&gt;$TITLE&lt;/H1&gt; &lt;P&gt;$TIME_STAMP&lt;/P&gt; $(report_uptime) $(report_disk_space) $(report_home_space) &lt;/BODY&gt; &lt;/HTML&gt; _EOF_ ############################################ ./sys_info_page &lt;HTML&gt; &lt;HEAD&gt; &lt;TITLE&gt;System Information Report For linuxbox&lt;/TITLE&gt; &lt;/HEAD&gt; &lt;BODY&gt; &lt;H1&gt;System Information Report For linuxbox&lt;/H1&gt; &lt;P&gt;Generated 03/20/2009 05:17:26 AM EDT, by me&lt;/P&gt; Function report_uptime executed. Function report_disk_space executed. Function report_home_space executed. &lt;/BODY&gt; &lt;/HTML&gt; control: if branchingif statementif commands; then commands [elif commands; then commands...] [else commands] fi exit statusls -d /usr/bin /usr/bin echo $? 0 ls -d /bin/usr ls: cannot access /bin/usr: No such file or directory echo $? 2 test expressionThe test command returns an exit status of zero when the expression is true and a status of one when the expression is false. test expression # the more popular one: [ expression ] test file expressiontest_file () { # test-file: Evaluate the status of a file FILE=~/.bashrc if [ -e &quot;$FILE&quot; ]; then if [ -f &quot;$FILE&quot; ]; then echo &quot;$FILE is a regular file.&quot; fi if [ -d &quot;$FILE&quot; ]; then echo &quot;$FILE is a directory.&quot; fi if [ -r &quot;$FILE&quot; ]; then echo &quot;$FILE is readable.&quot; fi if [ -w &quot;$FILE&quot; ]; then echo &quot;$FILE is writable.&quot; fi if [ -x &quot;$FILE&quot; ]; then echo &quot;$FILE is executable/searchable.&quot; fi else echo &quot;$FILE does not exist&quot; return 1 fi } test string expression Expression Is Ture If… string string is not null. -n string The length of string is greater than zero. -z string The length of string is zero. string1 = string2 or string1 == string2 string1 and string2 are equal. Single or double equal signs may be used, but the use of double equal signs is greatly preferred. string1 != string2 string1 and string2 are not equal. string1 &gt; string2 sting1 sorts after string2. string1 &lt; string2 string1 sorts before string2. test integer expression Expression Is Ture If… integer1 -eq integer2 integer1 is equal to integer2. integer1 -ne integer2 integer1 is not equal to integer2. integer1 -le integer2 integer1 is less than or equal to integer2. integer1 -lt integer2 integer1 is less than integer2. integer1 -ge integer2 integer1 is greater than or equal to integer2. integer1 -gt integer2 integer1 is greater than integer2. compound command, enhanced test expression[[ expression ]]: it is similar to test and it supports all of its expressions. # but add a new string expression # which returns true if string is matched by the extended regular expression regex string =~ regex #!/bin/bash # test-integer2: evaluate the value of an integer. INT=-5 if [[ &quot;$INT&quot; =~ ^-?[0-9]+$ ]]; then if [ $INT -eq 0 ]; then echo &quot;INT is zero.&quot; else if [ $INT -lt 0 ]; then echo &quot;INT is negative.&quot; else echo &quot;INT is positive.&quot; fi if [ $((INT % 2)) -eq 0 ]; then echo &quot;INT is even.&quot; else echo &quot;INT is odd.&quot; fi fi else echo &quot;INT is not an integer.&quot; &gt;&amp;2 exit 1 fi Another added feature of [[ ]] is that the == operator supports pattern matching the same way pathname expansion does. For example: FILE=foo.bar if [[ $FILE == foo.* ]]; then &gt; echo &quot;$FILE matches pattern &#39;foo.*&#39;&quot; &gt; fi foo.bar matches pattern &#39;foo.*&#39; (( arithmetic expression )): it is used to perform arithmetic truth tests. #!/bin/bash # test-integer2a: evaluate the value of an integer. INT=-5 if [[ &quot;$INT&quot; =~ ^-?[0-9]+$ ]]; then if ((INT == 0)); then echo &quot;INT is zero.&quot; else if ((INT &lt; 0)); then echo &quot;INT is negative.&quot; else echo &quot;INT is positive.&quot; fi if (( ((INT % 2)) == 0)); then echo &quot;INT is even.&quot; else echo &quot;INT is odd.&quot; fi fi else echo &quot;INT is not an integer.&quot; &gt;&amp;2 exit 1 fi combine expressionsLogical Operators Operation test [[ ]] and (( )) AND -a &amp;&amp; OR -o &#124;&#124; NOT ! ! #!/bin/bash # test-integer3: determine if an integer is within a # specified range of values. MIN_VAL=1 MAX_VAL=100 INT=50 if [[ &quot;$INT&quot; =~ ^-?[0-9]+$ ]]; then if [[ INT -ge MIN_VAL &amp;&amp; INT -le MAX_VAL ]]; then echo &quot;$INT is within $MIN_VAL to $MAX_VAL.&quot; else echo &quot;$INT is out of range.&quot; fi else echo &quot;INT is not an integer.&quot; &gt;&amp;2 exit 1 fi We also include parentheses around the expression, for grouping if [ ! \( $INT -ge $MIN_VAL -a $INT -le $MAX_VAL \) ]; then echo &quot;$INT is outside $MIN_VAL to $MAX_VAL.&quot; else echo &quot;$INT is in range.&quot; fi two control operators, can perform branchingcommand1 &amp;&amp; command2command1 || command2 mkdir temp &amp;&amp; cd temp [ -d temp ] || mkdir temp [ -d temp ] || exit 1 detect permission with ifreport_home_space () { if [[ $(id -u) -eq 0 ]]; then cat &lt;&lt;- _EOF_ &lt;H2&gt;Home Space Utilization (All Users)&lt;/H2&gt; &lt;PRE&gt;$(du -sh /home/*)&lt;/PRE&gt; _EOF_ else cat &lt;&lt;- _EOF_ &lt;H2&gt;Home Space Utilization ($USER)&lt;/H2&gt; &lt;PRE&gt;$(du -sh $HOME)&lt;/PRE&gt; _EOF_ fi return } Keyboard inputread [-options] [variable...] If read receives fewer than the expected number, the extra variables are empty. If read receives more than the expected number, the final variable will contain all of the extra input. If no variables are listed after the read command, a shell variable, REPLY, will be assigned all the input. #!/bin/bash # read-secret: input a secret pass phrase if read -t 10 -sp &quot;Enter secret pass phrase &gt; &quot; secret_pass; then echo &quot;\nSecret pass phrase = &#39;$secret_pass&#39;&quot; else echo &quot;\nInput timed out&quot; &gt;&amp;2 exit 1 fi IFS (Internal Field Separator)The shell allows one or more variable assignments to take place immediately before a command.These assignments alter the environment for the command that follows.The effect of the assignment is temporary; only changing the environment for the duration of the command.In our case, the value of IFS is changed to a colon character. #!/bin/bash # read-ifs: read fields from a file FILE=/etc/passwd read -p &quot;Enter a user name &gt; &quot; user_name file_info=$(grep &quot;^$user_name:&quot; $FILE) if [ -n &quot;$file_info&quot; ]; then IFS=&quot;:&quot; read user pw uid gid name home shell &lt;&lt;&lt; &quot;$file_info&quot; echo &quot;User = &#39;$user&#39;&quot; echo &quot;UID = &#39;$uid&#39;&quot; echo &quot;GID = &#39;$gid&#39;&quot; echo &quot;Full Name = &#39;$name&#39;&quot; echo &quot;Home Dir. = &#39;$home&#39;&quot; echo &quot;Shell = &#39;$shell&#39;&quot; else echo &quot;No such user &#39;$user_name&#39;&quot; &gt;&amp;2 exit 1 fi The &lt;&lt;&lt; operator indicates a here string.A here string is like a here document, only shorter, consisting of a single string.We might wonder why this rather oblique method was chosen rather than: echo &quot;$file_info&quot; | IFS=&quot;:&quot; read user pw uid gid name home shell You Can’t Pipe readThe explanation has to do with the way the shell handles pipelines.In bash (and other shells such as sh), pipelines create subshells (subshells is the subprocesses).Subshells in Unix-like systems create copies of the environment for the processes to use while they execute.When the command exits, the subshell and its environment are destroyed.This means that a subshell can never alter the environment of its parent process.Then the effect of the assignment is lost. validating input echo &quot;Invalid input &#39;$REPLY&#39;&quot; &gt;&amp;2 exit 1 } read -p &quot;Enter a single item &gt; &quot; # input is empty (invalid) [[ -z $REPLY ]] &amp;&amp; invalid_input # input is multiple items (invalid) (( $(echo $REPLY | wc -w) &gt; 1 )) &amp;&amp; invalid_input # is input a valid filename? if [[ $REPLY =~ ^[-[:alnum:]\._]+$ ]]; then echo &quot;&#39;$REPLY&#39; is a valid filename.&quot; if [[ -e $REPLY ]]; then echo &quot;And file &#39;$REPLY&#39; exists.&quot; else echo &quot;However, file &#39;$REPLY&#39; does not exist.&quot; fi # is input a floating point number? if [[ $REPLY =~ ^-?[[:digit:]]*\.[[:digit:]]+$ ]]; then echo &quot;&#39;$REPLY&#39; is a floating point number.&quot; else echo &quot;&#39;$REPLY&#39; is not a floating point number.&quot; fi # is input an integer? if [[ $REPLY =~ ^-?[[:digit:]]+$ ]]; then echo &quot;&#39;$REPLY&#39; is an integer.&quot; else echo &quot;&#39;$REPLY&#39; is not an integer.&quot; fi else echo &quot;The string &#39;$REPLY&#39; is not a valid filename.&quot; fi menu#!/bin/bash # read-menu: a menu driven system information program clear echo &quot; Please Select: 1. Display System Information 2. Display Disk Space 3. Display Home Space Utilization 0. Quit &quot; read -p &quot;Enter selection [0-3] &gt; &quot; if [[ $REPLY =~ ^[0-3]$ ]]; then if [[ $REPLY == 0 ]]; then echo &quot;Program terminated.&quot; exit fi if [[ $REPLY == 1 ]]; then echo &quot;Hostname: $HOSTNAME&quot; uptime exit fi if [[ $REPLY == 2 ]]; then df -h exit fi if [[ $REPLY == 3 ]]; then if [[ $(id -u) -eq 0 ]]; then echo &quot;Home Space Utilization (All Users)&quot; du -sh /home/* else echo &quot;Home Space Utilization ($USER)&quot; du -sh $HOME fi exit fi else echo &quot;Invalid entry.&quot; &gt;&amp;2 exit 1 fi Flow control: while/until loopwhilewhile commands; do commands; done break and continue #!/bin/bash # while-menu2: a menu driven system information program DELAY=3 # Number of seconds to display results while true; do clear cat &lt;&lt;- _EOF_ Please Select: 1. Display System Information 2. Display Disk Space 3. Display Home Space Utilization 0. Quit _EOF_ read -p &quot;Enter selection [0-3] &gt; &quot; if [[ $REPLY =~ ^[0-3]$ ]]; then if [[ $REPLY == 1 ]]; then echo &quot;Hostname: $HOSTNAME&quot; uptime sleep $DELAY continue fi if [[ $REPLY == 2 ]]; then df -h sleep $DELAY continue fi if [[ $REPLY == 3 ]]; then if [[ $(id -u) -eq 0 ]]; then echo &quot;Home Space Utilization (All Users)&quot; du -sh /home/* else echo &quot;Home Space Utilization ($USER)&quot; du -sh $HOME fi sleep $DELAY continue fi if [[ $REPLY == 0 ]]; then break fi else echo &quot;Invalid entry.&quot; sleep $DELAY fi done echo &quot;Program terminated.&quot; until#!/bin/bash # until-count: display a series of numbers count=1 until [ $count -gt 5 ]; do echo $count count=$((count + 1)) done echo &quot;Finished.&quot; process files with while or until loop redirection#!/bin/bash # while-read: read lines from a file while read distro version release; do printf &quot;Distro: %s\tVersion: %s\tReleased: %s\n&quot; \ $distro \ $version \ $release done &lt; distros.txt pipe#!/bin/bash # while-read2: read lines from a file sort -k 1,1 -k 2n distros.txt | while read distro version release; do printf &quot;Distro: %s\tVersion: %s\tReleased: %s\n&quot; \ $distro \ $version \ $release done Stay out of troublesyntactic errorsif [ $number = 1 ]; then echo &quot;Number is equal to 1.&quot; # add double quotes to prevent unexpected expansion if [ &quot;$number = 1]; the echo &quot;Number is equal to 1.&quot; logical errors incorrect conditional expressions. “Off by one” errors. Unanticipated situations. testing# use &#39;echo&#39; to show the expanded parameters echo rm * # TESTING debugging isolate the area related to problemcommenting out the code sections the code tracing echo more messages a method of tracing of bash```shell#!/bin/bash -xtrouble: script to demonstrate common errors to activate tracing for the entire script by adding the -x option to the first linenumber=1if [ $number = 1 ]; then echo “Number is equal to 1.”else echo “Number is not equal to 1.”fi ##############################################export PS4=’$LINENO + ‘trouble5 + number=17 + ‘[‘ 1 = 1 ‘]’8 + echo ‘Number is equal to 1.’Number is equal to 1. ```shell #!/bin/bash # trouble: script to demonstrate common errors # to perform a trace on a selected portion of a script # we can use the set command with the -x option: number=1 set -x # Turn on tracing if [ $number = 1 ]; then echo &quot;Number is equal to 1.&quot; else echo &quot;Number is not equal to 1.&quot; fi set +x # Turn off tracing Flow control: case branchingcase word in [pattern [| pattern]...) commands ;;]... esac The patterns used by case are the same as those used by pathname expansion. Here are some valid patterns:a): Matches if word equals “a”.[[:alpha:]]): Matches if word is a single alphabetic character.???): Matches if word is exactly three characters long.*.txt): Matches if word ends with the characters “.txt”.*): Matches any value of word. It is good practice to include this as the last pattern in a case command; that is, to catch any possible invalid values. #!/bin/bash # case-menu: a menu driven system information program clear echo &quot; Please Select: 1. Display System Information 2. Display Disk Space 3. Display Home Space Utilization 0. Quit &quot; read -p &quot;Enter selection [0-3] &gt; &quot; case $REPLY in 0) echo &quot;Program terminated.&quot; exit ;; 1) echo &quot;Hostname: $HOSTNAME&quot; uptime ;; 2) df -h ;; 3) if [[ $(id -u) -eq 0 ]]; then echo &quot;Home Space Utilization (All Users)&quot; du -sh /home/* else echo &quot;Home Space Utilization ($USER)&quot; du -sh $HOME fi ;; *) echo &quot;Invalid entry&quot; &gt;&amp;2 exit 1 ;; esac match more the one testIn bash prior to version 4.0 there was no way for case to match more than one test.Modern versions of bash, add the ;;&amp; notation to terminate each action, we can do this: #!/bin/bash # case4-2: test a character read -n 1 -p &quot;Type a character &gt; &quot; echo case $REPLY in [[:upper:]]) echo &quot;&#39;$REPLY&#39; is upper case.&quot; ;;&amp; [[:lower:]]) echo &quot;&#39;$REPLY&#39; is lower case.&quot; ;;&amp; [[:alpha:]]) echo &quot;&#39;$REPLY&#39; is alphabetic.&quot; ;;&amp; [[:digit:]]) echo &quot;&#39;$REPLY&#39; is a digit.&quot; ;;&amp; [[:graph:]]) echo &quot;&#39;$REPLY&#39; is a visible character.&quot; ;;&amp; [[:punct:]]) echo &quot;&#39;$REPLY&#39; is a punctuation symbol.&quot; ;;&amp; [[:space:]]) echo &quot;&#39;$REPLY&#39; is a whitespace character.&quot; ;;&amp; [[:xdigit:]]) echo &quot;&#39;$REPLY&#39; is a hexadecimal digit.&quot; ;;&amp; esac ##################################################################### case4-2 Type a character &gt; a &#39;a&#39; is lower case. &#39;a&#39; is alphabetic. &#39;a&#39; is a visible character. &#39;a&#39; is a hexadecimal digit. Positional parametersaccess to the contents of the command line#!/bin/bash # posit-param: script to view command line parameters echo &quot; Number of arguments: $# \$0 = $0 \$1 = $1 \$2 = $2 &quot; ##################################################### posit-param Number of arguments: 0 $0 = /home/me/bin/posit-param $1 = $2 = ##################################################### Number of arguments: 2 posit-param a b $0 = /home/me/bin/posit-param $1 = a $2 = b shift, access to a large number of argumentsEach time shift is executed, the value of $2 is moved to $1, the value of $3 is moved to $2 and so on.The value of $# is also reduced by one.In addition to $0, which never changes. #!/bin/bash # posit-param2: script to display all arguments count=1 while [[ $# -gt 0 ]]; do echo &quot;Argument $count = $1&quot; count=$((count + 1)) shift done ##################################################### posit-param2 a b c d Argument 1 = a Argument 2 = b Argument 3 = c Argument 4 = d group positional parameters“$@” is by far the most useful for most situations, because it preserves the integrity of each positional parameter. #!/bin/bash # posit-params3 : script to demonstrate $* and $@ print_params () { echo &quot;\$1 = $1&quot; echo &quot;\$2 = $2&quot; echo &quot;\$3 = $3&quot; echo &quot;\$4 = $4&quot; } pass_params () { echo -e &quot;\n&quot; &#39;$* :&#39;; print_params $* echo -e &quot;\n&quot; &#39;&quot;$*&quot; :&#39;; print_params &quot;$*&quot; echo -e &quot;\n&quot; &#39;$@ :&#39;; print_params $@ echo -e &quot;\n&quot; &#39;&quot;$@&quot; :&#39;; print_params &quot;$@&quot; } pass_params &quot;word&quot; &quot;words with spaces&quot; ##################################################### posit-param3 $* : $1 = word $2 = words $3 = with $4 = spaces &quot;$*&quot; : $1 = word words with spaces $2 = $3 = $4 = $@ : $1 = word $2 = words $3 = with $4 = spaces &quot;$@&quot; : $1 = word $2 = words with spaces $3 = $4 = # with our arguments both $* and $@ produce a four word result: word words with spaces &quot;$*&quot; produces a one word result: &quot;word words with spaces&quot; &quot;$@&quot; produces a two word result: &quot;word&quot; &quot;words with spaces&quot; a complicated application Output file -f or --file Interactive mode -i or --interactive Help -h or --help#!/bin/bash # sys_info_page: program to output a system information page PROGNAME=$(basename $0) TITLE=&quot;System Information Report For $HOSTNAME&quot; CURRENT_TIME=$(date +&quot;%x %r %Z&quot;) TIMESTAMP=&quot;Generated $CURRENT_TIME, by $USER&quot; report_uptime () { cat &lt;&lt;- _EOF_ &lt;H2&gt;System Uptime&lt;/H2&gt; &lt;PRE&gt;$(uptime)&lt;/PRE&gt; _EOF_ return } report_disk_space () { cat &lt;&lt;- _EOF_ &lt;H2&gt;Disk Space Utilization&lt;/H2&gt; &lt;PRE&gt;$(df -h)&lt;/PRE&gt; _EOF_ return } report_home_space () { if [[ $(id -u) -eq 0 ]]; then cat &lt;&lt;- _EOF_ &lt;H2&gt;Home Space Utilization (All Users)&lt;/H2&gt; &lt;PRE&gt;$(du -sh /home/*)&lt;/PRE&gt; _EOF_ else cat &lt;&lt;- _EOF_ &lt;H2&gt;Home Space Utilization ($USER)&lt;/H2&gt; &lt;PRE&gt;$(du -sh $HOME)&lt;/PRE&gt; _EOF_ fi return } usage () { echo &quot;$PROGNAME: usage: $PROGNAME [-f file | -i]&quot; return } write_html_page () { cat &lt;&lt;- _EOF_ &lt;HTML&gt; &lt;HEAD&gt; &lt;TITLE&gt;$TITLE&lt;/TITLE&gt; &lt;/HEAD&gt; &lt;BODY&gt; &lt;H1&gt;$TITLE&lt;/H1&gt; &lt;P&gt;$TIMESTAMP&lt;/P&gt; $(report_uptime) $(report_disk_space) $(report_home_space) &lt;/BODY&gt; &lt;/HTML&gt; _EOF_ return } # process command line options interactive= filename= while [[ -n $1 ]]; do case $1 in -f | --file) shift filename=$1 ;; -i | --interactive) interactive=1 ;; -h | --help) usage exit ;; *) usage &gt;&amp;2 exit 1 ;; esac shift done # interactive mode if [[ -n $interactive ]]; then while true; do read -p &quot;Enter name of output file: &quot; filename if [[ -e $filename ]]; then read -p &quot;&#39;$filename&#39; exists. Overwrite? [y/n/q] &gt; &quot; case $REPLY in Y|y) break ;; Q|q) echo &quot;Program terminated.&quot; exit ;; *) continue ;; esac fi done fi # output html page if [[ -n $filename ]]; then if touch $filename &amp;&amp; [[ -f $filename ]]; then write_html_page &gt; $filename else echo &quot;$PROGNAME: Cannot write file &#39;$filename&#39;&quot; &gt;&amp;2 exit 1 fi else write_html_page fi control: for loopthe original for command’s syntaxfor variable [in words]; do commands done #!/bin/bash # longest-word : find longest string in a file while [[ -n $1 ]]; do if [[ -r $1 ]]; then max_word= max_len=0 for i in $(strings $1); do len=$(echo $i | wc -c) if (( len &gt; max_len )); then max_len=$len max_word=$i fi done echo &quot;$1: &#39;$max_word&#39; ($max_len characters)&quot; fi shift done If the optional in words portion of the for command is omitted, for defaults to processing the positional parameters. # test.sh #!/bin/bash for i; do echo $i done #################### test 1 2 3 1 2 3 C stylefor (( expression1; expression2; expression3 )); do commands done #!/bin/bash # simple_counter : demo of C style for command for (( i=0; i&lt;5; i=i+1 )); do echo $i done ################################################ simple_counter 0 1 2 3 4 Strings and numbersomittedStrings and number Arrays shell arrays is 0-based. one way to create an arraydeclare -a a usually in the following way name[subscript]=value name=(value1 value2 ...) days=(Sun Mon Tue Wed Thu Fri Sat) days=([0]=Sun [1]=Mon [2]=Tue [3]=Wed [4]=Thu [5]=Fri [6]=Sat) output the whole array(a small mistake in the book, corrected) $ animals=(&quot;a dog&quot; &quot;a cat&quot; &quot;a fish&quot;) for i in ${animals[*]}; do echo $i; done a dog a cat a fish for i in ${animals[@]}; do echo $i; done a dog a cat a fish for i in &quot;${animals[*]}&quot;; do echo $i; done a dog a cat a fish for i in &quot;${animals[@]}&quot;; do echo $i; done a dog a cat a fish determine the number of elements a[100]=foo echo ${#a[@]} # number of array elements 1 echo ${#a[100]} # length of element 100 3 find the index of array used foo=([2]=a [4]=b [6]=c) for i in &quot;${foo[@]}&quot;; do echo $i; done a b c for i in &quot;${!foo[@]}&quot;; do echo $i; done 2 4 6 sort the array #!/bin/bash # array-sort : Sort an array a=(f e d c b a) echo &quot;Original array: ${a[@]}&quot; a_sorted=($(for i in &quot;${a[@]}&quot;; do echo $i; done | sort)) echo &quot;Sorted array: ${a_sorted[@]}&quot; delete an array $ foo=(a b c d e f) $ echo ${foo[@]} a b c d e f $ unset foo $ echo ${foo[@]} $ ################################## $ foo=(a b c d e f) $ echo ${foo[@]} a b c d e f $ unset &#39;foo[2]&#39; $ echo ${foo[@]} a b d e f any reference to an array variable without a subscript refers to element zero of the array $ foo=(a b c d e f) $ echo ${foo[@]} a b c d e f $ foo=A $ echo ${foo[@]} A b c d e f associative arrayassociative arrays can only be created with the declare command using the new -A option declare -A colors colors[&quot;red&quot;]=&quot;#ff0000&quot; colors[&quot;green&quot;]=&quot;#00ff00&quot; colors[&quot;blue&quot;]=&quot;#0000ff&quot; echo ${colors[&quot;blue&quot;]} Odds and ends group command or subshell```shell group commandthe braces must be separated from the commands by a spacethe last command must be terminated with either a semicolon or a newline prior to the closing brace.{ command1; command2; [command3; …] } subshell(command1; command2; [command3;…]) ```shell ls -l &gt; output.txt echo &quot;Listing of foo.txt&quot; &gt;&gt; output.txt cat foo.txt &gt;&gt; output.txt ################################################################### { ls -l; echo &quot;Listing of foo.txt&quot;; cat foo.txt; } &gt; output.txt (ls -l; echo &quot;Listing of foo.txt&quot;; cat foo.txt) &gt; output.txt process substitution```shellfor processes that produce standard output:&lt;(a list of commands) for processes that intake standard input: (a list of commands)``` # to solve the problem brought by subshell, we can employ process substitution like this: read &lt; &lt;(echo &quot;foo&quot;) echo $REPLY traptrap argument signal [signal...] #!/bin/bash # trap-demo2 : simple signal handling demo exit_on_signal_SIGINT () { echo &quot;Script interrupted.&quot; 2&gt;&amp;1 exit 0 } exit_on_signal_SIGTERM () { echo &quot;Script terminated.&quot; 2&gt;&amp;1 exit 0 } trap exit_on_signal_SIGINT SIGINT trap exit_on_signal_SIGTERM SIGTERM for i in {1..5}; do echo &quot;Iteration $i of 5&quot; sleep 5 done temp filemktemp tempfile=$(mktemp /tmp/foobar.$$.XXXXXXXXXX) echo $tempfile /tmp/foobar.6593.UOZuvM6654 asynchronous executionwait #!/bin/bash # async-parent : Asynchronous execution demo (parent) echo &quot;Parent: starting...&quot; echo &quot;Parent: launching child script...&quot; async-child &amp; pid=$! echo &quot;Parent: child (PID= $pid) launched.&quot; echo &quot;Parent: continuing...&quot; sleep 2 echo &quot;Parent: pausing to wait for child to finish...&quot; wait $pid echo &quot;Parent: child is finished. Continuing...&quot; echo &quot;Parent: parent is done. Exiting.&quot; #!/bin/bash # async-child : Asynchronous execution demo (child) echo &quot;Child: child is running...&quot; sleep 5 echo &quot;Child: child is done. Exiting.&quot; async-parent Parent: starting... Parent: launching child script... Parent: child (PID= 6741) launched. Parent: continuing... Child: child is running... Parent: pausing to wait for child to finish... Child: child is done. Exiting. Parent: child is finished. Continuing... Parent: parent is done. Exiting. named pipe# it works as `process1 | process2` process1 &gt; named_pipe process2 &lt; named_pipe mkfifo mkfifo pipe1 # process1 ls -l &gt; pipe1 # process2 cat &lt; pipe1 SummayWell, we have completed our journey. The only thing left to do now is practice, practice, practice. Even though we covered a lot of ground in our trek, we barely scratched the surface as far as the command line goes. There are still thousands of command line programs left to be discovered and enjoyed. Start digging around in /usr/bin and you’ll see!]]></content>
      <categories>
        <category>Doing</category>
        <category>Shell</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Notes, Shell]]></title>
    <url>%2F2017%2F07%2F01%2Fshell-notes%2F</url>
    <content type="text"><![CDATA[Last Modified: 2017-07-31 11:18:00 Acknowledge What is shell? The shell is a program that takes keyboard commands and passes them to the operating system to carry out. Almost all Linux distributions supply a shell program from the GNU Project called bash. Bash is an enhanced replacement for sh, the original Unix shell program written by Steve Bourne. What is terminal emulator? We use a terminal emulator to interact with the shell when using a GUI. KDE uses konsole and GNOME uses gnome-terminal, though it’s likely called simply “terminal” on our menu. Shell prompt[me@linuxbox ~]$ Some Simple Commands date - Display the current time and date. cal - Display a calendar of the current month. df - Display the current amount of free space on your disk drives. free - Display the amount of free memory. exit - End the terminal session. Navigate the file system pwd - Print name of current working directory cd - Change directory ls - List directory contents file – Determine file type less – View file contents important facts about filenames Filenames that begin with a period character(.) are hidden.ls -a can display them, ll -a can display the detailed lists. Filenames and commands in Linux, like Unix, are case sensitive. The filenames “File1” and “file1” refer to different files. If you want to represent spaces between words in a filename, use underscore characters(_). Though Linux supports long filenames which may contain embedded spaces and punctuation characters: period(.), dash(-), underscore(_). Manipulate files and directories cp – Copy files and directories mv – Move/rename files and directories mkdir – Create directories rm – Remove files and directories ln – Create hard and symbolic links Here is a useful tip. Whenever you use wildcards with rm (besides carefully checking your typing!), test the wildcard first with ls.|Wildcard|Meaning||:——:|:——||*| Matches any characters||?| Matches any single character||[characters]| Matches any character that is a member of the set characters||[!characters]| Matches any character that is not a member of the set characters||[[:class:]]| Matches any character that is a member of the specified class| Character Class Meaning [:alnum:] Matches any alphanumeric character [:alpha:] Matches any alphabetic character [:digit:] Matches any numeral [:lower:] Matches any lowercase letter [:upper:] Matches any uppercase letter ln — Create linkscreate hard linksln file link a hard link may not reference a file that is not on the same disk partition as the link itself. a hard link may not reference a directory. a hard link is indistinguishable from the file itself when listed with ls. when a hard link is deleted, the link is removed but the contents of the file itself continue to exist (that is, its space is not deallocated) until all links to the file are deleted. create symbolic linksln -s item link a file pointed to by a symbolic link is also written, if you write some something to the symbolic link. however when you delete a symbolic link, only the link is deleted, not the file itself. Use commands type – Indicate how a command name is interpreted which – Display which executable program will be executed man – Display a command’s manual page apropos – Display a list of appropriate commands info – Display a command’s info entry whatis – Display a very brief description of a command whereis - Display the path of the executable program of a command alias – Create an alias for a command # append a new line of alias echo &#39;alias foo=&quot;cd /usr; ls; cd -&quot;&#39; &gt;&gt; .bashrc # force bash to re-read the modified .bashrc file source .bashrc I/O redirection cat - Concatenate files sort - Sort lines of text uniq - Report or omit repeated lines grep - Print lines matching a pattern wc - Print newline, word, and byte counts for each file head - Output the first part of a file tail - Output the last part of a file tee - Read from standard input and write to standard output and files &lt; operator redirects the standard input, &gt; operator redirects the standard output.&gt;&gt; means to append instead of overwriting.file streams as standard input, output and error, the shell references them internally as file descriptors zero, one and two, respectively```shell redirect to standard errorls -l /bin/usr 2&gt; ls-error.txt redirect standard output and error to same filethe redirection of standard error must always occur afterredirecting standard output or it doesn’t workls -l /bin/usr &gt; ls-output.txt 2&gt;&amp;1 # old versionls -l /bin/usr &amp;&gt; ls-output.txt # new version * to suppress error messages from a command, a special file called `/dev/null`, and it is a system device called a **bit bucket** which accepts input and does nothing with it. ```shell ls -l /bin/usr 2&gt; /dev/null the pipe operator | (vertical bar), the standard output of one command can be piped into the standard input of another.usually assisted with filters.```shellsort and unique files then showls /bin /usr/bin | sort | uniq | lessreport the duplicate files with -dls /bin /usr/bin | sort | uniq -d | less add wc to pipelines to count thingsls /bin /usr/bin | sort | uniq | wc -l * **grep** is a powerful program used to find text patterns within files. ```shell ls /bin /usr/bin | sort | uniq | grep zip -i to ignore case, -v to print the lines that do not match the pattern, -n to show the line numbers. head prints the first ten lines of a file and the tail command prints the last ten lines by default. # -n to adjust the number of lines to show head -n 5 ls-output.txt # -f to allow tail to view files in real-time tail -f /var/log/messages tee reads standard input and copies it to both standard output (allowing the data to continue down the pipeline) and to one or more files. ls /usr/bin | tee ls.txt | grep zip Expansion pathname expansionecho D* Desktop Documents arithmetic expansion# / is just integer division, ** is exponentiation echo $((2+2-2*2/3%10+2**2)) 7 brace expansion```shellecho Front-{A,B,C}-BackFront-A-Back Front-B-Back Front-C-Back echo Number_{1..5}Number_1 Number_2 Number_3 Number_4 Number_5 echo a{A{1,2},B{3,4}}baA1b aA2b aB3b aB4b * parameter expansion ```shell echo $USER me # to see a list of available variables printenv | less command substitution```shellecho $(ls)Desktop Documents ls-output.txt Music Pictures Public Templates ls -l $(which cp)-rwxr-xr-x 1 root root 71516 2007-12-05 08:58 /bin/cp file $(ls /usr/bin/* | grep zip)/usr/bin/bunzip2: symbolic link to `bzip2’ ```shell # use back-quotes instead of the dollar sign and parentheses # in older version of bash ls -l `which cp` -rwxr-xr-x 1 root root 71516 2007-12-05 08:58 /bin/cp to control expansion double quotesIf you place text inside double quotes, all the special characters used by the shell lose their special meaning and are treated as ordinary characters.The exceptions are $, \ (backslash), and ` (back-quote). single quotesAll expansions lose their special meaning. escape characterYou can precede a character with a \ (backslash) to selectively prevent an expansion.echo text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER text /home/me/ls-output.txt a b foo 4 me echo &quot;text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER&quot; text ~/*.txt {a,b} foo 4 me echo &#39;text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER&#39; text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER Keyboard operating techniques clear - Clear the screen history - Display the contents of the history list cursor movement shortcuts Key Action Ctrl-a Move cursor to the beginning of the line. Ctrl-e Move cursor to the end of the line. Ctrl-f Move cursor forward one character; same as the right arrow key. Ctrl-b Move cursor backward one character; same as the left arrow key. Alt-f Move cursor forward one word. Alt-b Move cursor backward one word. text editing shortcuts Key Action Ctrl-d Delete the character at the cursor location. Ctrl-t Transpose(exchange)the character at the cursor location with the one preceding it. Alt-t Transpose the word at the cursor location with the one preceding it. Alt-l Convert the characters from the cursor location to the end of the word to lowercase. Alt-u Convert the characters from the cursor location to the end of the word to uppercase. cut and paste shortcuts Key Action Ctrl-k Kill text from the cursor location to the end of line. Ctrl-u Kill text from the cursor location to the beginning of the line. Alt-d Kill text from the cursor location to the end of the current word. Alt-Backspace Kill text from the cursor location to the beginning of the word. If the cursor is at the beginning of a word, kill the previous word. Ctrl-y Yank text from the kill-ring and insert it at the cursor location. history expansion and shortcutshistory | grep /usr/bin # 88 ls -l /usr/bin &gt; ls-output.txt # to expand the command of history of 88th line !88 # to expand the last command of history !! Key Action Ctrl-p Move to the previous history entry. Same action as the up arrow. Ctrl-n Move to the next history entry. Same action as the down arrow. Ctrl-r Reverse incremental search. Searches incrementally from the current command line up the history list. Ctrl-o Execute the current item in the history list and advance to the next one. This is handy if you are trying to re-execute a sequence of commands in the history list. Permission id – Display user identity chmod – Change a file’s mode umask – Set the default file permissions su – Run a shell as another user sudo – Execute a command as another user chown – Change a file’s owner chgrp – Change a file’s group ownership passwd – Change a user’s password access rights, read, write, executionls -l foo.txt -rw-rw-r-- 1 me me 0 2008-03-06 14:52 foo.txt # the first one is file type, and the left nine is file mode. file types Attribute File Type - a regular file d A directory l A symbolic link. Notice that with symbolic links, the remainning file attributes are always “rwxrwxrwx” and are dummy values. The real file attributes are those of the file the symbolic link points to. c A character special file. This file type refers to a device that handles data as a stream of bytes, such as a terminal or modem. b A block special file. This file type refers to a device that handles data in blocks, such as a hard drive or CD-ROM drive. file mode|Attribute| Files| Directories||:-:|:-||r| Allows a file to be opened and read.| Allows a directory’s contents to be listed if the execute attribute is also set.||w| Allows a file to be written to or truncated, however this attribute does not allow files to be renamed or deleted. The ability to delete or rename files is determined by directory attributes.| Allows files within a directory to be created, deleted, and renamed if the execute attribute is also set.||x| Allows a file to be treated as a program and executed. Program files written in scripting languages must also be set as readable to be executed.| Allows a directory to be entered, e.g., cd directory.| chmodchmod 600 foo.txt ls -l foo.txt -rw------- 1 me me 0 2008-03-06 14:52 foo.txt a few common ones: 7 (rwx), 6 (rw-), 5 (r-x), 4 (r–), and 0 (—). chmod Symbolic Notation Notation Meaning u Short for “user”, but means the file or directory owner. g Group owner. o Short for “others”, but means world. a Short for “all”, the combination of “u”, “g”, and “o”. chmod Symbolic Notation Examples Example Meaning u+x Add execute permission for the owner. u-x Remove execute permission from the owner. +x Add execute permission for the owner, group, and world. Equivalent to a+x. o-rw Remove the read and write permission from anyone besides the owner and group owner. u+x,go=rw Add execute permission for the owner and set the permissions for the group and others to read and execute. Multiple specifications may be separated by commas. umaskThe umask command controls the default permissions given to a file when it is created. It uses octal notation to express a mask of bits to be removed from a file’s mode attributes. umask 0022 others The su command is used to start a shell as another user. su [-[l]] [user] The sudo command is used to execute commands as a different user (usually the superuser) in a very controlled way. The chown command is used to change the owner and group owner of a file or directory. Superuser privileges are required to use this command. chown [owner][:[group]] file... In older versions of Unix, the chown command only changed file ownership, not group ownership. For that purpose, a separate command, chgrp was used. It works much the same way as chown, except for being more limited. The passwd command is used to set passwords for yourself (and for other users if you have access to superuser privileges). passwd [user] more infos, … adduser, useradd, groupadd Process ps – Report a snapshot of current processes top – Display tasks jobs – List active jobs bg – Place a job in the background fg – Place a job in the foreground kill – Send a signal to a process killall – Kill processes by name shutdown – Shutdown or reboot the system Process States State Meaning R Running. This means that the process is running or ready to run. S Sleeping. A process is not running; rather, it is waiting for an event, such as a keystroke or network packet. D Uninterruptible Sleep. Process is waiting for I/O such as a disk drive. T Stopped. Process has been instructed to stop. More on this later. Z A defunct or “zombie” process. This is a child process that has terminated, but has not been cleaned up by its parent. &lt; A high priority process. It’s possible to grant more importance to a process, giving it more time on the CPU. This property of a process is called niceness. A process with high priority is said to be less nice because it’s taking more of the CPU’s time, which leaves less for everybody else. N A low priority process. A process with low priority (a “nice” process) will only get processor time after other processes with higher priority have been serviced. SignalsIn the case of Ctrl-c, a signal called INT (Interrupt) is sent; with Ctrl-z, a signal called TSTP (Terminal Stop.) kill [-Number] PID kill [-SIG&lt;Name&gt;] PID Number Name Meaning 1 HUP Hangup. 2 INT Interrupt. Performs the same function as the Ctrl-c key sent from the terminal. It will usually terminate a program. 9 KILL Kill. 15 TERM Terminate. This is the default signal sent by the kill command. If a program is still “alive” enough to receive signals, it will terminate. 18 CONT Continue. This will restore a process after a STOP signal. 19 STOP Stop. This signal causes a process to pause without terminating. Like the KILL signal, it is not sent to the target process, and thus it cannot be ignored. Shell environment printenv – Print part or all of the environment set – Set shell options export – Export environment to subsequently executed programs alias – Create an alias for a command printenv USER # print environment variable USER echo $USER # a same way as above # export added PATH PATH=$PATH:$HOME/bin export PATH Basic usage of vito do Customize shell promptomitted Package control - Debian Style (.deb) Red Hat Style (.rpm) Distributions (Partial Listing) Debian, Ubuntu, Xandros, Linspire Fedora, CentOS, Red Hat Enterprise Linux, OpenSUSE, Mandriva, PCLinuxOS Low-Level Tools dpkg apt-get, aptitude High-Level Tools rpm yum Package Search Commands apt-get update; apt-cache search search_string yum search search_string Package Installation Commands apt-get update; apt-get install package_name yum install package_name Low-Level Package Installation Commands dpkg –install package_file rpm -i package_file Package Removal Commands apt-get remove package_name yum erase package_name Package Update Commands apt-get update; apt-get upgrade yum update Low-Level Package Upgrade Commands dpkg –install package_file rpm -U package_file Package Listing Commands dpkg –list rpm -qa Package Status Commands dpkg –status package_name rpm -q package_name Package Information Commands apt-cache show package_name yum info package_name Package File Identification Commands dpkg –search file_name rpm -qf file_name Storage devices mount – Mount a file system umount – Unmount a file system fsck – Check and repair a file system fdisk – Partition table manipulator mkfs – Create a file system fdformat – Format a floppy disk dd – Write block oriented data directly to a device genisoimage (mkisofs) – Create an ISO 9660 image file wodim (cdrecord) – Write data to optical storage media md5sum – Calculate an MD5 checksum omitted Networking ping - Send an ICMP ECHO_REQUEST to network hosts traceroute - Print the route packets trace to a network host netstat - Print network connections, routing tables, interface statistics, masquerade connections, and multicast memberships ftp - Internet file transfer program wget - Non-interactive network downloader ssh - OpenSSH SSH client (remote login program) Find files locate – Find files by name find – Search for files in a directory hierarchy We will also look at a command that is often used with file search commands to process the resulting list of files: xargs – Build and execute command lines from standard input In addition, we will introduce a couple of commands to assist us in or exploration: touch – Change file times stat – Display file or file system status Archive and backup gzip – Compress or expand files bzip2 – A block sorting file compressor tar – Tape archiving utility zip – Package and compress files rsync – Remote file and directory synchronization Regexgrep: global regular expression print-n: Prefix each matching line with the number of the line within the file. May also be specified –line-number.-r: Recursively search subdirectories listed. metacharactersRegular expression metacharacters consist of the following: ^ $ . [ ] { } - ? * + ( ) | \ any characterThe dot or period(.) character is used to match any character. anchorsThe caret (^) and dollar ($) sign characters are treated as anchors. This means that they cause the match to occur only if the regular expression is found at the beginning of the line or at the end of the line. # crossword puzzles grep -i &#39;^..j.r$&#39; /usr/share/dict/words Gujar Kajar Major major bracket expressionsBracket expressions is used to match a single character from a specified set of characters. grep -h &#39;[bg]zip&#39; dirlist*.txt bzip2 bzip2recover gzip Metacharacters lose their special meaning when placed within brackets. However, two cases have different meanings.The first is the caret (^), which is used to indicate negation; the second is the dash (-), which is used to indicate a character range. grep -h &#39;[^bg]zip&#39; dirlist*.txt bunzip2 gunzip # it will match all filenames starting with letters and numbers: grep -h &#39;^[A-Za-z0-9]&#39; dirlist*.txt # to include a dash, making it the first character in the expression # it will match every filename containing a dash, or a upper case “A” or an uppercase “Z”. grep -h &#39;[-AZ]&#39; dirlist*.txt POSIX Character Classes Character Class Description [:alnum:] The alphanumeric characters. In ASCII, equivalent to: [A-Za-z0-9] [:word:] The same as [:alnum:], with the addition of the underscore (_) character. [:alpha:] The alphabetic characters. In ASCII, equivalent to: [A-Za-z] [:digit:] The numerals zero through nine. [:lower:] The lowercase letters. [:space:] The whitespace characters including space, tab, carriage return, newline, vertical tab, and form feed. In ASCII, equivalent to: [ \t\r\n\v\f] [:upper:] The upper case characters. [:xdigit:] Characters used to express hexadecimal numbers. In ASCII, equivalent to: [0-9A-Fa-f] basic regular expressions (BRE) and extended regular expressions (ERE)What’s the difference between BRE and ERE?It’s a matter of metacharacters.With BRE, the following metacharacters are recognized: ^ $ . [ ] * All other characters are considered literals. With ERE, the following metacharacters (and their associated functions) are added: ( ) { } ? + | alternation# it will match the filenames in our lists that start with either “bz”, “gz”, or “zip grep -Eh &#39;^(bz|gz|zip)&#39; dirlist*.txt # it changes to match any filename that begins with “bz” or contains “gz” or contains “zip” grep -Eh &#39;^bz|gz|zip&#39; dirlist*.txt quantifierThe question mark (?) means making the preceding element optional (matching 0 or 1 element). # to valid if it matched either of these two forms: # (nnn) nnn-nnnn # nnn nnn-nnnn echo &quot;(555) 123-4567&quot; | grep -E &#39;^\(?[0-9][0-9][0-9] \)? [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$&#39; (555) 123-4567 echo &quot;555 123-4567&quot; | grep -E &#39;^\(?[0-9][0-9][0-9]\) ? [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$&#39; 555 123-4567 The asterisk (*) means making the preceding element optional (matching 0 or any number of times elements). # to see if a string was a sentence # it starts with an uppercase letter # then contains any number of upper and lowercase letters and spaces # and ends with a period. echo &quot;This works.&quot; | grep -E &#39;[[:upper:]][[:upper:][:lower:] ]*\.&#39; This works. echo &quot;this does not&quot; | grep -E &#39;[[:upper:]][[:upper:][:lower:] ]*\.&#39; The plus mark (+) means making the preceding element optional (matching 1 or any number of times elements). # it will match lines consisting of groups of one or more alphabetic characters separated by single spaces echo &quot;This that&quot; | grep -E &#39;^([[:alpha:]]+ ?)+$&#39; This that echo &quot;a b c&quot; | grep -E &#39;^([[:alpha:]]+ ?)+$&#39; a b c The { and } metacharacters are used to express minimum and maximum numbers of required matches. They may be specified in four possible ways:|Specifier| Meaning||:-:|:-||{n}| Match the preceding element if it occurs exactly n times.|{n,m}| Match the preceding element if it occurs at least n times, but no more than m times.||{n,}| Match the preceding element if it occurs n or more times.||{,m}| Match the preceding element if it occurs no more than m times.| echo &quot;(555) 123-4567&quot; | grep -E &#39;^\(?[0-9]{3}\)? [0-9]{3}-[0-9]{4}$&#39; (555) 123-4567 find files# it will reveal pathnames that contain embedded spaces and other potentially offensive characters find . -regex &#39;.*[^-\_./0-9a-zA-Z].*&#39; less and vimThey support basic regular expressions.Pressing the / key followed by a regular expression will perform a search. Manipulate text cat – Concatenate files and print on the standard output sort – Sort lines of text files uniq – Report or omit repeated lines cut – Remove sections from each line of files paste – Merge lines of files join – Join lines of two files on a common field comm – Compare two sorted files line by line diff – Compare files line by line patch – Apply a diff file to an original tr – Translate or delete characters sed – Stream editor for filtering and transforming text aspell – Interactive spell checker cat-A: display non- printing characters in the text.-n: show line numbers.-s: suppress the output of multiple blank lines. sort-n: perform sorting based on the numeric evaluation of a string rather than alphabetical value.-r: sort in reverse order. results are in descending rather than ascending order.-b: ignore leading blanks.-k field1[,field2]: sort based on a key field located from field1 to field2 rather than the entire line. # by specifying -k 3.7 we instruct sort to # use a sort key that begins at the seventh character within the third field sort -k 3.7nbr -k 3.1nbr -k 3.4nbr distros.txt Fedora 10 11/25/2008 Ubuntu 8.10 10/30/2008 SUSE 11.0 06/19/2008 ... unique-u: remove duplicates from the sorted output.-d: only output duplicated lines, rather than unique lines. cut-f filed_list, -c char_list, -d delimiter_char cut -f 3 distros.txt 12/07/2006 11/25/2008 cut -f 3 distros.txt | cut -c 7-10 2006 2008 # default delimiter is tab # what if we wanted a file fully manipulated with cut by characters, rather than fields expand distros.txt | cut -c 23- # set delimiter to &#39;:&#39; cut -d &#39;:&#39; -f 1 /etc/passwd | head pasteThe paste command does the opposite of cut. Rather than extracting a column of text from a file, it adds one or more columns of text to a file. joinA join is an operation usually associated with relational databases where data from multiple tables with a shared key field is combined to form a desired result. comm and diff commThe comm program compares two text files and displays the lines that are unique to each one and the lines they have in common. diff-c: contex format```shelldiff -c file1.txt file2.txt_*_ file1.txt 2008-12-23 06:40:13.000000000 -0500— file2.txt 2008-12-23 06:40:34.000000000 -0500 _ 1,4 *_ abcd— 1,4 —-bcd e`-u`: **unified format** ```shell diff -u file1.txt file2.txt --- file1.txt 2008-12-23 06:40:13.000000000 -0500 +++ file2.txt 2008-12-23 06:40:34.000000000 -0500 @@ -1,4 +1,4 @@ -a b c d +e patchTo prepare a diff file for use with patch, the GNU documentation (see Further Reading below) suggests using diff as follows: diff -Naur old_file new_file &gt; diff_file Once the diff file has been created, we can apply it to patch the old file into the new file: patch &lt; diff_file trThe tr program is used to transliterate characters. # transliterate characters echo &quot;lowercase letters&quot; | tr a-z A-Z LOWERCASE LETTERS echo &quot;lowercase letters&quot; | tr [:lower:] A AAAAAAAAA AAAAAAA # delete &#39;\r&#39; in dos files tr -d &#39;\r&#39; &lt; dos_file &gt; unix_file # “squeeze” (delete) repeated instances of a character echo &quot;aaabbbccc&quot; | tr -s ab abccc sed-n: no auto-print; sed Address Notation|Address| Description||:-:|:-||n| A line number where n is a positive integer.||$| The last line.||/regexp/| Lines matching a POSIX basic regular expression. Note that the regular expression is delimited by slash characters. Optionally, the regular expression may be delimited by an alternate character, by specifying the expression with \cregexpc, where c is the alternate character.||addr1,addr2| A range of lines from addr1 to addr2, inclusive. Addresses may be any of the single address forms above.||first~step| Match the line represented by the number first, then each subsequent line at step intervals. For example 1~2 refers to each odd numbered line, 5~5 refers to the fifth line and every fifth line thereafter.||addr1,+n| Match addr1 and the following n lines.||addr!| Match all lines except addr, which may be any of the forms above.| sed -n &#39;1,5p&#39; distros.txt SUSE 10.2 12/07/2006 Fedora 10 11/25/2008 SUSE 11.0 06/19/2008 Ubuntu 8.04 04/24/2008 Fedora 8 11/08/2007 sed -n &#39;/SUSE/p&#39; distros.txt SUSE 10.2 12/07/2006 SUSE 11.0 06/19/2008 sed -n &#39;/SUSE/!p&#39; distros.txt Fedora 10 11/25/2008 Ubuntu 8.04 04/24/2008 sed Basic Editing Commands|Command| Description||:-:|:-||=| Output current line number.||a| Append text after the current line.||d| Delete the current line.||i| Insert text in front of the current line.||p| Print the current line. By default, sed prints every line and only edits lines that match a specified address within the file. The default behavior can be overridden by specifying the -n option.||q| Exit sed without processing any more lines. If the -n option is not specified, output the current line.||Q| Exit sed without processing any more lines.||s/regexp/replacement/| Substitute the contents of replacement wherever regexp is found. replacement may include the special character &amp;, which is equivalent to the text matched by regexp. In addition, replacement may include the sequences \1 through \9, which are the contents of the corresponding subexpressions in regexp. For more about this, see the discussion of back references below. After the trailing slash following replacement, an optional flag may be specified to modify the s command’s behavior.||y/set1/set2| Perform transliteration by converting characters from set1 to the corresponding characters in set2. Note that unlike tr, sed requires that both sets be of the same length.| # &#39;s/([0-9]{2})/([0-9]{2})/([0-9]{4})$/\3-\1-\2/&#39; sed &#39;s/\([0-9]\{2\}\)\/\([0-9]\{2\}\)\/\([0-9]\{4\}\)$/\3-\1-\2/&#39; distros.txt SUSE 10.2 2006-12-07 echo &quot;aaabbbccc&quot; | sed &#39;s/b/B/&#39; aaaBbbccc echo &quot;aaabbbccc&quot; | sed &#39;s/b/B/g&#39; aaaBBBccc aspellan interactive spelling checker. aspell check textfile Format text outputomitted Printerommited Compile source codeWhy compile software? There are two reasons: Availability. Despite the number of precompiled programs in distribution repositories, some distributions may not include all the desired applications. In this case, the only way to get the desired program is to compile it from source. Timeliness. While some distributions specialize in cutting edge versions of programs, many do not. This means that in order to have the very latest version of a program, compiling is necessary. [~]$ mkdir src [~]$ cd src ftp ftp.gnu.org anonymous ftp&gt; cd gnu/diction ftp&gt; ls 150 Here comes the directory listing. -rw-r--r-- 1 1003 65534 68940 Aug 28 1998 diction-0.7.tar.gz -rw-r--r-- 1 1003 65534 90957 Mar 04 2002 diction-1.02.tar.gz -rw-r--r-- 1 1003 65534 141062 Sep 17 2007 diction-1.11.tar.gz ftp&gt; get diction-1.11.tar.gz 226 File send OK. ftp&gt; bye [src]$ ls diction-1.11.tar.gz # unpack [src]$ tar -xzf diction-1.11.tar.gz [src]$ cd diction-1.11 # configure, compile and install [diction-1.11]$ ./configure [diction-1.11]$ make [diction-1.11]$ make install Reference快乐的 Linux 命令行]]></content>
      <categories>
        <category>Doing</category>
        <category>Shell</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Constructors, Destrustors and Assignment Operators, Notes(2), Effective C++]]></title>
    <url>%2F2017%2F06%2F15%2Feffective-cpp-constructors-destructors-and-assignment-operators%2F</url>
    <content type="text"><![CDATA[(I read a Chinese version of the book, any translation problem plz point out. Constructors, Destructors and Assignment OperatorKnow what functions CPP silently writes and callsFor empty class, the complier will declare a copy constructor, a copy assignment operator, a destructor, if no any constructor is declared, one more default constructor is declared by compiler.They are all public and inlined, and when called, they will be created (during compiling period). Explicitly disallow the use of compiler-generated functions you do not want declare as private with no definition.when member function or friend function calls, a linkage error will be reported. class HomeForSale { public: // ... private: HomeForSale(const HomeForSale&amp;); HomeForSale&amp; operator=(const HomeForSale&amp;); }; earlier? -&gt; compiling period```cppclass Uncopyable {protected: Uncopyable() {} ~Uncopyable() {}private: Uncopyable(const Uncopyable&amp;); Uncopyable&amp; operator=(const Uncopyable&amp;);}; class HomeForSale: private Uncopyable { // …}; **why?** anyone tries to copy `HomeForSale`, the compiler will try to generate a copy constructor and a copy assignment operator, then &quot;compiler-generated version&quot; tries to call the ones in base classes respectively, and it will be refused due to the privateness of copying functions in base classes. * Boost have one class `noncopyable` similarly that mentioned above. * CPP11 new feature, `=delete` ### Declare vitual destructors in polymorphic base classes. * CPP points out specificly, it is a **undefined behavior** when a object of derived class is deleted by a pointer of base class, which has a non-virtual destructor. * Any class that has a virtual function should have a virtual destructor. * A class with no virtual destructor mustn&#39;t be used as a base class, such as STL containers. In other words, **if some class is not designed for using as a base class, it shouldn&#39;t declare a virtual destructor**. * Declare a pure virtual destrutor when creating an abstract class without any other pure virtual functions. ```cpp class AWOV { public: virtual ~AWOV() = 0; }; AWOV::~AWOV() {} Prevent exceptions from leaving destructorsWhen 2 exceptions exist at the same time, the program either aborts or results in a undefined behavior. double insuranceif customer need to response to the exceptions which was thrown by the run-time of some function, the class should provide a normal function (other than handled in the destructor). class DBConn { public: void close() { db.close(); closed = true; } ~DBConn() { if(!closed) { try { db.close(); } catch (...) { // log, then abort or swallow the exception } } } private: DBConnection db; bool closed; }; Never call virtual functions during construction or destruction virtual functions never downcast to derived classes, when base classed is constructing. once called, it is a undefined behavior because the members haven’t been initialized yet. if needed, declare as non-virtualconstructors of derived classes passes the parameters to the ones of base classes (static functions will also avoid the problem).```cppclass Transaction {public: explicit Transaction(const std::string&amp; logInfo); void logTransaction(const std::string&amp; logInfo) const; // non-virtual};Transaction::Transaction(const std::string&amp; logInfo) { logTransaction(logInfo);} class BuyTransaction: public Transaction {public: BuyTransaction( … ) : Transaction(createLogString( … )) {}private: static std::string createLogString( …);); ### Assignment operator * Have assignment operators return a reference to `*this` * Handle assignment to self **copy and swap** technique ```cpp Widget&amp; Widget::operator=(const Widget&amp; rhs) { Widget temp(rhs); swap(*this, temp); return *this; } Copy all parts of an object compiler may generate no warnings or errors when you implement your own copy constructors or copy assignment operators```cppclass Customer {public: Customer(const Customer&amp; rhs); Customer&amp; operator=(const Customer&amp; rhs);private: std::string name;}; class PriorityCustomer: public Customer {public: PriorityCustomer(const PriorityCustomer&amp; rhs); PriorityCustomer&amp; operator=(const PriorityCustomer&amp; rhs);private: int priority;}; PriorityCustomer::PriorityCustomer(const PriorityCustomer&amp; rhs) : Customer(rhs), priority(rhs.priority) {} PriorityCustomer&amp; PriorityCustomer::operator=(const PriorityCustomer&amp; rhs) { Customer::operator=(rhs); priority = rhs.priority; return *this;}``` Do not try to use some copying function to implement another one.If you wanna avoid code duplicate, try to introduce a new function, maybe called init() to be called by the two copying functions.]]></content>
      <categories>
        <category>Doing</category>
        <category>CPP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Accustoming to CPP, Notes(1), Effective C++]]></title>
    <url>%2F2017%2F06%2F11%2Feffective-cpp-accustoming-to-cpp%2F</url>
    <content type="text"><![CDATA[(I read a Chinese version of the book, any translation problem plz point out. View CPP as a federation of languages a multiparadigm programming language procedural object-oriented programming (OOP) functional programming (FP) generic template metaprogramming (TMP) tips pass-by-value is more efficient for built-in types (C-like types) pass-by-reference-to-const is better for user-defined types pass-by-value is better for STL iterators and functors (both implemented based on C-pointers) Prefer compliers to preprocessorsUse consts for constants consts can be in the symbol table and will be seen by compliers const char* const authorName = &quot;Scott Meyers&quot;; //std::string is better than char*-based string const std::string authorName(&quot;Scott Meyers&quot;); consts in class for scope // Well, it is a declaration not a definition. Normally CPP requires a definition for anything you use. // But static consts in class with integral types(ints, chars, bools) need to be treated specially. class GamePlayer { private: static const int NumTurns = 5; //declaration int scores[NumTurns]; // ... }; No need to provide definitions when their addresses are never taken.Some compliers may wrongly require a definition, then it will look like: // definiton, no more initialization due to done in declaration const int GamePlayer::NumTurns; #defines have no scopeonce a macro is defined, it is taken into effect during all the later process of compiling(unless #undef is done).no encapsulation enum hack // some like #defines // consts can be taken the addresses while enums cannot class GamePlayer { private: enum { NumTurns = 5 }; int scores[NumTurns]; // ... }; For acquaintance, enum hack is basic technique in TMP Use template inlines for mini functions// disgusting #define CALL_WITH_MAX(a, b) f((a) &gt; (b) ? (a) : (b)) template&lt;typename T&gt; inline void callWithMAX(const T&amp; a, const T&amp; b) { f(a &gt; b ? a : b); } Use consts whenever possiblechar greeting[] = &quot;Hello&quot;; char* p = greeting; // non-const pointer, non-const data const char* p = greeting; // non-const pointer, const data char* const p = greeting; // const pointer, non-const data const char* const p = greeting; // const pointer, const data STL iteratoriterator acts like a T_ pointer.```cppstd::vector vec;// iter acts like T_ constconst std::vector::iterator iter = vec.begin();*iter = 10; // ok++iter; // CE // cIter acts like const T_std::vector::const_iterator cIter = vec.begin();++iter; // ok _iter = 10; // CE * return const value ```cpp class Rational { // ... }; const Rational operator* (const Rational&amp; lhs, const Rational&amp; rhs); Rational a, b, c; if(a * b = c) {} // CE, without const it will be ok CPP returns object by value, so the assignment is never legal, for only changing a copy. const member functiontwo member functions can be overloaded even if they are only different in constness.in real, const member function is overloaded when const objects are used in passed by pointer-to-const or passed by reference-to-const.```cppclass TextBlock {public: const char&amp; operator const { // ... return text[position]; } char&amp; operator { return const_cast&lt;char&amp;&gt;( static_cast&lt;const TextBlock&amp;&gt;(*this)[position] ); }}; void print(const TextBlock&amp; ctb) { std::cout &lt;&lt; ctb[0];} **non-const overloaded function can be implemented by calling the const version is safe, otherwise it is not.** * bitwise constness or logical constness **bitwist constness is the definition of CPP&#39;s constness, so the const member funcion cannot change any non-static member variable.** use keyword `mutable` to release the constraint of CPP&#39;s bitwise constness. **write codes by using logical constness.** ```cpp class CTextBlock { public: std::size_t length() const; private: char* pText; mutable std::size_t textLength; mutable bool lengthIsValid; }; std::size_t CTextBlock::length() const { if(!lengthIsValid) { textLength = std::strlen(pText); // can be changed lengthIsValid = true; // same as above } return textLength; } Make sure that objects are initialized before used objects will be initialized when declared in heap while they won’t when declared in stack. it is not easy to memorize it, whatever, keep initialization always. do not mix assignment and initialization. for user-defined types, always use the member initialization list and always list all the member variables in the member initialization list. sometimes, a class may have many constructors, and to avoid duplication, we can move the invitializatin of the variables that have same efficiency between assignment and initialization to some private function. (well, this ‘pseudo-intialization’ is not advocated, try member initialization list as much as possible) The order of initialization: base classes is initialized earlier than derived classes. member variables is initialized as the order of that they are declared even if the order of the appearance in member initialization list is different. non-local static objects static objects: global objects, objects defined in namespace, static objects in classes, functions, file scopes. local static objects: static objects in functions. no specific initialization order for non-local static objects in different translation unit. Singleton:use local static objects to replace the non-local ones.class FileSystem { // ... }; FileSystem&amp; tfs() { static FileSystem fs; return fs; } class Directory { // ... }; Directory::Directory( params ) { // ... std::size_t disks = tfs().numDisks(); } Directory&amp; tempDir() { static Directory td; return td; }]]></content>
      <categories>
        <category>Doing</category>
        <category>CPP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Address Collecting]]></title>
    <url>%2F2017%2F05%2F18%2FAddress-Collecting%2F</url>
    <content type="text"><![CDATA[这里留地址吧，具体时间就截止到多说关闭(6.1)吧，到时候我就换Disqus了喔，到时候收到了转给我打印费和邮费就好了。(某ACMer卖模版月入百万！才不会说我是骗手机号的呢 那啥地址就按照这个格式留吧： 收件地址： 重庆市重庆大学A区中门11舍收件人：老顽童收件人号码：13123333333 嗨呀，以后就只能自己玩啦~]]></content>
      <categories>
        <category>Doing</category>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Backthoughts during These Days]]></title>
    <url>%2F2017%2F04%2F28%2FBackthoughts-during-These-Days%2F</url>
    <content type="text"><![CDATA[“I’m sorry that you are not the person we choose”“I’m sorry …” Yeah, I gotta some problems myself, mainly from the ICPC regionals’ results…I managed to avoid that, yet I can’t control the inner hints myself… During the toutiao interview, the first two was OK.The third one crashed.. Last year, a new team formed, and I became the vice coder instead ofthe major coder…Less and less onsite coding, makes me lose the judgement of coding time of a problem.. WAPS online Interview, anxiety made me … couldn’t think straightly..Unexpectedly, onsite interview, I did a great job.. even I was not matched at last.Anyway, it doesn’t matter.. Life is not all about money and comfort,and I’d love to have some challenges which hard mode of life will be more exciting. Well, going back to the third one of toutiao’ interview.So bad! I AM the one who can code a complicated data structure problem,and a complicated implementation problem too…Calm down, and 30 minutes is OK.. Do believe myself…Failure won’t take anything.Results can’t be changed, more world later on. 2 times I failed at the third interview of toutiao.I don’t believe the fate, just lack of some luck.More details, see this link, click me Be better and More progress！More effort on the hard mode chosed！]]></content>
      <categories>
        <category>Doing</category>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[头条秋招春招失败的思考]]></title>
    <url>%2F2017%2F04%2F28%2FBackthoughts-about-the-Failure-of-the-Autumn-and-Spring-Campus-Recruiting-of-Toutiao%2F</url>
    <content type="text"><![CDATA[毕设交了一波初稿，总算回来填坑了。回头想想，不得不说头条面试反映了我的心境变化。 秋招后台岗一面记得有2个题，其中一个应该非常水的题，没啥印象了。 数组中乘积最大连续子数组这个现在就是一眼的dp，只怪刷了那么多题的我还是刷题太少了。 Old Solution直接暴力是$O(n^3)$的，所以就显然的前缀积优化到$O(n^2)$蓝儿因为有$0$，这里就会有些问题，为了避免除$0$要做一些处理不过实际上只要乘了$0$这一段乘积就是$0$了，所以把所有$0$的位置抠出来就可以了然后枚举每一段，就不会有事了，答案初始化为$0$就可以了，前提是有一个$0$。。 New Solution很简单的dp啊，，$f[i][0/1]:$=到$i$这个位置的连续乘积最大值/最小值就是套用最大连续子段和的套路，这破题我还被问过两遍$HR$又做了一个更复杂的的树形的，不过那个时候我一眼秒了。。就因为有负数嘛，所以就简单的维护下最小值就好了。。 二面写个类似单调栈的玩意儿印象中应该让写了一个支持push,pop,getMin的栈，所有操作$O(1)$ Solution这东西也很简单啊，就维护数字栈的之后再顺手维护一个单调栈，细节注意一下就好了我当时并没有想到单调栈，可能平时用的不多。不过还是有脑子的，随便一想就想到了。我记得这个破题剑指offer上有吧，虽然一直没注意。 微信怎么拉取朋友圈信息这东西我真不会啊，就xjb说了一下，本地存个跟帐号有关的hashvalue表示已经拉取了多少每次拉取的时候，服务器也生成一个，比对一下，不适最新的就拉取就好了。当然你问我什么别人点赞评论啥的，我真的不会啊。。 服务器很少，流量很大，怎么负载均衡啊不会啊，xjb扯淡啊，就随手说了一下缓存服务器，Nginx啥的(这东西我tm就听过名字。讲道理啊，为啥不买设备啊喂！(大雾 三面哇，这面跑不了啊，直接就问我后台技术栈啥的。骗不过去了啊。然后就不知道啊。有点绝望啊。意识不清醒了啊，打完比赛找不到工作一同交织在一起啊。然后面试官问我读不读研啊。然后脑子一抽说想读啊。然后我还耿直的去问头条有没有quit工作去读研啊没见过比我更sb的人了主要还是比赛打炸了，心态太差了。几个月都没调好。 然后就没然后了啊春招算法岗一面扯扯淡啊，自我介绍啥的啊，ACM打的怎么样啊。。 二叉树最长路径长度一看就当普通树做了啊，然后就无脑说两次dfs求直径就好了啊。他说能不能一次啊，那就无脑dp求一下直径啊。他说还能不能再简单一点啊。 (dp还不简单啊哇 我又看了一下题，发现二叉树。然后我就说那简化一下啊。 Code```cppstruct Node{ Node_ ls, _rs;}; const int INF = INT_MAX / 2; int maxd = -INF;int dfs(Node* cur){ if(cur == nullptr) return 0; int ldep = dfs(cur-&gt;ls); int rdep = dfs(cur-&gt;rs); maxd = max(maxd, ldep + rdep + 1); return max(ldep, rdep) + 1;} #### 脑筋急转弯 有25个人，跑道一次只能跑5个人，问最少跑几次能得到冠亚季军啊。 * Solution 一眼看穿是多路归并啊，然后算了一下是8啊。。 ### 二面 不记得问了啥啊，就扔了一个题，然后问了点儿机器学习的东西 #### 复杂链表的复制 * Description 有一个链表L,其每个节点有2个指针，一个指针next指向链表的下个节点，另一个random随机指向链表中的任一个节点，可能是自己或者为空，写一个程序，复制这个链表 * Solution 剑指offer上有啊，看了一眼思路啊当时就，然后很慌啊。 不过面了那么多面试啊，一下子就冷静了啊。然后就会了啊。 就后面拷贝一份搞一搞啊。 * Code ```cpp struct Node{ int val; Node *nxt, *random; Node(){} Node(int val, Node *nxt, Node *random): val(val), nxt(nxt), random(random){} }; Node* copyComplexList(Node *head){ if(head == nullptr) return nullptr; for(Node *cur = head; cur != nullptr; cur = cur-&gt;nxt-&gt;nxt){ Node *copied = new Node(cur-&gt;val, cur-&gt;nxt, cur-&gt;random); cur-&gt;nxt = copied; } for(Node *cur = head-&gt;nxt; cur != nullptr; cur = cur-&gt;nxt-&gt;nxt){ cur-&gt;random = cur-&gt;random-&gt;nxt; } Node *nHead = head-&gt;nxt; for(Node *cur = head; cur != nullptr; cur = cur-&gt;nxt){ Node *copied = cur-&gt;nxt; Node *copiedNxt = copied-&gt;nxt-&gt;nxt; Node *curNxt = cur-&gt;nxt-&gt;nxt; cur-&gt;nxt = curNxt; copied-&gt;nxt = copiedNxt; } return nHead; } 机器学习 手推一下LR吧就直接把Hypothesis Function，Cost Function写一写，Gradient Decent推一推啊。然后我就推了一下啊，sigmoid函数的导数差点不会推啊。。有惊无险啊 正则参数$\lambda$选取的影响啊大了会overfitting啊，小了会underfitting啊。 一个奇怪的题 Description对一个数组，有n个数据，找一个索引的位置k，使前k个数的方差var(k)和后面n-k个数的方差var(n-k)之和最小。 Solution不知道能不能$O(1)$啊，不会做啊，就暴力展开了一下方差啊然后$O(n)$枚举$k$，$O(1)$算答案，总复杂度$O(n)$ Code```cpp/_var = \sum_{i=1}^n (x_i - avg)^2= \sum_{i=1}^n (x_i ^ 2 + avg^2 - 2_x_i*avg)= \sum_{i=1}^n (x_i ^ 2 + (sum / n)^2 - 2 _ x_i _ (sum / n))= \sum_{i=1}^n x_i^2 + sum^2 /n - 2*sum^2/n= \sum_{i=1}^n x_i^2 - sum^2/n*/ int findIndex(const vector&amp; v){ int preSqSum = 0, totSqSum = 0; int preSum = 0, totSum = 0; pair varAndIdx = {-1, -1}; for(int i = 0; i &lt; v.size(); ++i){ totSqSum += v[i] _ v[i]; totSum += v[i]; } for(int i = 0; i &lt; v.size(); ++i){ preSum += v[i]; preSqSum += v[i] _ v[i]; int sufSqSum = totSqSum - preSqSum; int sufSum = totSum - preSum; double preVar = preSqSum - 1.0 _ preSum _ preSum / (i + 1); double sufVar = sufSqSum - 1.0 _ sufSum _ sufSum/ (v.size() - i - 1); varAndIdx = max(varAndIdx, {preVar + sufVar, i}); } return varAndIdx.second;} ### 三面 #### 24点游戏 * Description 给定4个整数0～9，给出是否能计算得到24，加减乘除括号，普通算术运算。精度他说`1e-5` * Solution 以前写过啊，蓝儿没脑子了啊，连面了两面。 就选择写暴力搜索所有表达式啊。 然后就因为`string v = &quot;&quot; + toChar(a) + toChar(b) + toChar(c) + toChar(d);` 这个垃圾代码不CE挂了啊。。我以为会CE的啊。结果最后半天才反应到这里。 写了半个多小时，面试官他写了一个都写完了啊。。难受啊。。 我当时好怂啊，不自信啊。。结果面试结束后几分钟就调通了啊。 * My Code 找不到最终版本了，就扔个有点小问题的吧。纪念一下我这个“C++大师” ```cpp #include &lt;bits/stdc++.h&gt; using namespace std; const string op = &quot;+-*/&quot;; int getPriority(char c) { if(c == &#39;+&#39; || c == &#39;-&#39;) return 1; else if(c == &#39;*&#39; || c == &#39;/&#39;) return 2; return 0; } vector&lt;string&gt; inToPost(const string&amp; expr) { stack&lt;char&gt; opr; vector&lt;string&gt; ret; for(int i = 0; i &lt; expr.size(); ++i) { char c = expr[i]; if(c == &#39;(&#39;) opr.push(c); else if(c == &#39;)&#39;) { while(true) { char top = opr.top(); opr.pop(); if(top == &#39;(&#39;) break; ret.push_back(string(1, top)); } } else if(isdigit(c)) { string digit; for(; i &lt; expr.size() &amp;&amp; isdigit(expr[i]); ++i) digit += expr[i]; ret.push_back(digit); --i; } else { int curP = getPriority(c); for(; opr.size() &amp;&amp; getPriority(opr.top()) &gt;= curP; opr.pop()) ret.push_back(string(1, opr.top())); opr.push(c); } } for(; opr.size(); opr.pop()) ret.push_back(string(1, opr.top())); return ret; } double calc(const vector&lt;string&gt;&amp; post) { stack&lt;double&gt; opd; for(const auto&amp; s : post) { if(isdigit(s[0])) opd.push(stod(s)); else { assert(opd.size()); double y = opd.top(); opd.pop(); assert(opd.size()); double x = opd.top(); opd.pop(); if(s[0] == &#39;+&#39;) opd.push(x + y); else if(s[0] == &#39;-&#39;) opd.push(x - y); else if(s[0] == &#39;*&#39;) opd.push(x * y); else opd.push(x / y); } } return opd.top(); } bool check(int dep, bool lftBracketed, string s) { if(dep == s.size()) { if(lftBracketed) s += &#39;)&#39;; // cout &lt;&lt; s &lt;&lt; endl; if(abs(calc(inToPost(s)) - 24) &lt; 1e-5) return true; return false; } if(isdigit(s[dep])) { if(dep &gt; 0) { for(int i = 0; i &lt; 4; ++i) { string ns = s; ns.insert(dep, 1, op[i]); if(check(dep + 2, lftBracketed, ns)) return true; if(lftBracketed) { ns.insert(dep + 2, 1, &#39;)&#39;); if(check(dep + 3, 0, ns)) return true; } else { ns.insert(dep + 1, 1, &#39;(&#39;); if(check(dep + 3, 1, ns)) return true; } } } else if(check(dep + 1, lftBracketed, s)) return true; } else if(check(dep + 1, lftBracketed, s)) return true; return false; } bool twentyFour(int a, int b, int c, int d) { auto toChar = [](int x) {return char(&#39;0&#39; + x);}; string v = string(&quot;&quot;) + toChar(a) + toChar(b) + toChar(c) + toChar(d); sort(v.begin(), v.end()); bool ok = false; do { ok |= check(0, 0, v); } while(!ok &amp;&amp; next_permutation(v.begin(), v.end())); return ok; } int main() { string test = &quot;5*5-5/5&quot;; //cout &lt;&lt; calc(test) &lt;&lt; endl; cout &lt;&lt; (calc(inToPost(test))) &lt;&lt; endl; cout &lt;&lt; twentyFour(5, 5, 5, 5) &lt;&lt; endl; return 0; } Interviewer’s Code没仔细读这个代码啊，改天研究一下正确性，写一个bugfree的24点感觉不容易啊。。 import itertools def isEqual(v0, v1): return abs(v0 - v1) &lt; 1e-6 def expresssion(code, v0, v1): if code == 0: return v0 + v1 elif code == 1: return v0 - v1 elif code == 2: return v1 - v0 elif code == 3: return v0 * v1 elif code == 4: if isEqual(v1, 0): return float(&#39;NaN&#39;) return float(v0)/v1 elif code == 5: if isEqual(v0, 0): return float(&#39;NaN&#39;) return float(v1)/v0 def printExpr(code, v0, v1): if code == 0: print &#39;%s+%s&#39; %(v0, v1) if code == 1: print &#39;%s-%s&#39; %(v0, v1) if code == 2: print &#39;%s-%s&#39; % (v1, v0) if code == 3: print &#39;%s*%s&#39; % (v0, v1) if code == 4: print &#39;%s/%s&#39; % (v0, v1) if code == 5: print &#39;%s/%s&#39; %(v1, v0) def search(a, v): if len(a) == 1: return isEqual(a[0], v) elif len(a) == 2: for code in range(6): if isEqual(expresssion(code, a[0], a[1]), v): printExpr(code, a[0], a[1]) return True return False elif len(a) == 3: for b in itertools.permutations(a): for code in range(6): if search([expresssion(code, b[0], b[1]), b[2]], v): printExpr(code, b[0], b[1]) return True return False elif len(a) == 4: for b in itertools.permutations(a): for code in range(6): if search([expresssion(code, b[0], b[1]), b[2], b[3]], v): printExpr(code, b[0], b[1]) return True return False elif len(a) == 4: for b in itertools.permutations(a): for code in range(6): if search([expresssion(code, b[0], b[1]), b[2], b[3]], v): printExpr(code, b[0], b[1]) return True return False print search([3, 3, 8, 8], 24) 然后就又没然后了啊后记好好学习辣！然后要自信！失败了并不会失去什么。]]></content>
      <categories>
        <category>Doing</category>
        <category>Interview</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[WAPS Interview]]></title>
    <url>%2F2017%2F04%2F28%2FWAPS-Interview%2F</url>
    <content type="text"><![CDATA[3.31 rejected..Since the campus recruitment in this year is over, a little summary here.. Online Coding???I forgot this one and no record, really easy though. Verify Preorder Serialization of a Binary TreeOne way to serialize a binary tree is to use pre-order traversal.When we encounter a non-null node, we record the node’s value.If it is a null node, we record using a sentinel value such as #. Examples • “9,3,4,#,#,1,#,#,2,#,6,#,#” → true • “1,#” → false • “9,#,#,1” → false SolutionJust simply go pre-order traversal and check whether each node has two sons…Careful about some corner cases.. Code Onsite Interview4 easy problems… I gotta have a solution only with a glance. I only recall 2 of them. Anagram Matchinganagram: a word formed by rearranging the letters of another, such as cinema, formed from icemantry to figgure out the number of occurrences of all the anagrams of $T$ in $S$, lowercase alphabets Solutionuse the number of occurrences of each alphabet to hash all the anagrams of $T$total time complexity is $O(\sum |S|),where\sum = 26$ Maximum Weighted Independent Set of a treechoose some nodes that each pair of them have no edge.try to maximize the total weight of the chosen nodes Solutionsimple tree dp. $f[u][0/1]:=$ the maximum weight of the independent set that the subtree rooted at $u$, and choosing $u$ or notand the transition is simple:choose $u$, all of its sons mustn’t be choosednot choose $u$, choosing or not choosing its sons is OK, choose the maximum one.$ans=\max \{f[root][0], f[root][1]\}$total time complexity is $O(N)$ SummaryTwo interviewers are both very nice and patient. Good Expericence. VP InterviewFvcking stupid that I talked about FP programming…I’m not familiar with that..I think the Japanese interviewer was a little sleepy, so absolutely my interview is a shit.. even he “woke up” when heard FP..And it seemed that the Chinese one is weak.. some easy cpp questions.. Bad Expericence！A Lesson：no more talking about the things without knowing a shit.. Something moreNo chance to attempt the indeed interview is a pity..it would be very nice to have a free trip to Japan..]]></content>
      <categories>
        <category>Doing</category>
        <category>Interview</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[So Sad]]></title>
    <url>%2F2017%2F04%2F24%2FSo-Sad%2F</url>
    <content type="text"><![CDATA[Sooooo Sad! Nothing changes, am I wrong?Defintely not, calm down for some time.. Well, many things to do…Which one get the most priority? Am I clear? Am I really prepared? I’m afraid that something may follow the process of history.. Try to be more precise on some certain thing. Any time, calm down.The desire can lead you to the paradise and also the hell… Think about myself.A Little afraid to failure… That’s not what I want. I wanna get my straightness and bravery back! Well, all things will be OK.]]></content>
      <categories>
        <category>Doing</category>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 408 (Div. 2)]]></title>
    <url>%2F2017%2F04%2F12%2FCodeforces%20Round%20408%20(Div.%202)%2F</url>
    <content type="text"><![CDATA[$C题直接读错题，被教育到死，DE其实好做，没仔细想就跑了。。$ C. Bank Hacking题意：$N\le 10^5个点的树，点权，初始每个点黑色，现在要涂白$$你的力量\ge 点权可以涂白，开始任选一点涂$$涂白一个点导致和它之间相连的黑点点权+1，通过一个黑点相连的点权也+1$$之后涂白一个点，必须保证它和一个白点相连$$问最少需要多少力量怎么把所有点涂白$ 分析：$眼瞎没看到通过一个黑点相连，然后又没看到涂白的点必须和白点相连$$这2个这么强的条件，你玩一下发现就是一圈一圈涂的，答案最多是maxA_i+2$$然后你就枚举起点，相连的+1，其他的+2就可以了$$map、multiset都怼不过去，按rank排序上BIT吧$$其实维护一下maxA_i和maxA_i-1的个数就可以了，都没有说明答案maxA_i，不然有谁就谁+2$$这里给出O(nlogn)的代码$ 代码： // // Created by TaoSama on 2017-04-11 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cerr &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cerr &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 3e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, a[N]; vector&lt;int&gt; G[N]; struct BIT { int n, b[N]; void init(int _n) { n = _n; memset(b, 0, sizeof b); } void add(int i, int v) { for(; i &lt;= n; i += i &amp; -i) b[i] += v; } int sum(int i) { int ret = 0; for(; i; i -= i &amp; -i) ret += b[i]; return ret; } int kth(int k) { int ret = 0; for(int i = 18; ~i; --i) { int x = 1 &lt;&lt; i; if(ret + x &lt;= n &amp;&amp; b[ret + x] &lt; k) { k -= b[ret + x]; ret += x; } } return ret + 1; } } bit; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); while(scanf(&quot;%d&quot;, &amp;n) == 1) { for(int i = 1; i &lt;= n; ++i) G[i].clear(); vector&lt;int&gt; xs; for(int i = 1; i &lt;= n; ++i) { scanf(&quot;%d&quot;, a + i); xs.push_back(a[i]); } for(int i = 1; i &lt; n; ++i) { int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); } sort(xs.begin(), xs.end()); xs.resize(unique(xs.begin(), xs.end()) - xs.begin()); auto getRank = [&amp;](int x) { return lower_bound(xs.begin(), xs.end(), x) - xs.begin() + 1; }; int ans = INF; bit.init(xs.size()); for(int i = 1; i &lt;= n; ++i) bit.add(getRank(a[i]), 1); for(int i = 1; i &lt;= n; ++i) { int cur = a[i]; bit.add(getRank(a[i]), -1); for(int v : G[i]) { bit.add(getRank(a[v]), -1); cur = max(cur, a[v] + 1); } int k = bit.sum(xs.size()); if(k) { int idx = bit.kth(k); cur = max(cur, xs[idx - 1] + 2); } ans = min(ans, cur); bit.add(getRank(a[i]), 1); for(int v : G[i]) bit.add(getRank(a[v]), 1); } printf(&quot;%d\n&quot;, ans); } return 0; } D. Police Stations题意：$N\le 10^5的树，1\le K\le 10^5个标记点，给定距离0\le D &lt; N$$问最多删去几条边使得，每个点到标记点的距离还能不超过D$$保证有解$ 分析:$保证有解，所以其实就相当于每个标记点所在的连通块与其他的连接对半切$$找到这个对半切的边就好了，答案一定是标记点数-1$$直接从标记点开始bfs就好了，如果碰到访问过的点，切掉就ok，一定是对半切的$$毕竟bfs是按照level来的，这样实现非常帅气啊$ // // Created by TaoSama on 2017-04-11 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cerr &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cerr &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 3e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, m, d; bool cut[N], vis[N]; vector&lt;pair&lt;int, int&gt;&gt; G[N]; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); while(scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;d) == 3) { vector&lt;pair&lt;int, int&gt;&gt; q; q.reserve(n); for(int i = 1; i &lt;= m; ++i) { int x; scanf(&quot;%d&quot;, &amp;x); q.push_back({x, 0}); } for(int i = 1; i &lt;= n; ++i) G[i].clear(); for(int i = 1; i &lt; n; ++i) { int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); G[u].push_back({v, i}); G[v].push_back({u, i}); } memset(vis, 0, sizeof vis); memset(cut, 0, sizeof cut); for(int i = 0; i &lt; q.size(); ++i) { int u, fa; tie(u, fa) = q[i]; if(vis[u]) continue; vis[u] = true; for(const auto&amp; e : G[u]) { int v, id; tie(v, id) = e; if(v == fa) continue; if(vis[v]) { cut[id] = true; continue; } q.push_back({v, u}); } } vector&lt;int&gt; ans; for(int i = 1; i &lt; n; ++i) if(cut[i]) ans.push_back(i); printf(&quot;%d\n&quot;, ans.size()); for(int i = 0; i &lt; ans.size(); ++i) printf(&quot;%d%c&quot;, ans[i], &quot; \n&quot;[i + 1 == ans.size()]); } return 0; } E. Exam Cheating题意：$N\le 10^3行，有2个人，各会一些其中一些行，主人公看P\le 10^3次$$每次选择一个人看连续K\le 50行，问主人公最多能会多少行$ 分析:$首先有一个暴力的dp，f[i][j][a][b]:=1\sim i行，看了j次$$上一次看使得第一个人可以免费看a行，第二个人b行的最多会的行数$$转移就枚举不看，看第一个人，看第二个人，都看$$复杂度是O(npk^2)，显然会T$$注意连续这个条件，2个人加起来最多看2\times \lceil {n\over k}\rceil次$$所以复杂度变成了O(n\times 2\times \lceil {n\over k}\rceil k^2)=O(n^2k)$$cf跑得很快就可以过了$ // // Created by TaoSama on 2017-04-11 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cerr &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cerr &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, m, k; int f[2][1005][55][55]; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); while(scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k) == 3) { vector&lt;int&gt; q(n + 1, 1); vector&lt;int&gt; a(n + 1, 0), b(n + 1, 0); int aCnt; scanf(&quot;%d&quot;, &amp;aCnt); while(aCnt--) { int x; scanf(&quot;%d&quot;, &amp;x); a[x] = 1; } int bCnt; scanf(&quot;%d&quot;, &amp;bCnt); while(bCnt--) { int x; scanf(&quot;%d&quot;, &amp;x); b[x] = 1; } int p = 0; memset(f[p], 0xc0, sizeof f[p]); f[p][0][0][0] = 0; auto getMax = [](int&amp; x, int y) {if(x &lt; y) x = y;}; m = min(m, 2 * (n + k - 1) / k); for(int i = 1; i &lt;= n; ++i) { memset(f[!p], 0xc0, sizeof f[!p]); for(int j = 0; j &lt;= m; ++j) { for(int x = 0; x &lt;= k; ++x) { for(int y = 0; y &lt;= k; ++y) { int nj, nx, ny, val; nj = j, nx = max(0, x - 1), ny = max(0, y - 1), val = (nx &amp;&amp; a[i]) || (ny &amp;&amp; b[i]); getMax(f[!p][nj][nx][ny], f[p][j][x][y] + val); nj = j + 1, nx = k, ny = max(0, y - 1), val = (nx &amp;&amp; a[i]) || (ny &amp;&amp; b[i]); getMax(f[!p][nj][nx][ny], f[p][j][x][y] + val); nj = j + 1, nx = max(0, x - 1), ny = k, val = (nx &amp;&amp; a[i]) || (ny &amp;&amp; b[i]); getMax(f[!p][nj][nx][ny], f[p][j][x][y] + val); nj = j + 2, nx = k, ny = k, val = (nx &amp;&amp; a[i]) || (ny &amp;&amp; b[i]); getMax(f[!p][nj][nx][ny], f[p][j][x][y] + val); } } } p = !p; } int ans = 0; for(int j = 0; j &lt;= m; ++j) { for(int x = 0; x &lt;= k; ++x) { for(int y = 0; y &lt;= k; ++y) { getMax(ans, f[p][j][x][y]); } } } printf(&quot;%d\n&quot;, ans); } return 0; }]]></content>
      <categories>
        <category>套题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 358 (Div. 2) E. Alyona and Triangles]]></title>
    <url>%2F2017%2F04%2F12%2FCodeforces%20Round%20358%20(Div.%202)%20E.%20Alyona%20and%20Triangles%2F</url>
    <content type="text"><![CDATA[题意：$N\le 5000个点，保证任意形成的三角形的面积\le S\le 10^{18}$$现在构成出一个三角形面积不超过4S，使得包含这个N个点$ 分析：$求个凸包，然后n^2枚举2个点，two pointers旋转卡壳搞出第三个点$$求出最大三角形，之后把每条边作为对角线搞出大三角形就好了$$即原来三角形的每个点是新三角形每条边的中点$$证明方式就反证一下，如果有点在大三角形外$$那么他作为新的三角形的顶点，拥有更大的高，面积更大，矛盾$$所以原来的构造方法正确$$时间复杂度O(n^2)$ 题外话：$我觉得点积叉积还是写函数比较好，不重载运算符比较好$$避免更多的括号，省得出事，而且好看，算是更新了一下板子$ 代码： // // Created by TaoSama on 2017-04-10 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cerr &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cerr &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; typedef long long Type; struct Point { Type x, y; Point() {} Point(Type x, Type y) : x(x), y(y) {} void read() {scanf(&quot;%lld%lld&quot;, &amp;x, &amp;y);} void write() {printf(&quot;%lld %lld\n&quot;, x, y);} Point operator+(const Point&amp; p) const { return Point(x + p.x, y + p.y); } Point operator-(const Point&amp; p) const { return Point(x - p.x, y - p.y); } bool operator&lt;(const Point&amp; p) const { return x != p.x ? x &lt; p.x : y &lt; p.y; } }; Type dot(const Point&amp; A, const Point&amp; B) { return A.x * B.x + A.y * B.y; } Type det(const Point&amp; A, const Point&amp; B) { return A.x * B.y - A.y * B.x; } //输入不能有重点，函数执行完后输入顺序被破坏 Point ps[N], ch[N]; int convexHull(Point* p, int n, Point* ch) { sort(p, p + n); int m = 0; for(int i = 0; i &lt; n; ++i) { while(m &gt; 1 &amp;&amp; det(ch[m - 1] - ch[m - 2], p[i] - ch[m - 2]) &lt;= 0) --m; ch[m++] = p[i]; } for(int i = n - 2, t = m; ~i; --i) { while(m &gt; t &amp;&amp; det(ch[m - 1] - ch[m - 2], p[i] - ch[m - 2]) &lt;= 0) --m; ch[m++] = p[i]; } if(n &gt; 1) --m; return m; } vector&lt;int&gt; rotatingCalipers(Point* ch, int n) { if(n &lt; 3) return vector&lt;int&gt;(); Type ans = 0; vector&lt;int&gt; ret(3); ch[n] = ch[0]; for(int i = 0; i &lt; n; ++i) { for(int j = i + 1, k = j; j &lt; n; ++j) { while(det(ch[j] - ch[i], ch[k + 1] - ch[i]) &gt; det(ch[j] - ch[i], ch[k] - ch[i])) k = (k + 1) % n; if(det(ch[j] - ch[i], ch[k] - ch[i]) &gt; ans) { ans = det(ch[j] - ch[i], ch[k] - ch[i]); ret = {i, j, k}; } } } return ret; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); int n; long long s; scanf(&quot;%d%lld&quot;, &amp;n, &amp;s); for(int i = 0; i &lt; n; ++i) ps[i].read(); int m = convexHull(ps, n, ch); vector&lt;int&gt; triangle = rotatingCalipers(ch, m); for(int i = 0; i &lt; 3; ++i) { Point p = ch[triangle[i]] + ch[triangle[(i + 1) % 3]] - ch[triangle[(i + 2) % 3]]; p.write(); } return 0; }]]></content>
      <categories>
        <category>计算几何</category>
        <category>旋转卡壳</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[BestCoder Round 93]]></title>
    <url>%2F2017%2F04%2F12%2FBestCoder%20Round%2093%2F</url>
    <content type="text"><![CDATA[补题学套路。。 1001 MG loves gold题意：$N\le 10^5个数的序列，拆成尽快多的部分，使得每个部分不包含重复数字$ 分析:$直接贪心就好了，每次取尽可能长的不包含重复数字的，set判重即可$ 代码： // // Created by TaoSama on 2017-04-01 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cerr &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cerr &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, a[N]; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, a + i); int ans = 0; set&lt;int&gt; mp; for(int i = 1, j; i &lt;= n; i = j) { ++ans; mp.clear(); for(j = i; j &lt;= n &amp;&amp; !mp.count(a[j]); ++j) mp.insert(a[j]); } printf(&quot;%d\n&quot;, ans); } return 0; } 1002 MG loves apple题意：$给定1个N\le 10^5位的不含前导零的数字，现删去恰好0\le K&lt;N个数字$$使得剩下的数字，顺序不变，构成的合法数字，能被3整除$$问是否可行$ 分析：$这个题跟CF EDU 18 C的贪心做法类似$$首先一个数能被3整除跟数字和sum能被3整除一致$$接下来就统计一下cnt_i的个，\%3=i的数个数$$首先特判数字中含0，且k=n-1的情况，CF那个题也是$ $之后就枚举非0数字，使得它作为第一位，存不存在一种合法方案使得sum\%3=0$$这里要注意，这个非0数字是不能删掉的，他前面的都必须删掉，后面的就枚举一下$$枚举0,1,3选取的个数，当然是\%3后的，之后判断need的数去掉这些之后能不能被3整除$$然后判一判就好了，注意细节$$复杂度O(3^3n)$ // // Created by TaoSama on 2017-04-01 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cerr &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cerr &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e6 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, m; char a[N], r[N]; int cnt[3]; bool go(int mod, int need) { for(int a = 0; a &lt; 3; ++a) { //1 if(a &gt; cnt[1]) continue; for(int b = 0; b &lt; 3; ++b) { //2 if(b &gt; cnt[2]) continue; for(int c = 0; c &lt; 3; ++c) { //0 if(c &gt; cnt[0]) continue; if((a + 2 * b) % 3 != mod) continue; if(a + b + c &gt; need) continue; if((need - a - b - c) % 3 != 0) continue; int t = (cnt[1] - a) / 3 + (cnt[2] - b) / 3 + (cnt[0] - c) / 3; if(3 * t + a + b + c &gt;= need) return true; } } } return false; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%d%d%s&quot;, &amp;n, &amp;m, a + 1); int sum = 0; for(int i = 0; i &lt; 3; ++i) cnt[i] = 0; for(int i = 1; i &lt;= n; ++i) { a[i] -= &#39;0&#39;; r[i] = a[i] % 3; ++cnt[r[i]]; sum += r[i]; } bool ok = false; if(m == n - 1) for(int i = 1; i &lt;= n &amp;&amp; !ok; ++i) ok |= a[i] == 0; int need = m; for(int i = 1; i &lt;= n &amp;&amp; !ok; ++i) { int x = a[i]; if(x) { --cnt[r[i]]; ok |= go(sum % 3, need); } else --cnt[r[i]]; sum -= r[i]; if(--need &lt; 0) break; } puts(ok ? &quot;yes&quot; : &quot;no&quot;); } return 0; } 1003 MG loves string题意：$给定一个26个小写字母的置换A，即进行一次变换，所有字符(‘a’+i)都会变成A_i$$问一个长度是N\le 10^9随机字符串，变换到自身的期望变换次数$$输出期望答案乘上26^n以后模10^9+7的结果$ 分析：$可以发现不同的置换的环的长度不超过6个，1+2+3+4+5+6&gt;26$$所以就枚举不同的置换的环的组合，至少出现一次的方案数$$我们知道一个置换变回自己的次数是，每个环的长度的lcm$$先统计出每个环长度的选取的字母的个数$$f[sta]:=sta状态的环至少出现一次的方案数$$算这个可以容斥来搞，随便选-非法的$$g[sta]:=sta状态的环随便选的方案数，g[sta]=cnt[sta]^n$$f[sta]=g[sta]-\displaystyle\sum_{s0\subset sta} f[s0]$$之后乘上对应的lcm就可以了$$复杂度为O(6^3logn)$ // // Created by TaoSama on 2017-04-02 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cerr &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cerr &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n; char a[27]; int f[1 &lt;&lt; 6]; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%d%s&quot;, &amp;n, a); for(int i = 0; i &lt; 26; ++i) a[i] -= &#39;a&#39;; map&lt;int, int&gt; mp; for(int i = 0; i &lt; 26; ++i) { int cnt = 1; for(int j = a[i]; j != i; j = a[j]) ++cnt; ++mp[cnt]; } vector&lt;pair&lt;int, int&gt;&gt; v(mp.begin(), mp.end()); auto add = [&amp;](int&amp; x, int y) {if((x += y) &gt;= MOD) x -= MOD;}; auto quickPow = [&amp;](int x, int y) { int ret = 1; for(; y; y &gt;&gt;= 1) { if(y &amp; 1) ret = 1LL * ret * x % MOD; x = 1LL * x * x % MOD; } return ret; }; int ans = 0; for(int s = 1; s &lt; 1 &lt;&lt; v.size(); ++s) { int sum = 0, lcm = 1; for(int i = 0; i &lt; v.size(); ++i) { if(s &gt;&gt; i &amp; 1) { lcm = lcm / __gcd(lcm, v[i].first) * v[i].first; sum += v[i].second; } } f[s] = quickPow(sum, n); for(int s0 = s &amp; (s - 1); s0; s0 = (s0 - 1) &amp; s) add(f[s], MOD - f[s0]); add(ans, 1LL * f[s] * lcm % MOD); } printf(&quot;%d\n&quot;, ans); } return 0; } 1004 MG loves set题意：$如果一个集合所有元素的平方的和小于等于所有元素的和的平方，那么就称这个集合为“和谐集合”。$$给定n\le 30个数，询问有多少个非空子集是“和谐集合”$ 分析：$现有一个集合S，则题目的条件为\displaystyle\sum_{x\in S} x^2\le (\displaystyle\sum_{x\in S} x)^2$$移项则有，(\displaystyle\sum_{x\in S} x)^2-\displaystyle\sum_{x\in S} x^2\ge 0，这个就是2\displaystyle\sum_{x, y\in S, x&lt;y}xy\ge 0$$然后看到n=30，显然的折半枚举$$令va=\displaystyle\sum_{x\in S} x，vb=2\displaystyle\sum_{x, y\in S, x&lt;y}xy$$那么上面那个式子由2个集合合并可以表示为，2\times va\times va’+vb+vb’\ge 0$$把(va, vb)看成直线，(va’, vb’)看成点，那么就是求直线上方的点数，KDT优化即可$$时间复杂度为O(2^{15}log2^{15})$ // // Created by TaoSama on 2017-04-03 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cerr &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cerr &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; typedef long long LL; const LL LLINF = 0x3f3f3f3f3f3f3f3fLL; namespace KDT { const int M = 1 &lt;&lt; 16, K = 2; int D; struct Point { LL d[K]; inline LL&amp; operator[](int k) {return d[k];} inline const LL&amp; operator[](int k) const {return d[k];} inline bool operator&lt;(const Point&amp; p) const { return d[D] &lt; p.d[D]; } } a[M]; struct Node { Point key, maxd, mind; Node* ch[2]; int sz; inline void up() { sz = ch[0]-&gt;sz + ch[1]-&gt;sz + 1; for(int i = 0; i &lt; K; ++i) { maxd[i] = max(maxd[i], ch[0]-&gt;maxd[i]); maxd[i] = max(maxd[i], ch[1]-&gt;maxd[i]); mind[i] = min(mind[i], ch[0]-&gt;mind[i]); mind[i] = min(mind[i], ch[1]-&gt;mind[i]); } } } pool[M], *ptr, *null, *root; inline bool onLine(const Point&amp; p, const Point&amp; q) { return 2 * p[0] * q[0] + p[1] + q[1] &gt;= 0; } inline int h(Node* o, const Point&amp; p) { int ret = 0; ret += onLine({o-&gt;mind[0], o-&gt;mind[1]}, p); ret += onLine({o-&gt;mind[0], o-&gt;maxd[1]}, p); ret += onLine({o-&gt;maxd[0], o-&gt;mind[1]}, p); ret += onLine({o-&gt;maxd[0], o-&gt;maxd[1]}, p); return ret; } inline Node* newNode(const Point&amp; p) { ptr-&gt;key = p; ptr-&gt;ch[0] = ptr-&gt;ch[1] = null; for(int i = 0; i &lt; K; ++i) ptr-&gt;maxd[i] = ptr-&gt;mind[i] = ptr-&gt;key[i]; return ptr++; } void init() { ptr = pool; null = ptr++; null-&gt;sz = 0; null-&gt;ch[0] = null-&gt;ch[1] = null; for(int i = 0; i &lt; K; ++i) { null-&gt;mind[i] = LLINF; null-&gt;maxd[i] = -LLINF; } } void build(Node*&amp; o, int l, int r, int dim) { if(l &gt; r) return; int m = l + r &gt;&gt; 1; D = dim; nth_element(a + l, a + m, a + r + 1); o = newNode(a[m]); build(o-&gt;ch[0], l, m - 1, (dim + 1) % K); build(o-&gt;ch[1], m + 1, r, (dim + 1) % K); o-&gt;up(); } int query(Node* o, const Point&amp; p) { if(o == null) return 0; int have = h(o, p); if(!have) return 0; if(have == 4) return o-&gt;sz; int ret = onLine(o-&gt;key, p); ret += query(o-&gt;ch[0], p); ret += query(o-&gt;ch[1], p); return ret; } } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;, &quot;w&quot;, stdout); #endif ios_base::sync_with_stdio(0); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { int n; scanf(&quot;%d&quot;, &amp;n); vector&lt;int&gt; v(n); for(int&amp; x : v) scanf(&quot;%d&quot;, &amp;x); int hf = (n + 1) &gt;&gt; 1; for(int s = 0; s &lt; 1 &lt;&lt; hf; ++s) { LL va = 0, vb = 0; for(int i = 0; i &lt; hf; ++i) { if(s &gt;&gt; i &amp; 1) { va += v[i]; vb += 1LL * v[i] * v[i]; } } KDT::a[s + 1] = {va, va* va - vb}; } KDT::init(); KDT::Node*&amp; root = KDT::root; KDT::build(root, 1, 1 &lt;&lt; hf, 0); n &gt;&gt;= 1; int ans = 0; for(int s = 0; s &lt; 1 &lt;&lt; n; ++s) { LL va = 0, vb = 0; for(int i = 0; i &lt; n; ++i) { if(s &gt;&gt; i &amp; 1) { va += v[hf + i]; vb += 1LL * v[hf + i] * v[hf + i]; } } ans += KDT::query(root, {va, va * va - vb}); } printf(&quot;%d\n&quot;, ans - 1); } return 0; }]]></content>
      <categories>
        <category>套题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hihocode 1496 寻找最大值（高维前缀和）]]></title>
    <url>%2F2017%2F04%2F05%2FHihocode%201496%20%E5%AF%BB%E6%89%BE%E6%9C%80%E5%A4%A7%E5%80%BC%EF%BC%88%E9%AB%98%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意：$给定一个长度为N\le 10^5的数列，1\le A_i\le 2^{20}$$求\displaystyle\max_{i, j, i\neq j}\{A_i\times A_j\times (A_i\&amp; A_j)\}的值$ 分析：$这个题显然不能枚举A_i和A_j，考虑枚举A_i\&amp; A_j的值$$令z=A_i\&amp;A_j，事实上条件可以不用这么严格$$只要找到z的超集Z’即可，即z\supset Z’$$假如存在Z’中的两个元素z’_1，z’_2分别是最大值和次大值$$满足z’_1\&amp; z’_2=z，那么这个必然是z的答案$$假如z’_1\&amp; z’_2&gt;z，那么令z’_1\&amp; z’_2=y$$那么这个答案必然在y处更新，且答案更大，也就是说不会影响答案$$所以问题就变成了如何求z的超集的最大值和次大值了$ $这是一个高位前缀和问题，即20维空间，每一维大小是2$$所以把1的答案都加到0上即可，因为1是0的超集$$同理子集问题也可以这么搞，不过是0加到1上，0是1的子集$$具体看代码，注意循环顺序，感受一下前缀和$ 代码： // // Created by TaoSama on 2017-04-04 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cerr &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cerr &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n; pair&lt;int, int&gt; f[1 &lt;&lt; 20]; pair&lt;int, int&gt; operator+(pair&lt;int, int&gt; A, pair&lt;int, int&gt; B) { pair&lt;int, int&gt; ret = A; if(B.first &gt; ret.first) { swap(ret.first, ret.second); ret.first = B.first; } else if(B.second &gt; ret.second) ret.second = B.second; return ret; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%d&quot;, &amp;n); for(int i = 0; i &lt; 1 &lt;&lt; 20; ++i) f[i] = {0, 0}; for(int i = 1; i &lt;= n; ++i) { int x; scanf(&quot;%d&quot;, &amp;x); f[x] = f[x] + make_pair(x, 0); } for(int i = 0; i &lt; 20; ++i) for(int j = 0; j &lt; 1 &lt;&lt; 20; ++j) if(j &gt;&gt; i &amp; 1) f[j ^ (1 &lt;&lt; i)] = f[j ^ (1 &lt;&lt; i)] + f[j]; long long ans = 0; for(int i = 0; i &lt; 1 &lt;&lt; 20; ++i) ans = max(ans, 1LL * i * f[i].first * f[i].second); printf(&quot;%lld\n&quot;, ans); } return 0; }]]></content>
      <categories>
        <category>数学</category>
        <category>FFT/NTT/FWT</category>
      </categories>
      <tags>
        <tag>高维前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hihocode 1492 Parentheses Sequence（dp）]]></title>
    <url>%2F2017%2F04%2F05%2FHihocode%201492%20Parentheses%20Sequence%EF%BC%88dp%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意：$给定一个长度为N\le 10^3的括号串，可以插入括号$$问变成合法的括号串的最短插入次数，和方法数$ 分析：$首先回顾一下如何表示一个合法的括号串$$令’(‘=1，’)’=-1，那么需要前缀和\ge 0，且和=0$$那么显然我们有一个三方的dp$$f[i][j][k]:=1\sim i，插入了j个括号，sum=k的方法数$$再开个bool表示一下状态存不存在即可$$这样就可以找到最少多少个，以及相应的方案数了$ $蓝儿三方是不能过的，思考一下，这其实是一个背包问题$$背包的是sum，所以其实我们看成是一个图的问题，即n\times sum个节点的图$$那么插入的括号的个数自然变成了最短路，方法数自然变成了最短路方案数$$然后dp就变成了f[i][k]:=1\sim i，sum=k的最少插入括号数和方法数$$最后减去原来的括号个数即可$$这个背包化图的思路可以做一下上次CF 407的C：$题目链接 代码： // // Created by TaoSama on 2017-04-04 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cerr &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cerr &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e3 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n; char s[N]; int f[N][N], g[N][N]; void add(int&amp; x, int y) { if((x += y) &gt;= MOD) x -= MOD; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); scanf(&quot;%s&quot;, s + 1); n = strlen(s + 1); queue&lt;pair&lt;int, int&gt;&gt; q; memset(f, -1, sizeof f); f[0][0] = 0, g[0][0] = 1; q.push({0, 0}); while(q.size()) { int i, j; tie(i, j) = q.front(); q.pop(); for(int k = -1; k &lt;= 1; k += 2) { char c = k == 1 ? &#39;(&#39; : &#39;)&#39;; int ni = min(n, i + (s[i + 1] == c)); int nj = j + k; if(nj &gt;= 0 &amp;&amp; nj &lt;= n) { if(f[ni][nj] == -1) { f[ni][nj] = f[i][j] + 1; g[ni][nj] = g[i][j]; q.push({ni, nj}); } else if(f[ni][nj] == f[i][j] + 1) { add(g[ni][nj], g[i][j]); } } } } printf(&quot;%d %d\n&quot;, f[n][0] - n, g[n][0]); return 0; }]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[BestCoder Round 92]]></title>
    <url>%2F2017%2F04%2F05%2FBestCoder%20Round%2092%2F</url>
    <content type="text"><![CDATA[好久没写题解了。。感觉还是经常写点文字。题解勉强算是吧(雾 1001 Skip the Class直接对于每种课程维护最大值和次大值即可 1002 Count the Sheep题意：$给定N\le 10^5个男羊，M\le 10^5个女羊，K\le 10^5个朋友关系$$问满足A-B、B-C、C-D是朋友关系且A、B、C、D各不相同的，A-B-C-D这样序列的方案数$ 分析：$直接枚举B-C边，然后统计下两边的度就好了，别忘了减去自己$ 1003 Girls Love 233题意：$给定长度N\le 100的由字符’2’和’3’构成的字符串$$有\lfloor{M\over 2}\rfloor次操作次数，每次可以交换2个相邻的字符$$最多能使这个字符串中有多少个子串”233”呢$ 分析：$官方题解给了一个很妙的dp$$可以发现答案其实只跟’2’有关，即’3’和’3’换是毫无意义的$$于是我们可以抠出来所有’2’的位置，那么只对’2’有交换的花费$$接下来考虑dp，f[i][j][k][3]:=$$选取了i个’2’，j个’3’，使用了k次交换，状态是s的最多子串数$$s状态显然有i\in [0,3):’2’后面有i个’3’，如果有第一次有2个’3’显然答案+1$$最终ans=\displaystyle\max_{k, s}\{ f[c2][c3][k][s]\}$ 代码: // // Created by TaoSama on 2017-02-27 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cerr &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cerr &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e2 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, m; char s[N]; int f[N][N][N / 2][3]; void getMax(int&amp; x, int y) { if(x &lt; y) x = y; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { vector&lt;int&gt; p(1, 0); scanf(&quot;%d%d%s&quot;, &amp;n, &amp;m, s + 1); m &gt;&gt;= 1; for(int i = 1; i &lt;= n; ++i) if(s[i] == &#39;2&#39;) p.push_back(i); int c2 = p.size() - 1, c3 = n - c2; for(int i = 0; i &lt;= c2; ++i) for(int j = 0; j &lt;= c3; ++j) for(int k = 0; k &lt;= m; ++k) for(int z = 0; z &lt; 3; ++z) f[i][j][k][z] = -INF; f[0][0][0][2] = 0; for(int i = 0; i &lt;= c2; ++i) { for(int j = 0; j &lt;= c3; ++j) { for(int k = 0; k &lt;= m; ++k) { for(int z = 0; z &lt; 3; ++z) { if(f[i][j][k][z] &lt; 0) continue; if(i &lt; c2) { int nk = k + abs(i + j + 1 - p[i + 1]); if(nk &lt;= m) getMax(f[i + 1][j][nk][0], f[i][j][k][z]); } if(j &lt; c3) { int nz = z, one = 0; if(nz != 2) { if(++nz == 2) ++one; } getMax(f[i][j + 1][k][nz], f[i][j][k][z] + one); } } } } } int ans = 0; for(int k = 0; k &lt;= m; ++k) for(int z = 0; z &lt; 3; ++z) getMax(ans, f[c2][c3][k][z]); printf(&quot;%d\n&quot;, ans); } return 0; } 1004 Game Arrangement题意：$给定N\le 10^4段空闲时间[L_i, R_i]，1\le L_i\le R_i\le 10^9$$给定M\le 10^4个游戏的感兴趣时段[l_i, r_i]，1\le l_i\le r_i\le 10^9，并且需要持续时间1\le d_i\le 10^9$$对于i类游戏只能全在它的感兴趣时段，以及某段空闲时段才可以玩$$问最多能玩游戏的次数$ 分析:$如果数据范围不是10^9的话，显然可以按时间来dp，就不多说了$$可以考虑贪心，因为物品的价值都是1，就可以贪心了$$对于当前时间，对某个游戏肯定选择持续短的，就可以用堆或者set来贪心了$$首先把空闲时间和游戏按照起始时间排序$$考虑枚举每一段空闲时间，首先把当前能玩的游戏全部加进去堆里$$再把一把都玩不了的都删了，然后取出第一个能玩的$$当前这个游戏能玩多久由三个东西限制，一个是空闲时间，一个是感兴趣时间$$还有下一个游戏的开始时间来限制$$肯定尝试下取整个是一定可以的$$然后你以为就对了？？显然不是，我还可以后延续到下一个游戏的时间$$所以就考虑再玩一个，但是只是尝试，所以拆成两半，一个是现在玩一些$$剩下的时间成为一个新的游戏塞进去，之后直接尝试下一个游戏就可以了$$这样贪心就对了$$注意一下边界的细节，时间复杂度是O(nlogn)$$感谢bc大佬的代码$ // // Created by TaoSama on 2017-02-27 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cerr &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cerr &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, m; struct Node { int l, r, d; bool operator&lt;(const Node&amp; r) const { return d &gt; r.d; } void see() { pr(l); pr(r); prln(d); } }; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); vector&lt;Node&gt; a, b; a.reserve(n); b.reserve(m); for(int i = 1; i &lt;= n; ++i) { int l, r; scanf(&quot;%d%d&quot;, &amp;l, &amp;r); if(a.size() &amp;&amp; a.back().r + 1 == l) a.back().r = r; else a.push_back({l, r, 0}); } for(int i = 1; i &lt;= m; ++i) { int l, r, d; scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;d); b.push_back({l, r, d}); } b.push_back({INF, -1, -1}); sort(b.begin(), b.end(), [](const Node &amp; a, const Node &amp; b) { return a.l &lt; b.l; }); int ans = 0; priority_queue&lt;Node&gt; q; for(int i = 0, j = 0; i &lt; a.size(); ++i) { int cur = a[i].l; for(; cur &lt;= a[i].r;) { for(; b[j].l &lt;= cur; ++j) q.push(b[j]); //insert while(q.size() &amp;&amp; q.top().r - q.top().d + 1 &lt; cur) q.pop(); //delete if(!q.size()) {cur = b[j].l; continue;} Node tp = q.top(); int r = min(a[i].r, tp.r); int cnt = (min(r, b[j].l - 1) - cur + 1) / tp.d; ans += cnt; cur += cnt * tp.d; if(!cnt) { int nxt = cur + tp.d - 1; if(nxt &lt;= r) q.push({b[j].l, nxt, nxt - b[j].l + 1}); cur = b[j].l; } } } printf(&quot;%d\n&quot;, ans); } return 0; }]]></content>
      <categories>
        <category>套题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Notes, A Byte of Python]]></title>
    <url>%2F2017%2F03%2F25%2FNotes%2C%20A%20Byte%20of%20Python%2F</url>
    <content type="text"><![CDATA[总结一下$python$的语法对于一个$cpp programmer$来说如何快速上手 工具查阅。。 基本类型数 整数(int) type(1) 长整数(long) type(1L) 浮点数(float) type(1.0) python不区分单双精度浮点数 复数(complex) type(2.3+5j) 字符串(str) ‘和”意思相同 &#39;hello&#39; &quot;hello&quot;&#39;&#39;&#39;或者&quot;&quot;&quot;多行引号 里面随便用’和” 会自动转义 自然字符串r或者R前缀 不会转义 r&quot;new line\n&quot; Unicode字符串u或者U前缀 u&quot;This is a unicode string&quot; Tips:字符串是不可变的正则表示式 一定要用自然字符串行连接: (下面两个等价) print\ i print i 变量 命名规则类似于C/C++或者Java 运算符 + - * / % &lt;&lt; &gt;&gt; &amp; | ^ ~ &lt; &gt; &lt;= &gt;= == != 不变 x**y ==&gt; $x^y$ //取整除 5//2.1=2.0 逻辑运算符 not and or 运算符优先级 运算符 描述 lambda lambda表达式 or 布尔“或” and 布尔“与” not x 布尔“非” in，not in 成员测试 is，is not 同一性测试 &lt;，&lt;=，&gt;，>=，!=，== 比较 &#124; 按位或 ^ 按位异或 &amp; 按位与 &lt;&lt;，&gt;&gt; 移位 +，- 加法与减法 *，/，% 乘法、除法与取余 +x，-x 正负号 ~x 按位翻转 ** 指数 x.attribute 属性参考 x[index] 下标 x[index:index] 寻址段 f(arguments…) 函数调用 (experession,…) 绑定或元组显示 [expression,…] 列表显示 {key:datum,…} 字典显示 `expression,…` 字符串转换 控制语句 (不要忘记:)else部分是可选的。如果包含else，它总是在循环结束后执行一次，除非遇到break if和while # !/usr/bin/python number = 23 running = True while running: guess=int(raw_input(&quot;Enter an integer:&quot;)) if guess == number: print(&quot;Congratulation, you guessd it.&quot;) running = False elif guess &lt; number: print(&quot;No, it is a little higher&quot;) else: print(&quot;No, it is a little lower&quot;) else: print(&quot;The while loop is over.&quot;) print(&quot;Done&quot;) for, break和continue for x in range(1, 10): if x == 2: continue if x == 4: break 函数 (不要忘记:) 实参传递方式类似Java, 值类型值传递，对象类型引用传递 def maximum(x, y): if x &gt; y: return x else: return y 默认参数 def printWord(word, times = 1): print(word * times) 关键参数 def func(a, b = 5, c = 10): print(&#39;a is %d, b is %d, c is %d&#39; % (a, b, c)) ##################################################### func(3, 7) func(25, c = 24) func(c = 50, a = 100) DocStrings文档字符串的惯例是一个多行字符串，它的首行以大写字母开始，句号结尾。第二行是空行，从第三行开始是详细的描述。 def printMax(x, y): &#39;&#39;&#39;Prints the maximum of two numbers. The two values must be integers.&#39;&#39;&#39; if x &gt; y: print x, &#39;is maximum&#39; else: print y, &#39;is maximum&#39; ########################################## printMax(3, 5) print printMax.__doc__ 模块每个.py程序都是1个模块(可以类似cpp类一样用.来访问模块内的成员) from..import语句 import sys print &#39;The command line arguments are:&#39; for i in sys.argv: print i print &#39;\n\nThe PYTHONPATH is&#39;, sys.path, &#39;\n&#39; 如果你想要直接输入argv变量到你的程序中（避免在每次使用它时打sys.），那么你可以使用from sys import argv语句。如果你想要输入所有sys模块使用的名字，那么你可以使用from sys import *语句。这对于所有模块都适用。一般说来，应该避免使用from..import而使用import语句，因为这样可以使你的程序更加易读，也可以避免名称的冲突。 使用模块的__name__ if __name__ == &#39;__main__&#39;: print &#39;This program is being run by itself&#39; else: print &#39;I am being imported from another module&#39; dir()函数可以使用内建的dir函数来列出模块定义的标识符。标识符有函数、类和变量。当你为dir()提供一个模块名的时候，它返回模块定义的名称列表。如果不提供参数，它返回当前模块中定义的名称列表。 &gt;&gt;&gt; import sys &gt;&gt;&gt; dir() # get list of attributes for current module [&#39;__builtins__&#39;, &#39;__doc__&#39;, &#39;__name__&#39;, &#39;sys&#39;] &gt;&gt;&gt; a = 5 # create a new variable &#39;a&#39; &gt;&gt;&gt; dir() [&#39;__builtins__&#39;, &#39;__doc__&#39;, &#39;__name__&#39;, &#39;a&#39;, &#39;sys&#39;] &gt;&gt;&gt; del a # delete/remove a name &gt;&gt;&gt; dir() [&#39;__builtins__&#39;, &#39;__doc__&#39;, &#39;__name__&#39;, &#39;sys&#39;] 数据结构列表list = [1, 2, 3] list.append(4) list.pop(0) # del list[0] list.sort() print(list) 元组empty = () single = (1, ) zoo = (&quot;wolf&quot;, &quot;elephant&quot;, &quot;penguin&quot;) print &quot;number of animals in the zoo is&quot;, len(zoo) # 3 new_zoo = (&quot;monkey&quot;, &quot;dolphin&quot;, zoo) print &quot;number of animals in the new zoo is&quot;, len(new_zoo) # 3 元组最通常的用法是用在打印语句 age = 22 name = &#39;Swaroop&#39; print &#39;%s is %d years old&#39; % (name, age) print &#39;Why is %s playing with that python?&#39; % name 字典只能使用不可变的对象（比如字符串）来作为字典的键，但是你可以把不可变或可变的对象作为字典的值。基本说来就是，你应该只使用简单的对象作为键。 ab = { &#39;Swaroop&#39; : &#39;swaroopch@byteofpython.info&#39;, &#39;Larry&#39; : &#39;larry@wall.org&#39;, &#39;Matsumoto&#39; : &#39;matz@ruby-lang.org&#39;, &#39;Spammer&#39; : &#39;spammer@hotmail.com&#39; } print &quot;Swaroop&#39;s address is %s&quot; % ab[&#39;Swaroop&#39;] 序列列表、元组和字符串都是序列，序列的两个主要特点是索引操作符和切片操作符。索引操作符让我们可以从序列中抓取一个特定项目。切片操作符让我们能够获取序列的一个切片，即一部分序列 shoplist = [&#39;apple&#39;, &#39;mango&#39;, &#39;carrot&#39;, &#39;banana&#39;] # Indexing or &#39;Subscription&#39; operation print &#39;Item 0 is&#39;, shoplist[0] print &#39;Item -1 is&#39;, shoplist[-1] # Slicing on a list print &#39;Item 1 to 3 is&#39;, shoplist[1:3] print &#39;Item 2 to end is&#39;, shoplist[2:] print &#39;Item 1 to -1 is&#39;, shoplist[1:-1] print &#39;Item start to end is&#39;, shoplist[:] # Slicing on a string name = &#39;swaroop&#39; print &#39;characters 1 to 3 is&#39;, name[1:3] print &#39;characters 2 to end is&#39;, name[2:] print &#39;characters 1 to -1 is&#39;, name[1:-1] print &#39;characters start to end is&#39;, name[:] ################################################# Item 0 is apple Item -1 is banana Item 1 to 3 is [&#39;mango&#39;, &#39;carrot&#39;] Item 2 to end is [&#39;carrot&#39;, &#39;banana&#39;] Item 1 to -1 is [&#39;mango&#39;, &#39;carrot&#39;] Item start to end is [&#39;apple&#39;, &#39;mango&#39;, &#39;carrot&#39;, &#39;banana&#39;] characters 1 to 3 is wa characters 2 to end is aroop characters 1 to -1 is waroo characters start to end is swaroop 引用当你创建一个对象并给它赋一个变量的时候，这个变量仅仅引用那个对象，而不是表示这个对象本身！也就是说，变量名指向你计算机中存储那个对象的内存。这被称作名称到对象的绑定。必须使用切片操作符来取得拷贝 类类的声明基本跟cpp差不多，类中定义的变量，类似于cpp中的类的静态成员变量(比如下中的population)如果你使用的数据成员名称以双下划线前缀比如__privatevar，Python的名称管理体系会有效地把它作为私有变量。一个惯例，如果某个变量只想在类或对象中使用，就应该以单下划线前缀。其他的名称都将作为公共的，可以被其他类/对象使用。记住这只是一个惯例，并不是Python所要求的（与双下划线前缀不同）。 class Person: &#39;&#39;&#39;Represents a person.&#39;&#39;&#39; population = 0 def __init__(self, name): &#39;&#39;&#39;Initializes the person&#39;s data.&#39;&#39;&#39; self.name = name print &#39;(Initializing %s)&#39; % self.name # When this person is created, he/she # adds to the population Person.population += 1 def __del__(self): &#39;&#39;&#39;I am dying.&#39;&#39;&#39; print &#39;%s says bye.&#39; % self.name Person.population -= 1 if Person.population == 0: print &#39;I am the last one.&#39; else: print &#39;There are still %d people left.&#39; % Person.population def sayHi(self): &#39;&#39;&#39;Greeting by the person. Really, that&#39;s all it does.&#39;&#39;&#39; print &#39;Hi, my name is %s.&#39; % self.name def howMany(self): &#39;&#39;&#39;Prints the current population.&#39;&#39;&#39; if Person.population == 1: print &#39;I am the only person here.&#39; else: print &#39;We have %d persons here.&#39; % Person.population ########################################### swaroop = Person(&#39;Swaroop&#39;) swaroop.sayHi() swaroop.howMany() kalam = Person(&#39;Abdul Kalam&#39;) kalam.sayHi() kalam.howMany() swaroop.sayHi() swaroop.howMany() ########################################### (Initializing Swaroop) Hi, my name is Swaroop. I am the only person here. (Initializing Abdul Kalam) Hi, my name is Abdul Kalam. We have 2 persons here. Hi, my name is Swaroop. We have 2 persons here. Abdul Kalam says bye. There are still 1 people left. Swaroop says bye. I am the last one. 类的继承Python不会自动调用基本类的constructor，你得亲自专门调用它 class SchoolMember: &#39;&#39;&#39;Represents any school member.&#39;&#39;&#39; def __init__(self, name, age): self.name = name self.age = age print &#39;(Initialized SchoolMember: %s)&#39; % self.name def tell(self): &#39;&#39;&#39;Tell my details.&#39;&#39;&#39; print &#39;Name:&quot;%s&quot; Age:&quot;%s&quot;&#39; % (self.name, self.age), class Teacher(SchoolMember): &#39;&#39;&#39;Represents a teacher.&#39;&#39;&#39; def __init__(self, name, age, salary): SchoolMember.__init__(self, name, age) self.salary = salary print &#39;(Initialized Teacher: %s)&#39; % self.name def tell(self): SchoolMember.tell(self) print &#39;Salary: &quot;%d&quot;&#39; % self.salary class Student(SchoolMember): &#39;&#39;&#39;Represents a student.&#39;&#39;&#39; def __init__(self, name, age, marks): SchoolMember.__init__(self, name, age) self.marks = marks print &#39;(Initialized Student: %s)&#39; % self.name def tell(self): SchoolMember.tell(self) print &#39;Marks: &quot;%d&quot;&#39; % self.marks ############################################################## t = Teacher(&#39;Mrs. Shrividya&#39;, 40, 30000) s = Student(&#39;Swaroop&#39;, 22, 75) print # prints a blank line members = [t, s] for member in members: member.tell() # works for both Teachers and Students ############################################################## (Initialized SchoolMember: Mrs. Shrividya) (Initialized Teacher: Mrs. Shrividya) (Initialized SchoolMember: Swaroop) (Initialized Student: Swaroop) Name:&quot;Mrs. Shrividya&quot; Age:&quot;40&quot; Salary: &quot;30000&quot; Name:&quot;Swaroop&quot; Age:&quot;22&quot; Marks: &quot;75&quot; I/O文件poem = &#39;&#39;&#39;\ Programming is fun When the work is done if you wanna make your work also fun: use Python! &#39;&#39;&#39; f = file(&#39;poem.txt&#39;, &#39;w&#39;) # open for &#39;w&#39;riting f.write(poem) # write text to file f.close() # close the file f = file(&#39;poem.txt&#39;) # if no mode is specified, &#39;r&#39;ead mode is assumed by default while True: line = f.readline() if len(line) == 0: # Zero length indicates EOF break print line, # Notice comma to avoid automatic newline added by Python f.close() # close the file 储存器Python提供一个标准的模块，称为pickle。使用它你可以在一个文件中储存何Python对象，之后你又可以把它完整无缺地取出来。这被称为 持久地 储存对象。还有另一个模块称为cPickle，它的功能和pickle模块完全相同，只不过它是C语言编写的，因此要快得多（比pickle快1000倍） import cPickle as p #import pickle as p shoplistfile = &#39;shoplist.data&#39; # the name of the file where we will store the object shoplist = [&#39;apple&#39;, &#39;mango&#39;, &#39;carrot&#39;] # Write to the file f = file(shoplistfile, &#39;w&#39;) p.dump(shoplist, f) # dump the object to a file f.close() del shoplist # remove the shoplist # Read back from the storage f = file(shoplistfile) storedlist = p.load(f) print storedlist 异常else可以和try…except连用，不能只与try…finally连用 #!/usr/bin/python # Filename: raising.py class ShortInputException(Exception): &#39;&#39;&#39;A user-defined exception class.&#39;&#39;&#39; def __init__(self, length, atleast): Exception.__init__(self) self.length = length self.atleast = atleast try: s = raw_input(&#39;Enter something --&gt; &#39;) if len(s) &lt; 3: raise ShortInputException(len(s), 3) # Other work can continue as usual here except EOFError: print &#39;\nWhy did you do an EOF on me?&#39; except ShortInputException, x: print &#39;ShortInputException: The input was of length %d, \ was expecting at least %d&#39; % (x.length, x.atleast) else: print &#39;No exception was raised.&#39; Python标准库sys模块 sys.argv列表中总是至少有一个项目。sys.argv[0]（由于Python从0开始计数）就是当前运行的程序名称。其他的命令行参数在这个项目之后。 sys.version字符串给你提供安装的Python的版本信息 sys.stdin、sys.stdout和sys.stderr分别对应程序的标准输入、标准输出和标准错误流。 os模块 os.name字符串指示你正在使用的平台。比如对于Windows，它是’nt’，而对于Linux/Unix用户，它是’posix’。 os.getcwd()函数得到当前工作目录，即当前Python脚本工作的目录路径。 os.getenv()和os.putenv()函数分别用来读取和设置环境变量。 os.listdir()返回指定目录下的所有文件和目录名。 os.remove()函数用来删除一个文件。 os.system()函数用来运行shell命令。 os.linesep字符串给出当前平台使用的行终止符。例如，Windows使用’\r\n’，Linux使用’\n’而Mac使用’\r’。 os.path.split()函数返回一个路径的目录名和文件名。&gt;&gt;&gt; os.path.split(&#39;/home/swaroop/byte/code/poem.txt&#39;) (&#39;/home/swaroop/byte/code&#39;, &#39;poem.txt&#39;) os.path.isfile()和os.path.isdir()函数分别检验给出的路径是一个文件还是目录 os.path.exists()函数用来检验给出的路径是否真地存在 更多关于Python列表综合（List Comprehension）#!/usr/bin/python listone = [2, 3, 4] listtwo = [2*i for i in listone if i &gt; 2] print listtwo 在函数中接收元组和列表在args变量前有*前缀，多余的函数参数都会作为一个元组存储在args中如果使用的是**前缀，多余的参数则会被认为是一个字典的键/值对 &gt;&gt;&gt; def powersum(power, *args): ... &#39;&#39;&#39;Return the sum of each argument raised to specified power.&#39;&#39;&#39; ... total = 0 ... for i in args: ... total += pow(i, power) ... return total ... &gt;&gt;&gt; powersum(2, 3, 4) 25 &gt;&gt;&gt; dict = {} &gt;&gt;&gt; print dict {} &gt;&gt;&gt; def addKVs(**args): ... for key in args.keys(): ... dict[key] = args[key] ... &gt;&gt;&gt; addKVs(a=1,b=2) &gt;&gt;&gt; print dict {&#39;a&#39;: 1, &#39;b&#39;: 2} lambda expression语法：lambda [arg1[,arg2,arg3....argN]]:expression注意：只能使用表达式，即便是print语句也不能用在lambda形式中for..in..if能做的，最好不要选择lambda fuck = lambda : &#39;hello world&#39; print fuck() addition = lambda a, b : a + b print addition(1, 2) ########################### hello world 3 exec、eval、assert、repr exec语句用来执行储存在字符串或文件中的Python语句&gt;&gt;&gt; exec &#39;print &quot;Hello World&quot;&#39; Hello World eval语句用来计算存储在字符串中的有效Python表达式&gt;&gt;&gt; eval(&#39;2*3&#39;) 6 assert语句用来声明某个条件是真的&gt;&gt;&gt; mylist = [&#39;item&#39;] &gt;&gt;&gt; assert len(mylist) &gt;= 1 &gt;&gt;&gt; mylist.pop() &#39;item&#39; &gt;&gt;&gt; assert len(mylist) &gt;= 1 Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ? AssertionError repr函数和反引号（也称转换符）用来获取对象的可打印表示形式注意，在大多数时候有eval(repr(object)) == object可通过定义类的__repr__方法来控制对象被repr函数调用时返回的内容 &gt;&gt;&gt; i = [] &gt;&gt;&gt; i.append(&#39;item&#39;) &gt;&gt;&gt; `i` &quot;[&#39;item&#39;]&quot; &gt;&gt;&gt; repr(i) &quot;[&#39;item&#39;]&quot;]]></content>
      <categories>
        <category>Doing</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Coursera, Machine Learning]]></title>
    <url>%2F2017%2F03%2F07%2FCoursera%20Machine%20Learning%2F</url>
    <content type="text"><![CDATA[前言总算是开始学习$ML$了，这个$Stanford$的课看了一下$Materials$发现被精简了好多啊好处是通俗易懂，入门必备啊。。真是适合我这种数学渣 笔记和编程作业答案这里丢一波地址，毕竟博客的$md$对$Latex$的兹磁其实是一般的还是作业部落比较好用，主要是博客还得$push$吧，笔记应该是随心写的那种所以酱紫比较好 My Notes My Exercises Updated 完成了 现在是2017年3月12日 03:35:01，历时7天整，最终以$99.2\%$的成绩通过了 基本都是一次通过，拿满可能做了$2\sim 3$次 除了Anomaly Detection和Recommender Systems各错了一个，前者做了$6$遍还是没拿满，我!@#$%^&amp; 看到这个绿图还是很欣慰啊，就跟你大半夜日题看到$AC$一样的，勉强入门了？？ 后记 加油加油，我发现我还是爱学习的？ 爱数学？(雾 接下来可以玩一玩平台，工具啥的了 具体数学推导深入啥的，玩的过程中学可能更有效一点的 好像摆脱颓废的状态了，果然是忙起来就好了。。 感觉有空还是要把$cs229$的$lecture notes$看一看的，读了第一个感觉非常好啊 然后跟着他们一起学一学$DL$？ 再上一波$cs231n$了估计要]]></content>
      <categories>
        <category>Doing</category>
        <category>Machine Learning</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Reborn and Walk Alone]]></title>
    <url>%2F2017%2F02%2F28%2FRoborn-and-Walk-Alone%2F</url>
    <content type="text"><![CDATA[前言时光太瘦，指缝太宽，不经意的一瞥，已隔经年 ——安意如作为一个记忆是有限覆盖式的人（摊手），我大概已经不太记得这个人生$2\sim 3$年往前的事情了，不知是幸运还是悲哀。四年太快，马上就要毕业了，最近又传来噩耗，能不能毕业都不一定了，自作孽真是的。无数次幻想如果没有得到想要的结果就退役了是怎么样的，正儿八经儿从坎普回来发现其实也没啥区别。仿佛我的力气早已经在一年前透支了，突然找不回从前努力的那个自己了，这个样子不行啊，每天浑浑噩噩的。明天就是三月了，即使是在最后一秒回头也是不晚的，毕竟不是生死，真希望自己踽踽独行，踌躇满志。 莫名其妙的终于下了决定讲道理，迷茫的时候$salary-oriented$是很兹磁的啊，所谓技多不压身，学一波都是挺好玩的$ML、CV$什么的，周围学的人都已经建立正反馈了，而我还没找到正反馈，不过我想应该不难其他方向的孩子们早都深入了，观望真是一件最愚蠢的事情，开始做什么的才是硬道理啊 博客重新搞了搞以前黑灰的实在是看着好压抑啊，然后又去把landscape原版拿来搞一搞，借鉴了一下别人的发现自己实在是缺乏美(前端)的眼睛(skill)，也就只有$xjb$修一修$bug$，然后再随便调一调配色这种水平看起来勉强是能看了，终于把taosama.com买下来了，然后又可以重新愉快的写博客了？？？ 然后就开始重新写博客了？把东西整理一下，然后又可以随便刷刷题，打打$cf$，学学东西实习学的东西也可以整理一波。。然后就正儿八经儿的开始学习了？毕竟三月了，新的开始。。 后记好好学习，好好打游戏。。好好看视频。。别特么胡思乱想。。]]></content>
      <categories>
        <category>Doing</category>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[VS2013 + opencv2.4.8 环境搭建]]></title>
    <url>%2F2016%2F11%2F01%2Fset-up-environment-of-vs2013-with-opencv248%2F</url>
    <content type="text"><![CDATA[前言第一天来实习呀，宇哥让我搭建一波环境，来之前搞过一波$win+qt$的，过来发现这边并不是玩$linux$而是$win10+vs$的节奏，然后我就知道要开始开(踩)心(坑)之旅了 开始搭建环境工具下载 $vs 2013 ultimate$安装，可以去MSDN, I tell you下载 $cmake$，直接官网下载就好了，最新版本就好 $opencv 2.4.8$，直接去官网下载源码就好 编译 $cmake gui$选择$opencv$源码根目录，再选择一个输出目录编译静态库就不打勾这2个， BUILD_SHARED_LIBS，BUILD_WITH_STATIC_CRTQT 方案就 WITH_OPENGL 和 WITH_QT 勾一下 点击$configure$，选择$Visual Studio 12 2013$就好，编译器就默认就行 $configure$完之后点击$generate$，之后$open project$ 打开$OpenCV$工程之后，分别在$Debug$和$Release$模式下，$CMakeTargets$下$ALL_BUILD$和$INSTALL$先后构建一下 依赖 新建一个控制台工程，选择空项目，新建 main.cpp，找一段官网代码 #include &lt;opencv2/highgui/highgui.hpp&gt; #include &lt;iostream&gt; using namespace cv; using namespace std; int main(int argc, char** argv) { if (argc != 2) { cout &lt;&lt; &quot; Usage: display_image ImageToLoadAndDisplay&quot; &lt;&lt; endl; return -1; } Mat image; image = imread(argv[1], IMREAD_COLOR); // Read the file if (!image.data) // Check for invalid input { cout &lt;&lt; &quot;Could not open or find the image&quot; &lt;&lt; std::endl; return -1; } namedWindow(&quot;Display window&quot;, WINDOW_AUTOSIZE); // Create a window for display. imshow(&quot;Display window&quot;, image); // Show our image inside it. waitKey(0); // Wait for a keystroke in the window return 0; } 有了上面这个 打开的工程就可以为所有工程添加依赖了 $View\to Property Manager\to 工程名字\to Debug | Win32\to Microsoft.Cpp.Win32.user$上面这个位置找到之后，就可以添加包含目录和库目录了 $Common Properties\to VC++ Directories$包含目录，编译后目录下的 ...\install\include，...\install\include\opencv，...\install\include\opencv2三个目录添加就好库目录，静态库，编译后目录下的 ...\install\x86\vc12\staticlib可执行文件目录，直接添加到环境变量里去，...\install\x86\vc12\bin $Linker\to Input$库文件依赖，静态库依赖，库目录里的全部塞进去就行，$Debug$就添加 *d.lib版本的，$Release$添加 *.lib版本的 opencv_core248d.lib opencv_imgproc248d.lib opencv_highgui248d.lib opencv_ml248d.lib opencv_video248d.lib opencv_features2d248d.lib opencv_calib3d248d.lib opencv_objdetect248d.lib opencv_contrib248d.lib opencv_legacy248d.lib opencv_flann248d.lib libpngd.lib libtiffd.lib zlibd.lib IlmImfd.lib libjasperd.lib libjpegd.lib 各种坑点 静态库需要注意，highgui会需要下面这一堆。。。。库文件依赖里加一下（大坑） 参考1，参考2 comctl32.lib vfw32.lib user32.lib gdi32.lib winmm.lib uuid.lib winspool.lib wsock32.lib rpcrt4.lib odbc32.lib oleaut32.lib advapi32.lib comdlg32.lib ole32.lib error LNK2038: 检测到“RuntimeLibrary”的不匹配项: 值“MTd_StaticDebug”不匹配值“MDd_DynamicDebug”解决方案：$在工程上右键\to 属性\to C/C++\to 代码生成\to 运行库$有四个选项及含义分别如下：多线程调试Dll (/MDd) 对应的是MD_DynamicDebug多线程Dll (/MD) 对应的是MD_DynamicRelease多线程(/MT) 对应的是MD_StaticRelease多线程(/MTd)对应的是MD_StaticDebug根据错误提示修改即可 后记$windows$有毒，$vs$有毒。。]]></content>
      <categories>
        <category>Doing</category>
        <category>Computer Vision</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[51nod 1610 路径计数（dp、容斥）]]></title>
    <url>%2F2016%2F09%2F23%2F51nod%201610%20%E8%B7%AF%E5%BE%84%E8%AE%A1%E6%95%B0%EF%BC%88dp%E3%80%81%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $给定一个N\le 100点，M\le 5\times 10^4边的有向无环图$$一条路径的值:=路径上所有边权的最大公约数$$Q\le 500次修改操作，每次修改一条边的边权\le 100$$每次修改后输出有向无环图上路径的值为1的路径数量，答案模10^9+7$ 分析： $修改1条边所能影响的是他的约数那些边，看数据发现每次询问最多只兹磁O(n^2)$$暴力做是不行的，考虑对倍数容斥一下$$f[div][i][j]:=值为div倍数的i\to j的方法数$$根据拓扑序dp一下就得到dp[div][i]:=以i结尾的值为div倍数的方法数$$g[i]:=值为i的倍数的方法数，h[i]:=值为i的方法数，这个容斥一下就好了$$对于每次修改显然只影响约数那些，拿出来暴力重新dp，再容斥算答案就好了$$本题约数级别是sqrt(100)也就是10，所以复杂度是O(100\times n^2+q\times 10\times 100^2)$ 代码： // // Created by TaoSama on 2016-08-29 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;stdio.h&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 100 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; const int M = 5e4 + 10; typedef long long LL; int n, m; LL f[N][N][N], g[N], h[N]; //x倍数的i-&gt;j的路径数, x的倍数的路径数, x的路径数 int u[M], v[M], c[M]; vector&lt;int&gt; G[N], topo; vector&lt;int&gt; divisors[N]; void gao() { for(int i = 1; i &lt; N; ++i) for(int j = i; j &lt; N; j += i) divisors[j].push_back(i); } #define rep(i, a, b) for(int i = a; i &lt;= b; ++i) LL calc(int div) { LL sum = 0; vector&lt;LL&gt; dp(n + 1, 0); for(int i = 0; i &lt; topo.size(); ++i) { int u = topo[i]; sum = (sum + dp[u]) % MOD; for(int j = i + 1; j &lt; topo.size(); ++j) { int v = topo[j]; dp[v] += f[div][u][v] * (1 + dp[u]); dp[v] %= MOD; } } return sum; } LL solve() { for(int i = 100; i; --i) { h[i] = g[i]; for(int j = i + i; j &lt;= 100; j += i) h[i] -= h[j]; h[i] = (h[i] % MOD + MOD) % MOD; } return h[1]; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); gao(); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); vector&lt;int&gt; in(n + 1, 0); for(int i = 1; i &lt;= m; ++i) { scanf(&quot;%d%d%d&quot;, u + i, v + i, c + i); G[u[i]].push_back(v[i]); ++in[v[i]]; for(int div : divisors[c[i]]) ++f[div][u[i]][v[i]]; } for(int i = 1; i &lt;= n; ++i) if(!in[i]) topo.push_back(i); for(int i = 0; i &lt; topo.size(); ++i) { int u = topo[i]; for(int v : G[u]) if(--in[v] == 0) topo.push_back(v); } for(int i = 1; i &lt;= 100; ++i) g[i] = calc(i); printf(&quot;%lld\n&quot;, solve()); int q; scanf(&quot;%d&quot;, &amp;q); while(q--) { int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); vector&lt;int&gt; affected; for(int div : divisors[c[x]]) { --f[div][u[x]][v[x]]; affected.push_back(div); } c[x] = y; for(int div : divisors[c[x]]) { ++f[div][u[x]][v[x]]; affected.push_back(div); } sort(affected.begin(), affected.end()); affected.resize(unique(affected.begin(), affected.end()) - affected.begin()); for(int div : affected) g[div] = calc(div); printf(&quot;%lld\n&quot;, solve()); } return 0; }]]></content>
      <categories>
        <category>数学</category>
        <category>容斥</category>
      </categories>
      <tags>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSU 1805 Three Capitals（BEST定理、MatrixTree定理）]]></title>
    <url>%2F2016%2F09%2F22%2FCSU%201805%20Three%20Capitals%EF%BC%88BEST%E5%AE%9A%E7%90%86%E3%80%81MatrixTree%E5%AE%9A%E7%90%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $给定无向图3个点A、B、G，AB间有a条边，AG间有b条边，BG间有c条边$$求从A出发回到A的欧拉回路的个数，答案模10^9+7$ 分析： $叉姐给出1个有向图欧拉回路计数的定理$$有向图欧拉回路的话，判定条件：连通，每个点入度=出度$$有向图欧拉回路计数(BSET Theorem)：$$ec(G)=t_s(G)\cdot deg(s)! \cdot \prod_{v\in V, v\ne s} (deg(v)-1)!, t_s(G):=以s为根的外向树的个数$$注意特判1个点答案是1$$生成树计数(Kirchhoff Theorem)：$$基尔霍夫矩阵K=度数矩阵D-邻接矩阵A$$重边：按照边数计算，自环：不计入度数$$无向图生成树计数：c=|K的任意1个n-1阶主子式|$$有向图外向树计数：c=|去掉根所在的那阶得到的主子式|$ $以上是学习内容，这个题只要枚举一条边的其中1个方向的边数$$然后根据欧拉回路判定性条件解出其他边的2个方向的边数$$然后直接套定理解出个数，注意选边的时候要乘组合数$$然后这个题就做完了，时间复杂度O(n)$ $代码：$ // // Created by TaoSama on 2016-09-07 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; typedef long long LL; LL a[N][N], ans[N]; bool isFreeX[N]; LL gauss(int n, int m) { for(int i = 0; i &lt; m; ++i) isFreeX[i] = false; LL ret = 1, neg = 0; int r = 1, c = 1; for(; r &lt; n &amp;&amp; c &lt; m; ++r, ++c) { int p = r; for(; p &lt; n; ++p) if(a[p][c]) break; if(p == n) {--r; isFreeX[c] = true; continue;} if(p != r) { neg ^= 1; for(int i = c; i &lt;= m; ++i) swap(a[p][i], a[r][i]); } //eliminate coefficient for(int i = r + 1; i &lt; n; ++i) { while(a[i][c]) { LL delta = a[i][c] / a[r][c]; for(int j = c; j &lt;= m; ++j) { a[i][j] += MOD - delta * a[r][j] % MOD; a[i][j] %= MOD; } if(!a[i][c]) break; neg ^= 1; for(int j = c; j &lt;= m; ++j) swap(a[r][j], a[i][j]); } } } if(r != n) return 0; for(int i = 1; i &lt; r; ++i) ret = ret * a[i][i] % MOD; if(neg) ret = (-ret + MOD) % MOD; return ret; } int A, B, C; int deg[N]; bool check(int&amp; x, int A) { if(x &amp; 1) return false; x /= 2; return x &gt;= 0 &amp;&amp; x &lt;= A; } const int M = 1e5 + 10; LL fact[M], finv[M]; LL quick(LL x, LL n) { LL ret = 1; for(; n; n &gt;&gt;= 1) { if(n &amp; 1) ret = ret * x % MOD; x = x * x % MOD; } return ret; } LL comb(int n, int m) { if(n &lt; m) return 0; return fact[n] * finv[m] % MOD * finv[n - m] % MOD; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); fact[0] = finv[0] = 1; for(int i = 1; i &lt; M; ++i) { fact[i] = fact[i - 1] * i % MOD; finv[i] = quick(fact[i], MOD - 2); } while(scanf(&quot;%d%d%d&quot;, &amp;A, &amp;B, &amp;C) == 3) { LL ans = 0; for(int x = 0; x &lt;= A; ++x) { //x in-degrees from A; y from C, z from B int y = 2 * x + C - A; if(!check(y, C)) continue; int z = 2 * y + B - C; if(!check(z, B)) continue; if(x + B - z != A - x + z) continue; //check A deg[0] = x + B - z; deg[1] = y + A - x; deg[2] = z + C - y; for(int i = 0; i &lt; 3; ++i) a[i][i] = deg[i]; a[0][1] = -(A - x); a[0][2] = -z; a[1][0] = -x; a[1][2] = -(C - y); a[2][0] = -(B - z); a[2][1] = -y; LL cur = comb(A, x) * comb(C, y) % MOD * comb(B, z) % MOD; //BEST Theorem cur = cur * gauss(3, 3) % MOD; cur = cur * deg[0] % MOD; for(int i = 0; i &lt; 3; ++i) cur = cur * fact[deg[i] - 1] % MOD; ans = (ans + cur) % MOD; } printf(&quot;%lld\n&quot;, ans); } return 0; }]]></content>
      <categories>
        <category>图论</category>
        <category>生成树计数</category>
      </categories>
      <tags>
        <tag>生成树计数</tag>
        <tag>有向图欧拉回路计数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IFrog 1032 - A-B（容斥）]]></title>
    <url>%2F2016%2F09%2F22%2FIFrog%201032%20-%20A-B%EF%BC%88%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $n\le 500个球，需要把他们放到m\le 500个盒子里，盒子不同，可以为空$$要求拥有最多球的盒子唯一，问方案数，答案模998244353$ 分析： $容斥原理套路题，枚举最多球的个数x，令事件A_i:=i号盒子\ge x的解的方法数$$显然E_x=$$所以容斥一波就好了，注意这里是有序的，所以容斥的时候要乘C(m-1, i)$$因为选出1个盒子放最大的，最后插到m-1个盒子里有m种可能$$对于n个球放进m个不同的盒子可以为空用隔板法来求，即calc(n, m)=C(n+m-1, m-1)$$ans=m\sum_{x} E_x =m\sum_{x}\sum_{i=0}^{m-1} (-1)^i \cdot C(m-1, i) \cdot calc(m-1-x-i\times x, m-1)$$阶乘预处理一下组合数，时间复杂度O(nm)$ $代码：$ // // Created by TaoSama on 2016-09-22 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 500 + 10, INF = 0x3f3f3f3f, MOD = 998244353; int n, m; typedef long long LL; LL quick(LL x, LL n) { LL ret = 1; for(; n; n &gt;&gt;= 1) { if(n &amp; 1) ret = ret * x % MOD; x = x * x % MOD; } return ret; } LL fact[N], invf[N]; LL C(int n, int m) { if(n &lt; m) return 0; return fact[n] * invf[m] % MOD * invf[n - m] % MOD; } LL calc(int n, int m) { return C(n + m - 1, m - 1); } LL solve(int lft, int x, int m) { LL ret = 0; for(int i = 0; i &lt;= m; ++i) { if(lft - i * x &lt; 0) continue; if(i &amp; 1) ret -= C(m, i) * calc(lft - i * x, m) % MOD; else ret += C(m, i) * calc(lft - i * x, m) % MOD; ret %= MOD; } return (ret + MOD) % MOD; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); fact[0] = invf[0] = 1; for(int i = 1; i &lt; N; ++i) { fact[i] = fact[i - 1] * i % MOD; invf[i] = quick(fact[i], MOD - 2); } while(cin &gt;&gt; n &gt;&gt; m) { if(m == 1) {cout &lt;&lt; &quot;1\n&quot;; continue;} LL ans = 0; for(int i = n / m + 1; i &lt;= n; ++i) { ans += solve(n - i, i, m - 1); } ans = ans * m % MOD; cout &lt;&lt; ans &lt;&lt; endl; } return 0; }]]></content>
      <categories>
        <category>数学</category>
        <category>容斥</category>
      </categories>
      <tags>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 451E. Devu and Flowers（容斥）]]></title>
    <url>%2F2016%2F09%2F21%2FCodeforces%20451E.%20Devu%20and%20Flowers%EF%BC%88%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $求x_1+x_2+…+x_n\le s, x_1\le f1, x_2\le f_2,…,x_n\le f_n的方法数，答案模10^9 + 7$$n\le 20, f_i\le 10^{12}, s\le 10^{14}$ 分析： $容斥原理套路题，令事件A_i:=至少x_i&gt;f_i的解的方法数$$显然ans=$$所以容斥一波就好了，计算每个的时候，先把超过的部分减掉，剩下的就转化成了$$left个物品装进n个盒子，盒子可以为空的问题，这个用隔板法就可以了$$大组合数取模用lucas，组合数由于1个很小，直接暴力就可以了$ $代码：$ // // Created by TaoSama on 2016-09-17 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; typedef long long LL; LL quick(LL x, LL n) { LL ret = 1; for(; n; n &gt;&gt;= 1) { if(n &amp; 1) ret = ret * x % MOD; x = x * x % MOD; } return ret; } LL C(LL n, LL m) { if(n &lt; m) return 0; m = min(m, n - m); LL up = 1, dw = 1; for(int i = 0; i &lt; m; ++i) { up = up * (n - i) % MOD; dw = dw * (i + 1) % MOD; } return up * quick(dw, MOD - 2) % MOD; } LL lucas(LL n, LL m) { if(m == 0) return 1; return C(n % MOD, m % MOD) * lucas(n / MOD, m / MOD) % MOD; } LL calc(LL n, LL m) { return lucas(n + m - 1, m - 1); } int n; LL s, f[N]; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); while(cin &gt;&gt; n &gt;&gt; s) { for(int i = 0; i &lt; n; ++i) cin &gt;&gt; f[i]; LL ans = 0; for(int i = 0; i &lt; 1 &lt;&lt; n; ++i) { LL lft = s, cnt = 0; for(int j = 0; j &lt; n; ++j) { if(i &gt;&gt; j &amp; 1) { lft -= f[j] + 1; ++cnt; } } if(lft &lt; 0) continue; if(cnt &amp; 1) ans -= calc(lft, n); else ans += calc(lft, n); ans %= MOD; } ans = (ans + MOD) % MOD; cout &lt;&lt; ans &lt;&lt; endl; } return 0; }]]></content>
      <categories>
        <category>数学</category>
        <category>容斥</category>
      </categories>
      <tags>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 662C. Binary Table（FWT）]]></title>
    <url>%2F2016%2F09%2F21%2FCodeforces%20662C%20C.%20Binary%20Table%EF%BC%88FWT%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $给定N\times M的01矩阵，N\le 20，M\le 10^5，每次可以选择flip一行或者一列$$求最后最少能有几个1$ 分析： $显然每行每列的决定都是翻还是不翻，所以一个很暴力的想法就是二进制枚举其中1个$$我们得到了一个O(2^nm)的暴力做法，我们来表示一下这个做法$$f[msk]=\sum_{i=1}^m min(Ones_{col_i \oplus msk}, n - Ones_{col_i \oplus msk} ), msk \in [0, 2^n)$$事实上我们其实并不关心每个col_i \oplus msk是多少，只关心这些值有哪些，各有多少个$$换句话说(其实就是往fwt凑)，令cnt_k为col_i=k的i有多少，式子变一下$$f[msk]=\sum_{k \in [0, 2^n) }cnt_k\times min(Ones_{msk\oplus k}, n-Ones_{msk\oplus k})，然后这很卷积。。$$然后就做完了，时间复杂度O(n 2^n)$ $代码：$ // // Created by TaoSama on 2016-09-21 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; typedef long long LL; void fwtXor(LL* a, int len) { if(len == 1) return; int h = len &gt;&gt; 1; fwtXor(a, h); fwtXor(a + h, h); for(int i = 0; i &lt; h; ++i) { LL x1 = a[i]; LL x2 = a[i + h]; a[i] = (x1 + x2); a[i + h] = (x1 - x2); } } void ifwtXor(LL* a, int len) { if(len == 1) return; int h = len &gt;&gt; 1; for(int i = 0; i &lt; h; ++i) { // y1=x1+x2 // y2=x1-x2 LL y1 = a[i]; LL y2 = a[i + h]; a[i] = (y1 + y2) / 2; a[i + h] = (y1 - y2) / 2; } ifwtXor(a, h); ifwtXor(a + h, h); } const int C = 1 &lt;&lt; 20; int n, m, a[N]; char buf[N]; LL cnt[C], f[C]; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 0; i &lt; n; ++i) { scanf(&quot;%s&quot;, buf); for(int j = 0; j &lt; m; ++j) a[j] |= (buf[j] - &#39;0&#39;) &lt;&lt; i; } for(int i = 0; i &lt; m; ++i) ++cnt[a[i]]; for(int i = 0; i &lt; 1 &lt;&lt; n; ++i) { int b = __builtin_popcount(i); f[i] = min(b, n - b); } fwtXor(cnt, 1 &lt;&lt; n); fwtXor(f, 1 &lt;&lt; n); for(int i = 0; i &lt; C; ++i) f[i] *= cnt[i]; ifwtXor(f, 1 &lt;&lt; n); LL ans = INF; for(int i = 0; i &lt; 1 &lt;&lt; n; ++i) ans = min(ans, f[i]); printf(&quot;%I64d\n&quot;, ans); return 0; }]]></content>
      <categories>
        <category>数学</category>
        <category>FFT/NTT/FWT</category>
      </categories>
      <tags>
        <tag>FWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FWT小结]]></title>
    <url>%2F2016%2F09%2F10%2FFWT%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Ⅰ. 快速沃尔什变换认知 这东西英文名叫$Fast Walsh$-$Hadamard Transform$ $FWT$是用来快速计算位运算卷积的，至于什么是卷积，可以先学习一下$FFT$ FFT小结，点击链接 既然提到了位运算，必然要和子集扯上关系，也就是说可以来求子集卷积 Ⅱ. 快速沃尔什变换形式 类似于$FFT$的卷积形式，假设$\otimes$为卷积符号，对于$2$个等长的系数向量$\overrightarrow{a}$和$\overrightarrow{b}$ 对于它们的卷积$\overrightarrow{c}=\overrightarrow{a}⊗\overrightarrow{b}$，有$C_k= \displaystyle \sum_{i\otimes j=k} A_i \times B_j$ 其实当$\otimes$为$+$的时候，就是普通的卷积形式了 计算 假设$2$个向量长度都是$n$，那么暴力计算位运算卷积是$O(n^2)$的 变换 类比$FFT$，假设我们知道一种类似于$DFT$的变换$tf$，可以使向量$X$产生一个新向量$tf(X)$ 以及类似于$IDFT$的变换$utf$，能使得$utf(tf(X))=X$ 并且变换$tf$必须具有这样的性质：$tf(X\otimes Y)=tf(X)\times tf(Y)$ 分治 类比$FFT$，我们考虑分治，接下来为了方便，我们令$\otimes$为$xor$运算，即$\oplus$ 令$Z=X\otimes Y$ 考虑$X$和$Y$都只有$1$个元素的时候，此时不需要变换，显然有$Z_{0\oplus 0=0}=X_0 \times Y_0$，即满足$tf(X)=X=utf(X)$ 考虑各有$2$个元素的时候，令$X=(a, b), Y=(c, d)$，此时$Z$$Z_0=ac+bd, Z_1=ad+bc$，即$(a, b)\otimes (c, d)=(ac + bd, ad + bc)$ 令$tf(a, b) = (a - b, a + b)$那么$tf(a, b) \times tf(c, d)$$= (a - b, a + b) \times (c - d, c + d)$$= ( (a-b)\times(c-d) , (a+b)\times(c+d) )$$= ( ac - ad - bc + bd, ac + ad + bc + bd )$$ = ( ac + bd - ad - bc, ac + bd + ad + bc )$$= tf( ac + bd, ad + bc )$$ = tf( (a,b) \otimes (c,d ) )$ 显然我们可以发现，对于偶数长度的向量，均分成$2$个向量都满足这个性质 当然也可以用数学归纳法证一波，具体去看Reference里的证明吧 之后我们就可以利用这个性质来递归的变换 令$X$是个偶数长度的向量，且$X=(X1, X2)$，$X1$和$X2$各是$X$的一半 那么有$tf(X1, X2) = (tf(X1) - tf(X2), tf(X1) + tf(X2))$ 具体就是先递归变换$2$个等长的子序列，$X1$和$X2$都递归变换过了，那么新的$X1=X1-X2$，同理新的$X2=X1+X2$ 当然逆变换$utf$也很好构造，只需要反向回去就好了，每次解一下方程 令$Y1 = tf(X1) - tf(X2), Y2 = tf(X1) + tf(X2)$，现在$Y1$和$Y2$已知，解出$tf(X1)$和$tf(X2)$即可 三种位运算变换总结 $tfxor(A)=(tfxor(A_0+A_1), tfxor(A_0−A_1))$$utfxor(A)=(utfxor( (A_0+A_1)/2), utfxor( (A_0−A_1)/2))$ $tfand(A)=(tfand(A_0+A_1), tfand(A_1))$$utfand(A)=(utfand(A_0−A_1), utfand(A_1))$ $tfor(A)=(tfor(A_0), tfor(A_1+A_0))$$utfor(A)=(utfor(A_0), utfor(A_1−A_0))$ 时间复杂度与写法 时间复杂度$T(n) = 2T(n/2)+O(n)$，根据主定理为$O(nlogn)$ 写法就跟$FFT$类似了，先把长度扩展到$2$的幂次，之后按照前面说的分治就好了 具体可以参照下面的板子题 位运算卷积与子集卷积 我没有太深的理解，基本的理解就是，其实它们是共通的 把数看成二进制下的子集，那么 &amp; 便是集合交，| 是集合并，^ 是集合对称差 所以很多时候题目可以从这$2$个角度都能说通，也提供了另一个思维方向 Ⅲ. 题目选讲IForg 1028 Bob and Alice are playing numbers分析：板子题，$n$个数里选$2$个数进行三种位运算的最大值数的大小只有$10^6$，$cnt[i]:=i$这个数出现了多少次然后卷积一下自己，减去自己和自己的，倒着枚举找到最大的那个就做完了 代码: // // Created by TaoSama on 2016-09-09 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; typedef long long LL; LL quick(LL x, LL n) { LL ret = 1; for(; n; n &gt;&gt;= 1) { if(n &amp; 1) ret = ret * x % MOD; x = x * x % MOD; } return ret; } const LL invTwo = quick(2, MOD - 2); void fwtXor(LL* a, int len) { if(len == 1) return; int h = len &gt;&gt; 1; fwtXor(a, h); fwtXor(a + h, h); for(int i = 0; i &lt; h; ++i) { LL x1 = a[i]; LL x2 = a[i + h]; a[i] = (x1 + x2) % MOD; a[i + h] = (x1 - x2 + MOD) % MOD; } } void ifwtXor(LL* a, int len) { if(len == 1) return; int h = len &gt;&gt; 1; for(int i = 0; i &lt; h; ++i) { // y1=x1+x2 // y2=x1-x2 LL y1 = a[i]; LL y2 = a[i + h]; a[i] = (y1 + y2) * invTwo % MOD; a[i + h] = (y1 - y2 + MOD) * invTwo % MOD; } ifwtXor(a, h); ifwtXor(a + h, h); } void fwtAnd(LL* a, int len) { if(len == 1) return; int h = len &gt;&gt; 1; fwtAnd(a, h); fwtAnd(a + h, h); for(int i = 0; i &lt; h; ++i) { LL x1 = a[i]; LL x2 = a[i + h]; a[i] = (x1 + x2) % MOD; a[i + h] = x2; } } void ifwtAnd(LL* a, int len) { if(len == 1) return; int h = len &gt;&gt; 1; for(int i = 0; i &lt; h; ++i) { // y1=x1+x2 // y2=x2 LL y1 = a[i]; LL y2 = a[i + h]; a[i] = (y1 - y2 + MOD) % MOD; a[i + h] = y2; } ifwtAnd(a, h); ifwtAnd(a + h, h); } void fwtOr(LL* a, int len) { if(len == 1) return; int h = len &gt;&gt; 1; fwtOr(a, h); fwtOr(a + h, h); for(int i = 0; i &lt; h; ++i) { LL x1 = a[i]; LL x2 = a[i + h]; a[i] = x1; a[i + h] = (x2 + x1) % MOD; } } void ifwtOr(LL* a, int len) { if(len == 1) return; int h = len &gt;&gt; 1; for(int i = 0; i &lt; h; ++i) { // y1=x1 // y2=x2+x1 LL y1 = a[i]; LL y2 = a[i + h]; a[i] = y1; a[i + h] = (y2 - y1 + MOD) % MOD; } ifwtOr(a, h); ifwtOr(a + h, h); } int n, op; const int C = 1 &lt;&lt; 20; LL a[N], cnt[C + 10]; int gao() { for(int i = C; ~i; --i) if(cnt[i]) return i; return -1; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%d%d&quot;, &amp;n, &amp;op); memset(cnt, 0, sizeof cnt); for(int i = 1; i &lt;= n; ++i) { scanf(&quot;%lld&quot;, a + i); ++cnt[a[i]]; } static int kase = 0; printf(&quot;Case #%d: &quot;, ++kase); if(op == 1) { fwtAnd(cnt, C); for(int i = 0; i &lt; C; ++i) cnt[i] = cnt[i] * cnt[i] % MOD; ifwtAnd(cnt, C); for(int i = 1; i &lt;= n; ++i) --cnt[a[i] &amp; a[i]]; printf(&quot;%d\n&quot;, gao()); } else if(op == 2) { fwtXor(cnt, C); for(int i = 0; i &lt; C; ++i) cnt[i] = cnt[i] * cnt[i] % MOD; ifwtXor(cnt, C); for(int i = 1; i &lt;= n; ++i) --cnt[a[i] ^ a[i]]; printf(&quot;%d\n&quot;, gao()); } else { fwtOr(cnt, C); for(int i = 0; i &lt; C; ++i) cnt[i] = cnt[i] * cnt[i] % MOD; ifwtOr(cnt, C); for(int i = 1; i &lt;= n; ++i) --cnt[a[i] | a[i]]; printf(&quot;%d\n&quot;, gao()); } } return 0; } SRM 518 NIM题意:$2$个人玩$nim$游戏，能选$K\le 10^9$堆，每堆必须是素数$p_i\le L\le 10^6$，后手赢的方案数 分析:$nim$游戏，由$SG$定理知，先手$xorsum$为$0$输，即后手赢问题就变成了这个，之后就可以$dp$了，$f[i][j]:=$选$i$堆异或和为$j$的方法数显然$f[1][j]$是知道的，转移是$f[i][j]=\displaystyle\sum_{x\oplus y=j} f[i-1][x] \times f[1][y]$发现这是个$and$卷积的形式，答案就是卷积的$k$次幂，所以直接做就好了 主要代码： fwtXor(a, L) a[i] = a[i] ^ k ifwtXor(a, L) ans = a[0] Codeforces 449D Jzzhu and Numbers题意：给定长度为$N\le 10^6$的数列，$A_i\le 10^6$，选出$0&lt;k\le N$个数使得它们二进制与起来的值为$0$，求方法数分析：题解给了一个容斥的做法，是基于子集卷积的$f[s]:=$子集状态为$s$的方法数，$g[s]:=s$中$1$的个数$f[s]$可由$fwt$子集卷积变换得到，之后我们根据容斥原理：$ans=2^n+\displaystyle\sum_{s=1}^{2^{20}-1}(-1)^{g(s)}\cdot2^{f(s)}$，这里空集被容斥掉了事实上，可以不用自己容斥，无论是哪种理解，对于某个$f[s]$，可以随便选即变成$2^{f[s]}$，然后再$ifwt$变换回去，答案就是$f[0]$，这里空集同样被容斥掉了从这里我们看出其实卷积也有容斥的感觉(试了一下代码发现$fwt$变换其实就是所谓的高维前缀和) 代码： // // Created by TaoSama on 2016-09-09 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e6 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; typedef long long LL; void fwtAnd(LL* a, int len) { if(len == 1) return; int h = len &gt;&gt; 1; fwtAnd(a, h); fwtAnd(a + h, h); for(int i = 0; i &lt; h; ++i) { LL x1 = a[i]; LL x2 = a[i + h]; a[i] = (x1 + x2) % MOD; a[i + h] = x2 % MOD; } } void ifwtAnd(LL* a, int len) { if(len == 1) return; int h = len &gt;&gt; 1; for(int i = 0; i &lt; h; ++i) { // y1=x1+x2 // y2=x2 LL y1 = a[i]; LL y2 = a[i + h]; a[i] = (y1 - y2 + MOD) % MOD; a[i + h] = y2 % MOD; } ifwtAnd(a, h); ifwtAnd(a + h, h); } int n; const int C = 1 &lt;&lt; 20; LL cnt[C + 10], two[C + 10]; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); two[0] = 1; for(int i = 1; i &lt; C; ++i) two[i] = two[i - 1] * 2 % MOD; while(scanf(&quot;%d&quot;, &amp;n) == 1) { memset(cnt, 0, sizeof cnt); for(int i = 1; i &lt;= n; ++i) { int x; scanf(&quot;%d&quot;, &amp;x); ++cnt[x]; } fwtAnd(cnt, C); for(int i = 0; i &lt; C; ++i) cnt[i] = two[cnt[i]]; ifwtAnd(cnt, C); printf(&quot;%I64d\n&quot;, cnt[0]); } return 0; } Reference SRM 518 NIM官方题解，含有证明 PICKS关于FWT，构造方案 板子来源参考]]></content>
      <categories>
        <category>小结</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 16（在线AC自动机、二进制分组）]]></title>
    <url>%2F2016%2F09%2F08%2FEducational%20Codeforces%20Round%2016%EF%BC%88%E5%9C%A8%E7%BA%BFAC%E8%87%AA%E5%8A%A8%E6%9C%BA%E3%80%81%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E7%BB%84%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $给定N\le 3\times 10^5次操作，操作一个字符串集合$$1 s:向集合添加字符串s$$2 s:从集合删除字符串s$$3 s:查询字符串s在集合的所有字符串中出现了多少次$$保证添加和删除操作合法，且\sum |S|\le 3\times 10^5$ 分析： $首先兹磁这种操作的有ac自动机，但是ac自动机是个离线的数据结构$$如何每次插入都build，那么总复杂度是1+2+\cdots+L=O(L^2)显然是不行的$$考虑均摊一下build的复杂度，维护一大一小ac自动机big、small$$每次添加和删除操作都往small的搞，每次都build，small如果大了就暴力合并到big上$$设总长是L，假设1个阈值D\le L，那么小的build满的复杂度是1+2+\cdots+D=O(D^2)$$显然一共有{L\over D}轮，这个复杂度是O({L\over D}\times D^2)=O(LD)$$把small合并到big上，每次都build，这个复杂度第k次是kD$$同理一共有{L\over D}轮，这个复杂度是D+2D+\cdots=O({L\over D}\times D+({L\over D})^2\times D)=O({L^2\over D})$$那么总复杂度就是O(D^2+{L^2\over D})=O({L^2\over D})$$显然当D=\sqrt L时，复杂度最好为O(L^{1.5})$ $类似的我们还可以维护2^i大小的AC自动机，根据同样的复杂度分析$$直观来讲每个字符移动了log次，所以总复杂度是O(LlogL)$ $对于这种做法我们称之为二进制分组，对于这种贡献独立的题$$我们以一个log的代价来让离线在线$ $懒的写内存池了，直接用容器写数据结构了，跑的比数组还快。。$$O2真可怕，看了下别人用了map写的比我的快了一倍$ $代码：$ // // Created by TaoSama on 2016-08-23 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 3e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; typedef long long LL; struct ACAutomata { static const int S = 26; int sz, root; vector&lt;vector&lt;int&gt; &gt; nxt; vector&lt;int&gt; fail, cnt; inline int idx(char c) {return c - &#39;a&#39;;} inline int newNode() { cnt.push_back(0); nxt.push_back(vector&lt;int&gt;(S, 0)); return sz++; } void init() { sz = 0; nxt.clear(); cnt.clear(); fail.clear(); root = newNode(); } void insert(const char* s, int d) { int u = root; for(; *s; ++s) { int c = idx(*s); int&amp; v = nxt[u][c]; if(!v) v = newNode(); u = v; } cnt[u] += d; } void build() { vector&lt;int&gt; q; fail.resize(nxt.size()); fail[root] = root; for(int i = 0; i &lt; S; ++i) { int&amp; v = nxt[root][i]; if(v) { fail[v] = root; q.push_back(v); } else v = root; } for(int k = 0; k &lt; q.size(); ++k) { int u = q[k]; for(int i = 0; i &lt; S; ++i) { int&amp; v = nxt[u][i]; if(v) { fail[v] = nxt[fail[u]][i]; cnt[v] += cnt[nxt[fail[u]][i]]; q.push_back(v); } else v = nxt[fail[u]][i]; } } } LL query(const char* s) { LL ret = 0; int u = root; for(; *s; ++s) { int c = idx(*s); u = nxt[u][c]; ret += cnt[u]; } return ret; } }; int q, op[N]; string s[N]; struct StaticToDynamic { static const int LOG = 20; ACAutomata ac[LOG]; vector&lt;int&gt; g[LOG]; void init() { for(int i = 0; i &lt; LOG; ++i) { g[i].clear(); ac[i].init(); } } inline get(int x) { return x == 1 ? 1 : -1; } void add(int id) { int p = -1; for(int i = 0; i &lt; LOG &amp;&amp; !~p; ++i) if(g[i].empty()) p = i; g[p].push_back(id); ac[p].insert(s[id].c_str(), get(op[id])); for(int i = 0; i &lt; p; ++i) { for(int id : g[i]) { g[p].push_back(id); ac[p].insert(s[id].c_str(), get(op[id])); } g[i].clear(); ac[i].init(); } ac[p].build(); } LL query(int id) { LL ret = 0; for(int i = 0; i &lt; LOG; ++i) ret += ac[i].query(s[id].c_str()); return ret; } } solver; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); while(cin &gt;&gt; q) { solver.init(); for(int i = 1; i &lt;= q; ++i) { cin &gt;&gt; op[i] &gt;&gt; s[i]; if(op[i] &lt;= 2) { solver.add(i); } else { cout &lt;&lt; solver.query(i) &lt;&lt; endl; } } } return 0; } 别人的： #include &lt;bits/stdc++.h&gt; using namespace std; struct AC { vector&lt;string&gt; keys; vector&lt;map&lt;char, int&gt;&gt; trie; vector&lt;long long&gt; endp; vector&lt;int&gt; fail; AC() { trie.resize(1); endp.resize(1); } void reset() { keys.clear(); trie.clear(); endp.clear(); fail.clear(); trie.resize(1); endp.resize(1); } void add_string(string&amp; s) { keys.push_back(s); int cur = 0; for(int i = 0; i &lt; (int)s.length(); i++) { if(trie[cur].count(s[i])) cur = trie[cur][s[i]]; else { cur = trie[cur][s[i]] = trie.size(); trie.push_back(map&lt;char, int&gt;()); endp.push_back(0); } } endp[cur]++; } void build() { fail.resize(trie.size()); vector&lt;pair&lt;int, pair&lt;int, char&gt;&gt;&gt; Q; Q.push_back({0, {0, &#39;\0&#39;}}); fail[0] = 0; for(int i = 0; i &lt; (int)Q.size(); i++) { int u = Q[i].first; int p = Q[i].second.first; char c = Q[i].second.second; for(auto&amp; it : trie[u]) Q.push_back({it.second, {u, it.first}}); if(u == 0) continue; int f = fail[p]; while(f != 0 &amp;&amp; !trie[f].count(c)) f = fail[f]; if(!trie[f].count(c) || trie[f][c] == u) fail[u] = 0; else fail[u] = trie[f][c]; endp[u] += endp[fail[u]]; } } long long count(string&amp; s) { if(keys.empty()) return 0; long long ret = 0; int cur = 0; for(int i = 0; i &lt; (int)s.length(); i++) { while(cur != 0 &amp;&amp; !trie[cur].count(s[i])) cur = fail[cur]; if(trie[cur].count(s[i])) cur = trie[cur][s[i]]; ret += endp[cur]; } return ret; } }; struct StaticToDynamic { AC ac[19]; void add(string&amp; s) { int k = 0; for(int i = 0; i &lt; 19; i++) if(ac[i].keys.empty()) { k = i; break; } ac[k].add_string(s); for(int i = 0; i &lt; k; i++) { for(auto&amp; it : ac[i].keys) ac[k].add_string(it); ac[i].reset(); } ac[k].build(); } long long count(string&amp; s) { long long ret = 0; for(int i = 0; i &lt; 19; i++) ret += ac[i].count(s); return ret; } } r, g; char buf[300001]; int main() { int N; scanf(&quot;%d&quot;, &amp;N); while(N--) { int t; scanf(&quot;%d%s&quot;, &amp;t, buf); string s(buf, buf + strlen(buf)); if(t == 1) r.add(s); else if(t == 2) g.add(s); else { printf(&quot;%I64d\n&quot;, r.count(s) - g.count(s)); fflush(stdout); } } return 0; }]]></content>
      <categories>
        <category>字符串</category>
        <category>AC自动机</category>
      </categories>
      <tags>
        <tag>二进制分组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 2482 Stars in Your Window（扫描线、线段树）]]></title>
    <url>%2F2016%2F08%2F29%2FPOJ%202482%20Stars%20in%20Your%20Window%EF%BC%88%E6%89%AB%E6%8F%8F%E7%BA%BF%E3%80%81%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $给定N\le 10^4个星星，每个有权值1\le w_i\le 100$$现有W\times H的矩形，问能严格框住的星星最大权值和是多少$ 分析： $考虑把问题转化一下，先不管严格框住，考虑极限情况，一个星星位于左下角$$那么就可以得到框住它的矩形是(x, y)，(x+w, y+h)了$$问题就转化成了类似于矩形面积并的问题，不过这里是求最大值$$之后扫描线一波、线段树区间更新一波就好了$$对于严格的情况，闭区间，可以把y+h变成y+h-1，w+h变成w+h-1$$但是扫描线的时候要注意，因为是闭区间了，所以当重合的时候，要先添加再删除$$当然扫描线每次都要注意这个的。。$$嘛，只有查询maxv[1]，写个标记永久化偷懒不用pushDown$$时间复杂度O(nlogn)$ $代码：$ // // Created by TaoSama on 2016-08-24 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e4 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; typedef long long LL; LL x[N], y[N], r[N]; LL maxv[N &lt;&lt; 3], addv[N &lt;&lt; 3]; void update(int L, int R, int v, int l, int r, int rt) { if(L &lt;= l &amp;&amp; r &lt;= R) { maxv[rt] += v; addv[rt] += v; return ; } int m = l + r &gt;&gt; 1; if(L &lt;= m) update(L, R, v, l, m, rt &lt;&lt; 1); if(R &gt; m) update(L, R, v, m + 1, r, rt &lt;&lt; 1 | 1); maxv[rt] = max(maxv[rt &lt;&lt; 1], maxv[rt &lt;&lt; 1 | 1]) + addv[rt]; } int n, w, h; #define y1 fddsfsdfds struct Line { LL x, d, y1, y2; Line() {} Line(LL x, LL d, LL y1, LL y2): x(x), d(d), y1(y1), y2(y2) {} bool operator&lt;(const Line&amp; l) const { if(x == l.x) return d &lt; l.d; return x &lt; l.x; } }; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); while(scanf(&quot;%d%d%d&quot;, &amp;n, &amp;w, &amp;h) == 3) { vector&lt;LL&gt; ys; for(int i = 1; i &lt;= n; ++i) { scanf(&quot;%lld%lld%lld&quot;, x + i, y + i, r + i); ys.push_back(y[i]); ys.push_back(y[i] + h - 1); } sort(ys.begin(), ys.end()); ys.resize(unique(ys.begin(), ys.end()) - ys.begin()); vector&lt;Line&gt; events; for(int i = 1; i &lt;= n; ++i) { LL y1 = lower_bound(ys.begin(), ys.end(), y[i]) - ys.begin() + 1; LL y2 = lower_bound(ys.begin(), ys.end(), y[i] + h - 1) - ys.begin() + 1; events.push_back(Line(x[i], -r[i], y1, y2)); //+ first events.push_back(Line(x[i] + w - 1, r[i], y1, y2)); } sort(events.begin(), events.end()); memset(maxv, 0, sizeof maxv); memset(addv, 0, sizeof addv); LL ans = 0; for(int i = 0; i &lt; events.size(); ++i) { Line&amp; e = events[i]; LL d = -e.d, y1 = e.y1, y2 = e.y2; update(y1, y2, d, 1, ys.size(), 1); // pr(e.x); pr(d);pr(y1);pr(y2);prln(maxv[1]); ans = max(ans, maxv[1]); } printf(&quot;%lld\n&quot;, ans); } return 0; }]]></content>
      <categories>
        <category>计算几何</category>
        <category>扫描线</category>
      </categories>
      <tags>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 3168 Barn Expansion（扫描线）]]></title>
    <url>%2F2016%2F08%2F29%2FPOJ%203168%20Barn%20Expansion%EF%BC%88%E6%89%AB%E6%8F%8F%E7%BA%BF%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $给定N\le 2.5\times 10^4个矩形，保证没有重合，且任何边相切或者顶点重合的是不好的$$问最后还有几个好的$ 分析： $- - 一眼扫描线了，关键是y轴怎么搞$$蓝儿扫描线的时候自己太naive复杂度爆炸$$事实上把矩形看作4个事件，y方向各自1个出入$$然后我们发现相切的情况实际上就是前缀和\ge 2$$嘛，注意顶点的情况，这个时候要先算进入事件$$时间复杂度O(nlogn)$ $代码：$ // // Created by TaoSama on 2016-08-24 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n; int bx[N], by[N], ux[N], uy[N]; struct Line { int x, y, id; Line() {} Line(int x, int y, int id): x(x), y(y), id(id) {} bool operator&lt;(const Line&amp; l) const { if(x == l.x) { if(y == l.y) return id &lt; l.id; //+ first return y &lt; l.y; } return x &lt; l.x; } }; void solve(vector&lt;int&gt;&amp; bad, int* bx, int* ux, int* by, int* uy) { vector&lt;Line&gt; events; for(int i = 1; i &lt;= n; ++i) { events.push_back(Line(bx[i], by[i], -i)); events.push_back(Line(bx[i], uy[i], i)); events.push_back(Line(ux[i], by[i], -i)); events.push_back(Line(ux[i], uy[i], i)); } sort(events.begin(), events.end()); int sum = 1; for(int i = 1; i &lt; events.size(); ++i) { sum += events[i].id &lt; 0 ? 1 : -1; int preID = abs(events[i - 1].id), curID = abs(events[i].id); if(sum &gt;= 2) bad[preID] = bad[curID] = true; } } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); while(scanf(&quot;%d&quot;, &amp;n) == 1) { for(int i = 1; i &lt;= n; ++i) scanf(&quot;%d%d%d%d&quot;, bx + i, by + i, ux + i, uy + i); vector&lt;int&gt; bad(n + 1, false); solve(bad, bx, ux, by, uy); solve(bad, by, uy, bx, ux); int ans = n - count(bad.begin(), bad.end(), true); printf(&quot;%d\n&quot;, ans); } return 0; }]]></content>
      <categories>
        <category>计算几何</category>
        <category>扫描线</category>
      </categories>
      <tags>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 1418 Viva Confetti（极角扫描）]]></title>
    <url>%2F2016%2F08%2F29%2FPOJ%201418%20Viva%20Confetti%EF%BC%88%E6%9E%81%E8%A7%92%E6%89%AB%E6%8F%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $给定N\le 100个圆，按输入顺序1个1个放，问最后能看到哪些圆$ 分析： $这个题的做法来自于题解了，感觉我也是似懂非懂$$考虑对于每个圆来说与其他圆的相交部分，是一段圆弧，极角表示法$$极角排序后，对于任意2个交点的每段圆弧，求它们的中点$$之后向内向外偏移一点，求上面那个第一个盖住它的就是可以看见的$$由于是从下往上找的，所以最后留下的就是都可以看见的$$时间复杂度O(n^3logn)$ $代码：$ // // Created by TaoSama on 2016-08-23 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; #include &lt;complex&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; typedef complex&lt;double&gt; P; const double EPS = 5e-13, PI = acos(-1); int n; double normalize(double r) { if(r &lt; 0.0) r += 2 * PI; if(r &gt;= 2 * PI) r -= 2 * PI; return r; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); while(scanf(&quot;%d&quot;, &amp;n) == 1 &amp;&amp; n) { vector&lt;P&gt; ps(n); vector&lt;double&gt; rs(n); for(int i = 0; i &lt; n; ++i) { double x, y, r; scanf(&quot;%lf%lf%lf&quot;, &amp;x, &amp;y, &amp;r); ps[i] = P(x, y); rs[i] = r; } vector&lt;int&gt; visible(n, 0); for(int i = 0; i &lt; n; ++i) { vector&lt;double&gt; angles; angles.push_back(0); angles.push_back(2 * PI); for(int j = 0; j &lt; n; ++j) { if(i == j) continue; P v = ps[j] - ps[i]; double a = abs(v); double b = rs[i]; double c = rs[j]; if(a + b &lt; c || a + c &lt; b || b + c &lt; a) continue; double angle = arg(v); double delta = acos((a * a + b * b - c * c) / (2 * a * b)); angles.push_back(normalize(angle - delta)); angles.push_back(normalize(angle + delta)); } sort(angles.begin(), angles.end()); for(int j = 0; j + 1 &lt; angles.size(); ++j) { double theta = (angles[j] + angles[j + 1]) / 2; for(int d = -1; d &lt;= 1; d += 2) { P o = ps[i] + polar(rs[i] + d * EPS, theta); for(int k = n - 1; ~k; --k) { if(abs(ps[k] - o) &lt; rs[k]) { visible[k] = true; break; } } } } } int ans = count(visible.begin(), visible.end(), true); printf(&quot;%d\n&quot;, ans); } return 0; }]]></content>
      <categories>
        <category>计算几何</category>
        <category>极角扫描</category>
      </categories>
      <tags>
        <tag>极角扫描</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AOJ 1313 Intersection of Two Prisms（数值积分）]]></title>
    <url>%2F2016%2F08%2F28%2FAOJ%201313%20Intersection%20of%20Two%20Prisms%EF%BC%88%E6%95%B0%E5%80%BC%E7%A7%AF%E5%88%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $三维平面2个棱柱的交体积$$一个底面在XOY平面，Z轴无限延伸，一个底面在XOZ平面，Y轴无限延伸$$2个凸多边形顶点数分别为N\le 100，M\le 100$ 分析： $考虑x=a平面对于2个棱柱的切面，切面在YOZ平面的投影是个矩形$$之后用这个矩形对x积分就得到了交体积$$直接用Simpson近似一下就好了，具体的话拿出x的每一段就好了$$由于体积就3次函数不是很高，并且要求精度才3位，就不需要自适应了$$时间复杂度O(n^2)$ $代码：$ // // Created by TaoSama on 2016-08-23 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 100 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; #define y1 asdadasdasd int m, n; double x1[N], y1[N], x2[N], z2[N]; double width(double a, double* x, double* y, int n) { double l = INF, r = -INF; for(int i = 1; i &lt;= n; ++i) { double x1 = x[i], x2 = x[i + 1], y1 = y[i], y2 = y[i + 1]; if((a - x1) * (a - x2) &lt;= 0) { //intersect double b = y1 + (y2 - y1) * (a - x1) / (x2 - x1); l = min(l, b); r = max(r, b); } } return max(0.0, r - l); } double solve() { double ret = 0; double minX = *min_element(x1 + 1, x1 + 1 + m); double maxX = *max_element(x1 + 1, x1 + 1 + m); minX = max(minX, *min_element(x2 + 1, x2 + 1 + n)); maxX = min(maxX, *max_element(x2 + 1, x2 + 1 + n)); vector&lt;double&gt; xs; for(int i = 1; i &lt;= m; ++i) if(x1[i] &gt;= minX &amp;&amp; x1[i] &lt;= maxX) xs.push_back(x1[i]); for(int i = 1; i &lt;= n; ++i) if(x2[i] &gt;= minX &amp;&amp; x2[i] &lt;= maxX) xs.push_back(x2[i]); sort(xs.begin(), xs.end()); xs.resize(unique(xs.begin(), xs.end()) - xs.begin()); for(int i = 0; i + 1 &lt; xs.size(); ++i) { double a = xs[i], b = xs[i + 1], c = (a + b) / 2; double fa = width(a, x1, y1, m) * width(a, x2, z2, n); double fb = width(b, x1, y1, m) * width(b, x2, z2, n); double fc = width(c, x1, y1, m) * width(c, x2, z2, n); ret += (b - a) / 6 * (fa + 4 * fc + fb); } return ret; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); while(scanf(&quot;%d%d&quot;, &amp;m, &amp;n) == 2 &amp;&amp; (m || n)) { for(int i = 1; i &lt;= m; ++i) scanf(&quot;%lf%lf&quot;, x1 + i, y1 + i); x1[m + 1] = x1[1], y1[m + 1] = y1[1]; for(int i = 1; i &lt;= n; ++i) scanf(&quot;%lf%lf&quot;, x2 + i, z2 + i); x2[n + 1] = x2[1], z2[n + 1] = z2[1]; printf(&quot;%.12f\n&quot;, solve()); } return 0; }]]></content>
      <categories>
        <category>计算几何</category>
        <category>数值积分</category>
      </categories>
      <tags>
        <tag>数值积分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 1981 Circle and Points（极限情况、极角扫描）]]></title>
    <url>%2F2016%2F08%2F28%2FPOJ%201981%20Circle%20and%20Points%EF%BC%88%E6%9E%81%E9%99%90%E6%83%85%E5%86%B5%E3%80%81%E6%9E%81%E8%A7%92%E6%89%AB%E6%8F%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N\le 300个点，问1个单位圆最多能包住几个点，在边界上也可以$$保证最多只有2个点在圆上$ 分析： $极限情况辣，肯定是有2个点在圆上的，暴力枚举2个点是n^2$$然后几何姿势找到圆心，转转向量啥的，之后再看有多个在圆内，O(n^3)$$蓝儿其实可以不这么想，考虑能包住每个点的圆是啥样的$$也就是说每个点作为圆心的单位圆，对于任意2个点能共同包住的部分显然是相交的那部分$$这是一个圆弧，我们可以用极角来表示这些圆弧，进入角度和出去角度$$事实上对于每个点，和其他点的形成的圆交的圆弧，求一个并，那么最大的并就是答案了$$至于求并，极角排序以后，+1-1极角扫描合并就可以了$$时间复杂度O(n^2logn)$ $代码O(n^3)：$ // // Created by TaoSama on 2016-08-23 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 300 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; const double EPS = 1e-8; int sgn(double x) { return x &lt; -EPS ? -1 : x &gt; EPS; } int n; struct Point { double x, y; Point() {} Point(double x, double y): x(x), y(y) {} inline void read() { scanf(&quot;%lf%lf&quot;, &amp;x, &amp;y); } inline Point operator+(const Point&amp; p) const { return Point(x + p.x, y + p.y); } inline Point operator-(const Point&amp; p) const { return Point(x - p.x, y - p.y); } inline Point operator*(const double&amp; k) const { return Point(k * x, k * y); } inline double operator*(const Point&amp; p) const { return x * p.x + y * p.y; } inline double operator^(const Point&amp; p) const { return x * p.y - y * p.x; } inline Point rotate(double rad) { return Point(x * cos(rad) - y * sin(rad), x * sin(rad) + y * cos(rad)); } inline double length() { return sqrt(x * x + y * y); } inline void norm() { double l = length(); x /= l, y /= l; } void see() { printf(&quot;%.4f %.4f\n&quot;, x, y); } } ps[N]; typedef Point Vector; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif // ios_base::sync_with_stdio(0); while(scanf(&quot;%d&quot;, &amp;n) == 1 &amp;&amp; n) { for(int i = 1; i &lt;= n; ++i) ps[i].read(); int ans = 1; for(int i = 1; i &lt;= n; ++i) { for(int j = i + 1; j &lt;= n; ++j) { if(i == j) continue; Vector AB = ps[j] - ps[i]; //B-A=AB double c = AB.length(); if(sgn(c - 2) &gt; 0) continue; double cosTheta = (c * c + 1 - 1) / (2 * c); double theta = acos(cosTheta); Vector AO = AB.rotate(theta); AO.norm(); Point O = ps[i] + AO; int cnt = 0; for(int k = 1; k &lt;= n; ++k) if(sgn((ps[k] - O).length() - 1) &lt;= 0) ++cnt; ans = max(ans, cnt); } } printf(&quot;%d\n&quot;, ans); } return 0; } $O(n^2logn)：$ // // Created by TaoSama on 2016-08-23 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 300 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; const double EPS = 1e-8; int sgn(double x) { return x &lt; -EPS ? -1 : x &gt; EPS; } int n; struct Point { double x, y; Point() {} Point(double x, double y): x(x), y(y) {} inline void read() { scanf(&quot;%lf%lf&quot;, &amp;x, &amp;y); } inline Point operator+(const Point&amp; p) const { return Point(x + p.x, y + p.y); } inline Point operator-(const Point&amp; p) const { return Point(x - p.x, y - p.y); } inline Point operator*(const double&amp; k) const { return Point(k * x, k * y); } inline double operator*(const Point&amp; p) const { return x * p.x + y * p.y; } inline double operator^(const Point&amp; p) const { return x * p.y - y * p.x; } inline Point rotate(double rad) { return Point(x * cos(rad) - y * sin(rad), x * sin(rad) + y * cos(rad)); } inline double length() { return sqrt(x * x + y * y); } inline double angle() { return atan2(y, x); } inline void norm() { double l = length(); x /= l, y /= l; } void see() { printf(&quot;%.4f %.4f\n&quot;, x, y); } } ps[N]; typedef Point Vector; pair&lt;double, int&gt; angles[N]; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif // ios_base::sync_with_stdio(0); while(scanf(&quot;%d&quot;, &amp;n) == 1 &amp;&amp; n) { for(int i = 1; i &lt;= n; ++i) ps[i].read(); int ans = 1; for(int i = 1; i &lt;= n; ++i) { int m = 0; for(int j = 1; j &lt;= n; ++j) { if(i == j) continue; Vector AB = ps[j] - ps[i]; double c = AB.length(); if(sgn(c - 2) &gt; 0) continue; double angle = AB.angle(); double delta = acos(c / 2); angles[m++] = make_pair(angle - delta, 1); angles[m++] = make_pair(angle + delta, -1); } sort(angles, angles + m); int cnt = 1; for(int j = 0; j &lt; m; ++j) { cnt += angles[j].second; ans = max(ans, cnt); } } printf(&quot;%d\n&quot;, ans); } return 0; }]]></content>
      <categories>
        <category>计算几何</category>
        <category>极角扫描</category>
      </categories>
      <tags>
        <tag>极角扫描</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 2187 Beauty Contest（凸包、旋转卡壳、最远点对）]]></title>
    <url>%2F2016%2F08%2F28%2FPOJ%202187%20Beauty%20Contest%EF%BC%88%E5%87%B8%E5%8C%85%E3%80%81%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B3%E3%80%81%E6%9C%80%E8%BF%9C%E7%82%B9%E5%AF%B9%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N\le 5\times 10^4个点，求最远点的距离的平方$ 分析： $凸包，然后旋转卡壳辣$$类似two pointers的做法，一图流$ // // Created by TaoSama on 2016-08-22 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; struct Point { int x, y; Point() {} Point(int x, int y): x(x), y(y) {} void read() { scanf(&quot;%d%d&quot;, &amp;x, &amp;y); } Point operator-(const Point&amp; p) const { return Point(x - p.x, y - p.y); } int operator*(const Point&amp; p) const { return x * p.x + y * p.y; } int operator^(const Point&amp; p) const { return x * p.y - y * p.x; } bool operator&lt;(const Point&amp; p) const { return x == p.x &amp;&amp; y &lt; p.y || x &lt; p.x; } int length() { return *this * *this; } } ps[N]; //输入不能有重点，函数执行完后输入顺序被破坏 Point ch[N]; int convexHull(Point* p, int n, Point* ch) { sort(p, p + n); int m = 0; for(int i = 0; i &lt; n; ++i) { while(m &gt; 1 &amp;&amp; ((ch[m - 1] - ch[m - 2]) ^ (p[i] - ch[m - 2])) &lt;= 0) --m; ch[m++] = p[i]; } for(int i = n - 2, t = m; ~i; --i) { while(m &gt; t &amp;&amp; ((ch[m - 1] - ch[m - 2]) ^ (p[i] - ch[m - 2])) &lt;= 0) --m; ch[m++] = p[i]; } if(n &gt; 1) --m; return m; } int rotatingCalipers(Point* ch, int n) { if(n == 2) return (ch[1] - ch[0]).length(); int ret = 0; ch[n] = ch[0]; for(int i = 0, j = 2; i &lt; n; ++i) { while(((ch[i + 1] - ch[i]) ^ (ch[j + 1] - ch[i])) &gt; ((ch[i + 1] - ch[i]) ^ (ch[j] - ch[i]))) j = (j + 1) % n; ret = max(ret, max((ch[j] - ch[i + 1]).length(), (ch[j] - ch[i]).length())); } return ret; } int n; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); while(scanf(&quot;%d&quot;, &amp;n) == 1) { for(int i = 0; i &lt; n; ++i) ps[i].read(); int chSz = convexHull(ps, n, ch); int ans = rotatingCalipers(ch, chSz); printf(&quot;%d\n&quot;, ans); } return 0; }]]></content>
      <categories>
        <category>计算几何</category>
        <category>旋转卡壳</category>
      </categories>
      <tags>
        <tag>旋转卡壳</tag>
        <tag>最远点对</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 2932 Coneology（扫描线）]]></title>
    <url>%2F2016%2F08%2F28%2FPOJ%202932%20Coneology%EF%BC%88%E6%89%AB%E6%8F%8F%E7%BA%BF%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N\le 4\times 10^4个圆，所有圆不相交和相切，输出所有最外层的圆$ 分析： $显然n^2枚举标记内层圆是不可以的，虽然有很多剪枝$$这种题就考虑扫描线了，把每个圆拆成进入事件和出去的事件$$考虑用set维护一下外层圆的y坐标$$显然最有可能包含是离它最近的，判一判就好了，而且有且只有他一个$$反证一下就好了，如果远的包含，那么上面这个之前就没有被丢进来$$时间复杂度O(nlogn)$ // // Created by TaoSama on 2016-08-22 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n; double x[N], y[N], r[N]; bool isInside(int i, int j) { double dx = x[i] - x[j], dy = y[i] - y[j]; return dx * dx + dy * dy &lt;= r[j] * r[j]; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); while(scanf(&quot;%d&quot;, &amp;n) == 1) { vector&lt;pair&lt;double, int&gt; &gt; events; for(int i = 1; i &lt;= n; ++i) { scanf(&quot;%lf%lf%lf&quot;, r + i, x + i, y + i); events.push_back(make_pair(x[i] - r[i], i)); events.push_back(make_pair(x[i] + r[i], -i)); } sort(events.begin(), events.end()); vector&lt;int&gt; ans; set&lt;pair&lt;double, int&gt; &gt; outers; for(int i = 0; i &lt; events.size(); ++i) { int id = events[i].second; if(id &gt; 0) { set&lt;pair&lt;double, int&gt; &gt;::iterator iter = outers.lower_bound(make_pair(y[id], -1)); if(iter != outers.end() &amp;&amp; isInside(id, iter-&gt;second)) continue; if(iter != outers.begin() &amp;&amp; isInside(id, (--iter)-&gt;second)) continue; ans.push_back(id); outers.insert(make_pair(y[id], id)); } else outers.erase(make_pair(y[-id], -id)); } sort(ans.begin(), ans.end()); printf(&quot;%d\n&quot;, ans.size()); for(int i = 0; i &lt; ans.size(); ++i) { printf(&quot;%d%c&quot;, ans[i], &quot; \n&quot;[i == ans.size() - 1]); } } return 0; }]]></content>
      <categories>
        <category>计算几何</category>
        <category>扫描线</category>
      </categories>
      <tags>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AOJ 2308 White Bird（计算几何、物理）]]></title>
    <url>%2F2016%2F08%2F28%2FAOJ%202308%20White%20Bird%EF%BC%88%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E3%80%81%E7%89%A9%E7%90%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $愤怒的小鸟，给定白鸟(0, 0)，就是可以从抛物线轨迹上任意一点下蛋的鸟$$给定N\le 50个矩形障碍物，和目标位置$$问能不能用蛋干掉目标$ 分析： $考虑极限情况就是贴着过去的，但是窝萌可以通过微小的偏移来不撞上$$所以就暴力枚举所有矩形的左上和右上的抛物线，当然直接到达目标也要枚举$$之后就是恶心的分类讨论了$$击打左边界、右边界、下边界、内部(包括了上边界)$$反正不管三七二十一、多判肯定没问题$$至于判断方法的话，可以考虑解点在特定位置的坐标，或者根据抛物线形态来判断$$2点坐标就可以确定形态$$注意细节、多画图就可以AC了$$时间复杂度O(n^2)$ // // Created by TaoSama on 2016-08-22 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 50 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; const double EPS = 1e-8, g = 9.8; int sgn(double x) { return x &lt; -EPS ? -1 : x &gt; EPS; } int n; double V, X, Y; double L[N], B[N], R[N], T[N]; double getY(double vy, double t) { return vy * t - 0.5 * g * t * t; } bool check(double qx, double qy) { if(sgn(qx) == 0) return false; //vx^2 + vy^2 = v^2, vx * t = qx, vy*t -0.5*g*t^2=qy //qx^2+qy^2+qy*g*t^2+(0.5*g*t^2)^2-v^2*t=0 double a = g * g / 4, b = qy * g - V * V, c = qx * qx + qy * qy; double delta = b * b - 4 * a * c; if(sgn(delta) &lt; 0) return false; delta = sqrt(abs(delta)); for(int d = -1; d &lt;= 1; d += 2) { double t = (-b + d * delta) / (2 * a); if(sgn(t) &lt; 0) continue; t = sqrt(abs(t)); double vx = qx / t, vy = (qy + 0.5 * g * t * t) / t; double yt = getY(vy, X / vx); if(sgn(yt - Y) &lt; 0) continue; bool ok = true; for(int i = 1; i &lt;= n &amp;&amp; ok; ++i) { if(sgn(L[i] - X) &gt; 0) continue; //target is in or below the obstacle if(sgn(X - L[i]) &gt; 0 &amp;&amp; sgn(X - R[i]) &lt; 0 &amp;&amp; sgn(yt - B[i]) &gt; 0 &amp;&amp; sgn(Y - T[i]) &lt; 0) ok = false; double yL = getY(vy, L[i] / vx), yR = getY(vy, R[i] / vx); //hit left if(sgn(yL - B[i]) &gt; 0 &amp;&amp; sgn(yL - T[i]) &lt; 0) ok = false; //hit right if(sgn(yR - B[i]) &gt; 0 &amp;&amp; sgn(yR - T[i]) &lt; 0) ok = false; //hit down if(sgn(yL - B[i]) &lt; 0 &amp;&amp; sgn(yR - B[i]) &gt; 0) ok = false; //highest point double xH = vx * vy / g, yH = getY(vy, vy / g); //hit inside, this time highest point is in or above the obstacle if(sgn(xH - L[i]) &gt; 0 &amp;&amp; sgn(xH - R[i]) &lt; 0 &amp;&amp; sgn(yL - B[i]) &lt; 0 &amp;&amp; sgn(yH - B[i]) &gt; 0) ok = false; } if(ok) return true; } return false; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); while(scanf(&quot;%d%lf%lf%lf&quot;, &amp;n, &amp;V, &amp;X, &amp;Y) == 4) { for(int i = 1; i &lt;= n; ++i) { scanf(&quot;%lf%lf%lf%lf&quot;, L + i, B + i, R + i, T + i); R[i] = min(R[i], X); } bool ok = check(X, Y); for(int i = 1; i &lt;= n &amp;&amp; !ok; ++i) { ok |= check(L[i], T[i]); ok |= check(R[i], T[i]); } puts(ok ? &quot;Yes&quot; : &quot;No&quot;); } return 0; }]]></content>
      <categories>
        <category>计算几何</category>
      </categories>
      <tags>
        <tag>物理</tag>
        <tag>极限情况</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 1127 Jack Straws（计算几何）]]></title>
    <url>%2F2016%2F08%2F28%2FPOJ%201127%20Jack%20Straws%EF%BC%88%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N&lt;13条线段，不规范相交认为是相连，求2条线段是不是直接或者间接相连$ 分析： $不规范相交直接在规范相交的基础上再判断是不是端点在另一条线段上即可$$间接相连求个传递闭包就好了$$时间复杂度O(n^3)$ // // Created by TaoSama on 2016-08-22 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 12 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; struct Point { int x, y; Point() {} Point(int x, int y): x(x), y(y) {} void read() { scanf(&quot;%d%d&quot;, &amp;x, &amp;y); } Point operator-(const Point&amp; p) const { return Point(x - p.x, y - p.y); } int operator*(const Point&amp; p) const { return x * p.x + y * p.y; } int operator^(const Point&amp; p) const { return x * p.y - y * p.x; } } ps[N][2]; bool segmentProperIntersection(Point a1, Point a2, Point b1, Point b2) { int c1 = (a2 - a1) ^ (b1 - a1), c2 = (a2 - a1) ^ (b2 - a1); int c3 = (b2 - b1) ^ (a1 - b1), c4 = (b2 - b1) ^ (a2 - b1); return c1 * c2 &lt; 0 &amp;&amp; c3 * c4 &lt; 0; } bool onSegment(Point p, Point a1, Point a2) { return ((a1 - p) ^ (a2 - p)) == 0 &amp;&amp; (a1 - p) * (a2 - p) &lt;= 0; } int n; bool f[N][N]; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); while(scanf(&quot;%d&quot;, &amp;n) == 1 &amp;&amp; n) { for(int i = 1; i &lt;= n; ++i) for(int j = 0; j &lt; 2; ++j) ps[i][j].read(); for(int i = 1; i &lt;= n; ++i) { f[i][i] = true; for(int j = i + 1; j &lt;= n; ++j) { int ok = segmentProperIntersection(ps[i][0], ps[i][1], ps[j][0], ps[j][1]); ok |= onSegment(ps[i][0], ps[j][0], ps[j][1]) || onSegment(ps[i][1], ps[j][0], ps[j][1]) || onSegment(ps[j][0], ps[i][0], ps[i][1]) || onSegment(ps[j][1], ps[i][0], ps[i][1]); f[i][j] = f[j][i] = ok; } } for(int k = 1; k &lt;= n; ++k) for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= n; ++j) f[i][j] |= f[i][k] &amp;&amp; f[k][j]; int a, b; while(scanf(&quot;%d%d&quot;, &amp;a, &amp;b) == 2 &amp;&amp; (a || b)) { puts(f[a][b] ? &quot;CONNECTED&quot; : &quot;NOT CONNECTED&quot;); } } return 0; }]]></content>
      <categories>
        <category>计算几何</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[AIM Tech Round 3 (Div. 1) D. Incorrect Flow（有源汇可行费用流）]]></title>
    <url>%2F2016%2F08%2F26%2FAIM%20Tech%20Round%203%20(Div.%201)%20D.%20Incorrect%20Flow%EF%BC%88%E6%9C%89%E6%BA%90%E6%B1%87%E5%8F%AF%E8%A1%8C%E8%B4%B9%E7%94%A8%E6%B5%81%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N\le 100，M\le 100的流网络，0\le c_i, f_i\le 10^6$$现在这个网络错了，可能c_i&gt;f_i，也可能流量不平衡$$现在要求你修改f_i和c_i使得流网络成为可行流，并且change=\sum |f_i’-f_i|+|c_i’-c_i|最小$$求这个change$ 分析： $对于无源汇的上下界可行流，新建源s，汇t，然后对于u\to v边，下界d，上界c$$变成s\to t, 容量d；u\to v，容量c-d；v\to t，容量d$$合并一下边就好了最后，如果有可行流，那么一定满流(下界一定满足)$$对于有源汇的，添加t\to s，容量为INF的边，之后新建超源s’，超汇t’，再做上面的就可以了$$显然添加那条边之后就抵消了原来的源汇的影响(即给他们加上了流量平衡)$ $对于本题来说，有源汇的可行流，加t\to s，容量INF的边$$先钦定下界为原始图的，统计一下流入流出的balance$$接下来讨论f\le c的情况：$$c-f次机会用1的费用使得流量+1$$之后，INF次机会使用2的费用使得流量和容量一起+1$$当然，也有f次机会使用费用1使得流量-1$$对于f&gt;c的情况：$$因为只能运送流量，先直接把情况搞成合法，即预先用f-c的费用使得c=f(但事实上图没有变)$$当然，可以INF次机会使用2的费用使得流量和容量一起+1$$接下来，当然可以退回去，即f-c次机会0费用使得流量-1(相当于用预先加的代价)$$之后，c次机会1费用使得流量-1$$然后跑最小费用最大流就好了$ // // Created by TaoSama on 2016-08-26 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; const int M = 1e5 + 10; struct Edge { int v, nxt, cost, cap; } edge[M]; int head[N], cnt; void addEdge(int u, int v, int c, int w1, int w2 = 0) { edge[cnt] = {v, head[u], c, w1}; head[u] = cnt++; edge[cnt] = {u, head[v], -c, w2}; head[v] = cnt++; } int in[N], d[N], delta[N], pre[N]; bool spfa(int s, int t) { deque&lt;int&gt; q; q.push_back(s); for(int i = s; i &lt;= t; ++i) d[i] = INF, in[i] = false; delta[s] = INF; d[s] = 0; in[s] = true; while(q.size()) { int u = q.front(); q.pop_front(); in[u] = false; for(int i = head[u]; ~i; i = edge[i].nxt) { int v = edge[i].v, cap = edge[i].cap, cost = edge[i].cost; if(cap &gt; 0 &amp;&amp; d[v] &gt; d[u] + cost) { delta[v] = min(delta[u], cap); d[v] = d[u] + cost; pre[v] = i; if(!in[v]) { in[v] = true; if(q.size() &amp;&amp; d[v] &lt;= d[q.front()]) q.push_front(v); else q.push_back(v); } } } } return d[t] != INF; } void minCostMaxFlow(int s, int t, int&amp; flow, int&amp; cost) { while(spfa(s, t)) { flow += delta[t]; cost += d[t] * delta[t]; for(int i, u = t; u != s; u = edge[i ^ 1].v) { i = pre[u]; edge[i].cap -= delta[t]; edge[i ^ 1].cap += delta[t]; } } } int n, m; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) == 2) { cnt = 0; memset(head, -1, sizeof head); int ans = 0; int s = 0, t = n + 1; vector&lt;int&gt; balance(n + 1, 0); for(int i = 1; i &lt;= m; ++i) { int u, v, c, f; scanf(&quot;%d%d%d%d&quot;, &amp;u, &amp;v, &amp;c, &amp;f); balance[u] -= f; balance[v] += f; if(f &lt;= c) { addEdge(u, v, 1, c - f); //f +1 addEdge(u, v, 2, INF); //f +1, c +1 addEdge(v, u, 1, f); //f -1; } else { ans += f - c; //c-&gt;f first addEdge(u, v, 2, INF); //f +1, c +1 addEdge(v, u, 0, f - c); //back addEdge(v, u, 1, c); //f -1 } } addEdge(n, 1, 0, INF); for(int i = 1; i &lt;= n; ++i) { if(balance[i] &gt; 0) addEdge(s, i, 0, balance[i]); else addEdge(i, t, 0, -balance[i]); } int flow = 0; minCostMaxFlow(s, t, flow, ans); printf(&quot;%d\n&quot;, ans); } return 0; }]]></content>
      <categories>
        <category>图论</category>
        <category>网络流</category>
      </categories>
      <tags>
        <tag>可行流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AIM Tech Round 3 (Div. 1) C. Centroids（树形dp）]]></title>
    <url>%2F2016%2F08%2F26%2FAIM%20Tech%20Round%203%20(Div.%201)%20C.%20Centroids%EF%BC%88%E6%A0%91%E5%BD%A2dp%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $给定N\le 4\times 10^5的一棵树，询问每个点是否能通过删掉1条边再添加1条边成为重心$$重心：删除这个点，所有连通分量的最大大小\le n/2$ 分析： $首先考虑重心是怎么求的，显然树dp算所有的与之相连的子树的大小$$对于1个点u，如果要让它成为重心，显然要让跟它所有相连的子树的大小都变成\le n/2的$$而题目中说的删边其实就是等价于把一个子树连到u上的操作$$由于只能干一次，所以实际上我们肯定找\le n/2最大的那颗子树分裂出来$$所以dp的方式就显而易见了，当然儿子父亲都要搞$$maxSub[u]:=u的子树中\le n/2的最大子树的大小$$f[u]:=u的父亲f的子树中，除了u这颗子树外，\le n/2的最大子树的大小$$前者直接暴力转移就好，后者维护一下\le n/2的最大和次大就好$$因为对于f来说如果u是最大不能选那么选次大，反之就选最大$$当然对于父亲那边，我们需要dfs再搞一次，先继承一下父亲的答案$$然后再减去u这颗子树，看看整个父亲的部分能不能更新$$判断可行的时候，直接查看每个儿子就好了，判一判就做完了$$时间复杂度O(n)$ // // Created by TaoSama on 2016-08-25 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 4e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n; vector&lt;int&gt; G[N]; int sz[N], maxSub[N], fa[N]; //u子树中不超过n/2的最大子树 //不经过u这颗子树fa子树中能取到的不超过n/2的最大子树 //再dfs一次变成不经过u这颗子树整棵树中能取到的不超过n/2的最大子树 void dfs1(int u, int f) { sz[u] = 1; int maxv = 0, nxtv = 0; for(int v : G[u]) { if(v == f) continue; dfs1(v, u); sz[u] += sz[v]; if(maxSub[v] &gt;= maxv) { nxtv = maxv; maxv = maxSub[v]; } else if(maxSub[v] &gt; nxtv) nxtv = maxSub[v]; } for(int v : G[u]) { if(v == f) continue; if(maxSub[v] == maxv) fa[v] = nxtv; else fa[v] = maxv; } maxSub[u] = maxv; if(sz[u] &lt;= n / 2) maxSub[u] = max(maxSub[u], sz[u]); } int ans[N]; void dfs2(int u, int f) { int cnt = 0, ok = 1; for(int v : G[u]) { if(v == f) continue; if(sz[v] &gt; n / 2) { if(sz[v] - maxSub[v] &gt; n / 2) ok = 0; else ++cnt; } } if(n - sz[u] &gt; n / 2) { if(n - sz[u] - fa[u] &gt; n / 2) ok = 0; else ++cnt; } ans[u] = ok &amp;&amp; cnt &lt;= 1; for(int v : G[u]) { if(v == f) continue; fa[v] = max(fa[v], fa[u]); if(n - sz[v] &lt;= n / 2) fa[v] = max(fa[v], n - sz[v]); dfs2(v, u); } } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); while(scanf(&quot;%d&quot;, &amp;n) == 1) { for(int i = 1; i &lt;= n; ++i) G[i].clear(); for(int i = 1; i &lt; n; ++i) { int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); } dfs1(1, 0); dfs2(1, 0); for(int i = 1; i &lt;= n; ++i) printf(&quot;%d%c&quot;, ans[i], &quot; \n&quot;[i == n]); } return 0; }]]></content>
      <categories>
        <category>动态规划</category>
        <category>树形dp</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5801 Up Sky,Mr.Zhu（可持久化Trie）]]></title>
    <url>%2F2016%2F08%2F13%2FHDU%205801%20Up%20Sky%2CMr.Zhu%EF%BC%88%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96Trie%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $给定N\le 10^5的字符串S，字符集大小为5，其中的回文子串长度&lt;20$$定义回文子串str[0\ldots n-1]的特征串为str[\lfloor n/ 2\rfloor\ldots n-1]$$给定询问区间s[L\ldots R]里，特征串前缀为T的回文串有多少个，|T|\le 10$ 分析： $区间询问就是裸的可持久化Trie$$以每个字符s[i]为结尾建立每棵Trie，暴力把以s[i]结尾的全部特征串插进去$$由于区间询问的时候要保证回文串也在这个范围内，这么做是有问题的$$但是特征串长度在[1, 10]，所以可以暴力对每个长度建立可持久Trie$$这样空间是10\times N\times 10\times 5，就炸了$$所以折衷一下，离线询问，枚举每个特征串长度，每次重建可持久化Trie就行$$为了方便处理奇偶回文，可以枚举回文长度，注意各种合法边界，然后就没啥了$$时间复杂度O(n\times 10^2+q\times 10)$ // // Created by TaoSama on 2016-08-13 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; typedef long long LL; int root[N]; struct PersistentTrie { static const int M = N * 10, S = 5; int sz; struct Node { LL val; int nxt[S]; } dat[M]; void init() { sz = 0; memset(&amp;dat[0], 0, sizeof dat[0]); } int newNode(int rt) { dat[++sz] = dat[rt]; return sz; } void update(char* s, int n, int&amp; rt) { rt = newNode(rt); int u = rt; for(int i = 0; i &lt; n; ++i) { int c = s[i] - &#39;a&#39;; int&amp; v = dat[u].nxt[c]; v = newNode(v); ++dat[v].val; u = v; } } LL query(char* s, int rt) { int u = rt; for(int i = 0; s[i]; ++i) { int c = s[i] - &#39;a&#39;; u = dat[u].nxt[c]; } return dat[u].val; } } trie; int q; char s[N], t[N][15]; int l[N], r[N]; LL ans[N]; bool check(char* s, int len) { for(int i = 0; i &lt; len / 2; ++i) if(s[-i] != s[-(len - i - 1)]) return false; return true; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); while(scanf(&quot;%s%d&quot;, s + 1, &amp;q) == 2) { int n = strlen(s + 1); for(int i = 1; i &lt;= q; ++i) scanf(&quot;%d%d%s&quot;, l + i, r + i, t[i]); memset(ans, 0, sizeof ans); for(int len = 1; len &lt; 20; ++len) { trie.init(); for(int i = 1; i &lt;= n; ++i) { root[i] = root[i - 1]; if(i &lt; len) continue; bool ok = check(s + i, len); if(!ok) continue; int l = i - (len - 1) / 2; trie.update(s + l, (len + 1) / 2, root[i]); } for(int i = 1; i &lt;= q; ++i) { if(r[i] - l[i] + 1 &lt; len) continue; ans[i] += trie.query(t[i], root[r[i]]) - trie.query(t[i], root[l[i] + len - 2]); } } for(int i = 1; i &lt;= q; ++i) printf(&quot;%I64d\n&quot;, ans[i]); } return 0; }]]></content>
      <categories>
        <category>数据结构</category>
        <category>可持久化Trie</category>
      </categories>
      <tags>
        <tag>可持久化Trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5829 Rikka with Subset （NTT）]]></title>
    <url>%2F2016%2F08%2F12%2FHDU%205829%20Rikka%20with%20Subset%20%EF%BC%88NTT%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $给定N\le 10^5个数，对于一个给定的1\le K\le N，设数集全集为U$$\forall S\in U，val(S):=S中前min(K, |S|)大数的和$$val(U)_{k}=\sum_{S\in U} val(S)$$输出每个val(U)_{k}$ 分析： $首先将数列从大到小排序，考虑每个数a_i作为第k大数的贡献f(k)$$f(k)=\sum_{i=k}^n C_{i-1}^{k-1} \times 2^{n-i} \times a_i$$窝萌来化简一下这个式子：$$f(k)=\sum_{i=k}^n \frac{(i-1)!}{(k-1)! \times (i-k)!} \times 2^{n-i} \times a_i$$令i’=i-k，f(k)=\sum_{i’=0}^{n-k} \frac{(i’+k-1)!}{(k-1)! \times i’!} \times 2^{n-i’-k} \times a_{i’+k}$$=\frac{1}{2^{k}(k-1)!} \sum_{i’=0}^{n-k} \frac{(i’+k-1)!}{i’!} \times 2^{n-i’} \times a_{i’+k}$$=\frac{1}{2^{k}(k-1)!} \sum_{i’=0}^{n-k} \frac{2^{n-i’}}{i’!} \times (i’+k-1)! \times a_{i’+k}$$令b_{i’}=\frac{2^{n-i’}}{i’!}, c_{i’}=(i’-1)! \times a_{i’}$$则f(k)=\frac{1}{2^{k}(k-1)!} \sum_{i’=0}^{n-k} b_{i’} \times c_{i’+k}$$设f(k)=f’(n-k)=\frac{1}{2^{k}(k-1)!} \sum_{i’=0}^{n-k} g(i’) \times h(n-k-i’)，这是个卷积形式$$与上式对比，发现只需要把c_i reverse一下就好了$$此时c_i=c_{n-k+1-i}，多偏移了1，所以最后f(k)=f’(n-k+1)$$给的是费马素数，然后只需要NTT卷积一下b_i和reversed c_i就好了$$最后的答案只要前缀和一下f(k)$$时间复杂度O(nlogn)$ // // Created by TaoSama on 2016-08-12 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; typedef long long LL; const int G = 3, P = 998244353; LL quick(LL x, LL n) { LL ret = 1; for(; n; n &gt;&gt;= 1) { if(n &amp; 1) ret = ret * x % P; x = x * x % P; } return ret; } LL A[N &lt;&lt; 2], B[N &lt;&lt; 2]; void rader(LL* y, int len) { for(int i = 1, j = len / 2; i &lt; len - 1; i++) { if(i &lt; j) swap(y[i], y[j]); int k = len / 2; while(j &gt;= k) {j -= k; k /= 2;} if(j &lt; k) j += k; } } void ntt(LL* y, int len, int op) { rader(y, len); for(int h = 2; h &lt;= len; h &lt;&lt;= 1) { LL wn = quick(G, (P - 1) / h); if(op == -1) wn = quick(wn, P - 2); for(int j = 0; j &lt; len; j += h) { LL w = 1; for(int k = j; k &lt; j + h / 2; k++) { LL u = y[k]; LL t = w * y[k + h / 2] % P; y[k] = (u + t) % P; y[k + h / 2] = (u - t + P) % P; w = w * wn % P; } } } if(op == -1) { LL inv = quick(len, P - 2); for(int i = 0; i &lt; len; i++) y[i] = y[i] * inv % P; } } int n, a[N], f[N]; LL fact[N], invf[N], two[N], invt[N]; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); fact[0] = two[0] = invf[0] = invt[0] = 1; for(int i = 1; i &lt; N; ++i) { fact[i] = fact[i - 1] * i % P; two[i] = two[i - 1] * 2 % P; invf[i] = quick(fact[i], P - 2); invt[i] = quick(two[i], P - 2); } int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, a + i); sort(a + 1, a + n + 1, greater&lt;int&gt;()); int len = 1; while(len &lt;= n &lt;&lt; 1) len &lt;&lt;= 1; for(int i = 0; i &lt; len; ++i) { A[i] = i &lt;= n ? two[n - i] * invf[i] % P : 0; B[i] = i &gt;= 1 &amp;&amp; i &lt;= n ? a[i] * fact[i - 1] % P : 0; } reverse(B + 1, B + n + 1); ntt(A, len, 1); ntt(B, len, 1); for(int i = 0; i &lt; len; ++i) A[i] = A[i] * B[i] % P; ntt(A, len, -1); for(int i = 1; i &lt;= n; ++i) f[i] = invt[i] * invf[i - 1] % P * A[n - i + 1] % P; for(int i = 1; i &lt;= n; ++i) if((f[i] += f[i - 1]) &gt;= P) f[i] -= P; for(int i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;, f[i]); puts(&quot;&quot;); } return 0; }]]></content>
      <categories>
        <category>数学</category>
        <category>FFT/NTT/FWT</category>
      </categories>
      <tags>
        <tag>NTT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5756 Boss Bo（主席树、标记永久化）]]></title>
    <url>%2F2016%2F08%2F11%2FHDU%205756%20Boss%20Bo%EF%BC%88%E4%B8%BB%E5%B8%AD%E6%A0%91%E3%80%81%E6%A0%87%E8%AE%B0%E6%B0%B8%E4%B9%85%E5%8C%96%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $给定N\le 5\times 10^4个点的一棵树，Q\le 10^5$$定义一个点是好点，当且仅当他所有祖先都不是坏点$$每次询问指定K个点为坏点，查询1个点P到所有好点的$$op=1:距离和$$op=2:最小距离$$op=3:最大距离$ 分析： $定义换句话说，如果一个点是坏点，那么子树都是坏点$$剩下的就是官方题解的做法了$ // // Created by TaoSama on 2016-08-13 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 5e4 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; typedef long long LL; const LL LLINF = 0x3f3f3f3f3f3f3f3fLL; int n, q; vector&lt;int&gt; G[N]; int dep[N], L[N], R[N], vs[N], dfsNum; void dfs(int u, int fa) { L[u] = ++dfsNum; vs[dfsNum] = u; for(int v : G[u]) { if(v == fa) continue; dep[v] = dep[u] + 1; dfs(v, u); } R[u] = dfsNum; } int root[N]; struct PersistentSegTree { static const int M = N * 2 * 20; int sz; struct Node { int ls, rs; LL addv, maxv, minv, sum; void add(LL v, int len) { addv += v; sum += v * len; maxv += v; minv += v; } void see() { pr(addv); pr(maxv); pr(minv); prln(sum); } } dat[M]; int newNode(int rt) { dat[++sz] = dat[rt]; return sz; } void init() { sz = 0; memset(&amp;dat[0], 0, sizeof dat[0]); } void up(int rt, int len) { dat[rt].sum = dat[dat[rt].ls].sum + dat[dat[rt].rs].sum + dat[rt].addv * len; dat[rt].minv = min(dat[dat[rt].ls].minv, dat[dat[rt].rs].minv) + dat[rt].addv; dat[rt].maxv = max(dat[dat[rt].ls].maxv, dat[dat[rt].rs].maxv) + dat[rt].addv; } void build(int l, int r, int&amp; rt) { rt = newNode(0); if(l == r) { dat[rt].add(dep[vs[l]], 1); return; } int m = l + r &gt;&gt; 1; build(l, m, dat[rt].ls); build(m + 1, r, dat[rt].rs); up(rt, r - l + 1); } void update(int L, int R, int v, int l, int r, int&amp; rt) { rt = newNode(rt); if(L &lt;= l &amp;&amp; r &lt;= R) { dat[rt].add(v, r - l + 1); return; } int m = l + r &gt;&gt; 1; if(L &lt;= m) update(L, R, v, l, m, dat[rt].ls); if(R &gt; m) update(L, R, v, m + 1, r, dat[rt].rs); up(rt, r - l + 1); } LL query1(int L, int R, LL z, int l, int r, int rt) { if(L &lt;= l &amp;&amp; r &lt;= R) return dat[rt].sum + z * (r - l + 1); int m = l + r &gt;&gt; 1; LL ret = 0; if(L &lt;= m) ret += query1(L, R, z + dat[rt].addv, l, m, dat[rt].ls); if(R &gt; m) ret += query1(L, R, z + dat[rt].addv, m + 1, r, dat[rt].rs); return ret; } LL query2(int L, int R, LL z, int l, int r, int rt) { if(L &lt;= l &amp;&amp; r &lt;= R) return dat[rt].minv + z; int m = l + r &gt;&gt; 1; LL ret = LLINF; if(L &lt;= m) ret = min(ret, query2(L, R, z + dat[rt].addv, l, m, dat[rt].ls)); if(R &gt; m) ret = min(ret, query2(L, R, z + dat[rt].addv, m + 1, r, dat[rt].rs)); return ret; } LL query3(int L, int R, LL z, int l, int r, int rt) { if(L &lt;= l &amp;&amp; r &lt;= R) return dat[rt].maxv + z; int m = l + r &gt;&gt; 1; LL ret = -LLINF; if(L &lt;= m) ret = max(ret, query3(L, R, z + dat[rt].addv, l, m, dat[rt].ls)); if(R &gt; m) ret = max(ret, query3(L, R, z + dat[rt].addv, m + 1, r, dat[rt].rs)); return ret; } } T; void dfs2(int u, int fa) { if(u == 1) { T.init(); T.build(1, n, root[1]); } else { root[u] = root[fa]; T.update(1, n, 1, 1, n, root[u]); T.update(L[u], R[u], -2, 1, n, root[u]); } for(int v : G[u]) { if(v == fa) continue; dfs2(v, u); } } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); while(scanf(&quot;%d%d&quot;, &amp;n, &amp;q) == 2) { for(int i = 1; i &lt;= n; ++i) G[i].clear(); for(int i = 1; i &lt; n; ++i) { int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); } dfsNum = 0; dfs(1, 0); dfs2(1, 0); LL last = 0; for(int z = 1; z &lt;= q; ++z) { int k, p, op; scanf(&quot;%d%d%d&quot;, &amp;k, &amp;p, &amp;op); p = (p + last) % n + 1; vector&lt;pair&lt;int, int&gt; &gt; seg(k); for(int i = 0; i &lt; k; ++i) { int x; scanf(&quot;%d&quot;, &amp;x); seg[i] = {L[x], R[x]}; } sort(seg.begin(), seg.end()); k = 0; for(int i = 0, j; i &lt; seg.size(); i = j) { int r = seg[i].second; for(j = i + 1; j &lt; seg.size() &amp;&amp; seg[j].first &lt;= seg[i].second; ++j) r = max(r, seg[j].second); seg[k++] = {seg[i].first, r}; } seg.resize(k); seg.push_back({n + 1, n + 1}); if(seg[0] == make_pair(1, n)) { puts(&quot;-1&quot;); last = 0; continue; } if(op == 1) { last = 0; for(int i = 0, l = 1; i &lt; seg.size(); ++i) { int r = seg[i].first - 1; if(l &lt;= r) { last += T.query1(l, r, 0, 1, n, root[p]); } l = seg[i].second + 1; } printf(&quot;%I64d\n&quot;, last); } else if(op == 2) { last = LLINF; for(int i = 0, l = 1; i &lt; seg.size(); ++i) { int r = seg[i].first - 1; if(l &lt;= r) { last = min(last, T.query2(l, r, 0, 1, n, root[p])); } l = seg[i].second + 1; } printf(&quot;%I64d\n&quot;, last); } else { last = -LLINF; for(int i = 0, l = 1; i &lt; seg.size(); ++i) { int r = seg[i].first - 1; if(l &lt;= r) { last = max(last, T.query3(l, r, 0, 1, n, root[p])); } l = seg[i].second + 1; } printf(&quot;%I64d\n&quot;, last); } } } return 0; }]]></content>
      <categories>
        <category>数据结构</category>
        <category>主席树</category>
      </categories>
      <tags>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5820 Lights（主席树）]]></title>
    <url>%2F2016%2F08%2F10%2FHDU%205820%20Lights%EF%BC%88%E4%B8%BB%E5%B8%AD%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $给定N\times N的网格图，N= 5\times 10^5，选中其中K\le 5\times 10^5个交叉点$$现判断对于任意2个交叉点之间，是否至少存在一条路径，使得这个路径的每个转弯都是交叉点$ 分析： $官方题解说的劲啊，实现一下就好了$$对于每个点(x, y)找它上面第一个点，下面第一个，以及左边第一个$$没有就给到边界上，求这个2个矩形的内部点数就好$ // // Created by TaoSama on 2016-08-10 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 5e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; const int C = 5e4; int n; vector&lt;int&gt; ps[C + 5]; int root[N]; struct PersistentSegTree { static const int M = N * 20; int sz; struct Node { int ls, rs, sum; } tree[M]; void init() { sz = 0; memset(&amp;tree[0], 0, sizeof tree[0]); } int newNode(int rt) { tree[++sz] = tree[rt]; return sz; } void update(int o, int v, int l, int r, int&amp; rt) { rt = newNode(rt); tree[rt].sum += v; if(l == r) return; int m = l + r &gt;&gt; 1; if(o &lt;= m) update(o, v, l, m, tree[rt].ls); else update(o, v, m + 1, r, tree[rt].rs); } int query(int L, int R, int l, int r, int rt) { if(L &lt;= l &amp;&amp; r &lt;= R) return tree[rt].sum; int m = l + r &gt;&gt; 1, ret = 0; if(L &lt;= m) ret += query(L, R, l, m, tree[rt].ls); if(R &gt; m) ret += query(L, R, m + 1, r, tree[rt].rs); return ret; } } T; int main() { #ifdef LOCAL // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;C:\\Users\\TaoSama\\Desktop\\1012.in&quot;, &quot;r&quot;, stdin); freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;, &quot;w&quot;, stdout); #endif ios_base::sync_with_stdio(0); while(scanf(&quot;%d&quot;, &amp;n) == 1 &amp;&amp; n) { vector&lt;int&gt; xs; for(int i = 1; i &lt;= C; ++i) ps[i].clear(); for(int i = 1; i &lt;= n; ++i) { int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); ps[x].push_back(y); } for(int i = 1; i &lt;= C; ++i) { auto&amp; v = ps[i]; if(!v.size()) continue; sort(v.begin(), v.end()); v.resize(unique(v.begin(), v.end()) - v.begin()); } T.init(); bool ok = true; vector&lt;int&gt; lastX(C + 1, 0); for(int x = 1; x &lt;= C &amp;&amp; ok; ++x) { root[x] = root[x - 1]; auto&amp; v = ps[x]; for(int i = 0; i &lt; v.size(); ++i) { int y = v[i]; int preX = lastX[y]; int preY = i - 1 &gt;= 0 ? v[i - 1] : 0; int nxtY = i + 1 &lt; v.size() ? v[i + 1] : C + 1; int num1 = T.query(preY + 1, nxtY - 1, 1, C, root[preX]); int num2 = T.query(preY + 1, nxtY - 1, 1, C, root[x - 1]); if(num1 != num2) {ok = false; break;} lastX[y] = x; T.update(y, 1, 1, C, root[x]); } } puts(ok ? &quot;YES&quot; : &quot;NO&quot;); } return 0; }]]></content>
      <categories>
        <category>数据结构</category>
        <category>主席树</category>
      </categories>
      <tags>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5812 Distance（数学、约数枚举）]]></title>
    <url>%2F2016%2F08%2F10%2FHDU%205812%20Distance%EF%BC%88%E6%95%B0%E5%AD%A6%E3%80%81%E7%BA%A6%E6%95%B0%E6%9E%9A%E4%B8%BE%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $维护1个集合S，d(x, y):=x经过多少次 乘/除素数 变成y$$给定Q\le 10^5个操作，有三种类型$$1 x:插入x，若x存在则无视$$2 x:删除x，若x不存在则无视$$3 x:求min_{y\in S} \{ d(x, y) \}$ 分析： $令f(x)=x中质因子的个数，首先发现d(x, y)=f(x/gcd(a, b))+f(y/gcd(a, b))$$所以我们可以枚举x的约数d，对于所有是d的倍数的y，求min\{ f(y/d) \}$$我们可以用multiset来维护(约数, 他的倍数的质因子个数)对$$对于每次插入x，枚举x的约数d，插入(d, f(x/d))即可，删除同理$$查询只需要枚举x的约数d，lower bound d对于的最小f(x/d)就好$$时间复杂度O(q\times max\{d(A_i)\})$ // // Created by TaoSama on 2016-08-09 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e6 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int q; vector&lt;int&gt; primes; int g[N]; void gao() { for(int i = 1; i &lt; N; ++i) g[i] = i; for(int i = 2; i &lt; N; ++i) { if(g[i] == i) primes.push_back(i); for(int j = 0; j &lt; primes.size() &amp;&amp; i * primes[j] &lt; N; ++j) { g[i * primes[j]] = primes[j]; if(i % primes[j] == 0) break; } } } vector&lt;int&gt; divisors[N]; vector&lt;pair&lt;int, int&gt; &gt; factors[N]; int cnt[N]; int factorize(int x) { if(cnt[x]) return cnt[x]; int y = x; auto&amp; v = factors[y]; while(x &gt; 1) { int t = g[x]; int e = 0; while(g[x] == t) ++e, x /= t; v.push_back({t, e}); cnt[y] += e; } return cnt[y]; } void dfs(int x, int k, int d) { if(k == factors[x].size()) { divisors[x].push_back(d); return; } dfs(x, k + 1, d); auto&amp; p = factors[x][k]; for(int i = 0; i &lt; p.second; ++i) { d *= p.first; dfs(x, k + 1, d); } } void decomp(int x) { if(divisors[x].size()) return; factorize(x); dfs(x, 0, 1); } bool vis[N]; multiset&lt;pair&lt;int, int&gt; &gt; mf; //number of factors of the number&#39;s multiple int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\1004.in&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;, &quot;w&quot;, stdout); #endif ios_base::sync_with_stdio(0); gao(); while(scanf(&quot;%d&quot;, &amp;q) == 1 &amp;&amp; q) { static int kase = 0; printf(&quot;Case #%d:\n&quot;, ++kase); mf.clear(); memset(vis, 0, sizeof vis); for(int i = 1; i &lt;= q; ++i) { char op[2]; int x; scanf(&quot;%s%d&quot;, op, &amp;x); if(*op == &#39;I&#39;) { if(vis[x]) continue; vis[x] = true; decomp(x); for(auto&amp; div : divisors[x]) { int num = factorize(x / div); mf.insert({div, num}); } } else if(*op == &#39;D&#39;) { if(!vis[x]) continue; vis[x] = false; decomp(x); for(auto&amp; div : divisors[x]) { int num = factorize(x / div); mf.erase(mf.find({div, num})); } } else { if(!mf.size()) { puts(&quot;-1&quot;); continue; } decomp(x); int ans = INF; for(auto&amp; div : divisors[x]) { auto iter = mf.lower_bound({div, -INF}); if(iter != mf.end() &amp;&amp; iter-&gt;first == div) { int num = factorize(x / div); ans = min(ans, num + iter-&gt;second); } } printf(&quot;%d\n&quot;, ans); } } } return 0; }]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>约数枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5811 Colosseo（拓扑排序、LIS）]]></title>
    <url>%2F2016%2F08%2F10%2FHDU%205811%20Colosseo%EF%BC%88%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E3%80%81LIS%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $给定N\le 10^3个人，给定拓扑关系，现将他们分为两个集合T1和T2$$问各自是否存在合法拓扑序，且在保证拓扑序的情况下，T2最多能添加多少人到T1中$ 分析： $先暴力对T1和T2求个拓扑序，之后倒着把T2往T1里尝试插入，记录下位置$$最后对这个位置求个LIS就是最多能添加的人数$$时间复杂度O(n^2)$ // // Created by TaoSama on 2016-08-10 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e3 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, m; bool g[N][N]; bool ok(vector&lt;int&gt;&amp; G, vector&lt;int&gt;&amp; seq) { seq = vector&lt;int&gt;(G.size(), 0); for(int x : G) { int s = 0; for(int y : G) s += g[x][y]; if(seq[s]) return false; seq[s] = x; } reverse(seq.begin(), seq.end()); return true; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;, &quot;w&quot;, stdout); #endif ios_base::sync_with_stdio(0); while(scanf(&quot;%d%d\n&quot;, &amp;n, &amp;m) == 2 &amp;&amp; (n || m)) { for(int i = 1; i &lt;= n; ++i) { char buf[N &lt;&lt; 1]; gets(buf + 1); for(int j = 1; buf[j]; j += 2) g[i][j / 2 + 1] = buf[j] - &#39;0&#39;; } vector&lt;int&gt; G[2]; vector&lt;int&gt; vis(n + 1, 0); for(int i = 1; i &lt;= m; ++i) { int x; scanf(&quot;%d&quot;, &amp;x); G[0].push_back(x); vis[x] = true; } for(int i = 1; i &lt;= n; ++i) if(!vis[i]) G[1].push_back(i); vector&lt;int&gt; seq[2]; if(ok(G[0], seq[0]) &amp;&amp; ok(G[1], seq[1])) { vector&lt;int&gt; pos(seq[1].size()); for(int i = 0; i &lt; seq[1].size(); ++i) { int x = seq[1][i]; int p = seq[0].size(); for(int j = seq[0].size() - 1; ~j; --j) { int y = seq[0][j]; if(g[x][y]) p = j; else break; } bool ok = true; for(int j = 0; j &lt; p &amp;&amp; ok; ++j) { int y = seq[0][j]; if(!g[y][x]) ok = false; } pos[i] = ok ? p : -1; } vector&lt;int&gt; dp(pos.size(), 0); for(int i = 0; i &lt; pos.size(); ++i) { if(pos[i] == -1) continue; dp[i] = 1; for(int j = 0; j &lt; i; ++j) if(pos[j] != -1 &amp;&amp; pos[i] &gt;= pos[j]) dp[i] = max(dp[i], dp[j] + 1); } printf(&quot;YES %d\n&quot;, *max_element(dp.begin(), dp.end())); } else puts(&quot;NO&quot;); } return 0; }]]></content>
      <categories>
        <category>图论</category>
        <category>拓扑排序</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4348 To the moon （主席树、标记永久化）]]></title>
    <url>%2F2016%2F08%2F09%2FHDU%204348%20To%20the%20moon%20%EF%BC%88%E4%B8%BB%E5%B8%AD%E6%A0%91%E3%80%81%E6%A0%87%E8%AE%B0%E6%B0%B8%E4%B9%85%E5%8C%96%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $给定N\le 10^5个数，Q\le 10^5询问，初始时间戳Timestamp=0$$C l r v:Timestamp+1，将[l, r]区间的数都+v$$Q l r:查询当前Timestamp的[l, r]区间和$$H l r t:查询历史Timestamp=t的[l, r]区间和，保证合法$$B t:回到历史Timestamp=t的时刻，保证合法，保证不会回到将来$ 分析： $卡空间所以打永久化lazy标记$$对于主席树继承更新的时候还是不要pushUp了，不然还要算lazy的$$对于查询的话，一路上把标记都加上，（一句话理解标记永久化系列$$话说好久没有画主席树来debug了，(大雾$ // // Created by TaoSama on 2016-08-08 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, q; typedef long long LL; int root[N]; struct PersistentSegTree { static const int M = 1e5 * 30; int sz; struct Node { int ls, rs, add; LL sum; } tree[M]; void init() { sz = 0; memset(&amp;tree[0], 0, sizeof tree[0]); } int newNode(int rt) { tree[++sz] = tree[rt]; return sz; } void up(int rt) { tree[rt].sum = tree[tree[rt].ls].sum + tree[tree[rt].rs].sum; } void build(int l, int r, int&amp; rt) { rt = newNode(0); if(l == r) { scanf(&quot;%I64d&quot;, &amp;tree[rt].sum); return; } int m = l + r &gt;&gt; 1; build(l, m, tree[rt].ls); build(m + 1, r, tree[rt].rs); up(rt); } void show(int l, int r, int rt) { pr(&quot;show&quot;); pr(rt); pr(l); pr(r); pr(tree[rt].add); prln(tree[rt].sum); if(l == r) return ; int m = l + r &gt;&gt; 1; show(l, m, tree[rt].ls); show(m + 1, r, tree[rt].rs); } void update(int L, int R, int v, int l, int r, int&amp; rt) { rt = newNode(rt); tree[rt].sum += v * (min(r, R) - max(l, L) + 1); if(L &lt;= l &amp;&amp; r &lt;= R) { tree[rt].add += v; return; } int m = l + r &gt;&gt; 1; if(L &lt;= m) update(L, R, v, l, m, tree[rt].ls); if(R &gt; m) update(L, R, v, m + 1, r, tree[rt].rs); } LL query(int L, int R, int l, int r, int rt) { if(L &lt;= l &amp;&amp; r &lt;= R) return tree[rt].sum; LL ret = 1LL * tree[rt].add * (min(r, R) - max(l, L) + 1); int m = l + r &gt;&gt; 1; if(L &lt;= m) ret += query(L, R, l, m, tree[rt].ls); if(R &gt; m) ret += query(L, R, m + 1, r, tree[rt].rs); return ret; } } T; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); while(scanf(&quot;%d%d&quot;, &amp;n, &amp;q) == 2) { T.init(); T.build(1, n, root[0]); int timStp = 0; while(q--) { char op[2]; scanf(&quot;%s&quot;, op); if(*op == &#39;C&#39;) { int l, r, d; scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;d); ++timStp; root[timStp] = root[timStp - 1]; // T.show(1, n, root[timStp]); T.update(l, r, d, 1, n, root[timStp]); } else if(*op == &#39;Q&#39;) { int l, r; scanf(&quot;%d%d&quot;, &amp;l, &amp;r); printf(&quot;%I64d\n&quot;, T.query(l, r, 1, n, root[timStp])); } else if(*op == &#39;H&#39;) { int l, r, t; scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;t); printf(&quot;%I64d\n&quot;, T.query(l, r, 1, n, root[t])); } else { scanf(&quot;%d&quot;, &amp;timStp); } } } return 0; }]]></content>
      <categories>
        <category>数据结构</category>
        <category>主席树</category>
      </categories>
      <tags>
        <tag>主席树</tag>
        <tag>标记永久化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces 231E Cactus（边双缩点、LCA）]]></title>
    <url>%2F2016%2F08%2F09%2FCodeForces%20231E%20Cactus%EF%BC%88%E8%BE%B9%E5%8F%8C%E7%BC%A9%E7%82%B9%E3%80%81LCA%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $给定一颗N\le 10^5个点的仙人掌，M\le 10^5条边$$仙人掌定义为：任意一个点至多属于一个简单环$$Q\le 10^5询问，(u, v)有多少条简单路径可达$ 分析： $考虑仙人掌的形态，任意2点之间的路径必然是由许多链和环构成$$一个环有2种走法，每经过一个环方法数\times 2$$那么问题转化为任意两点之间有多少简单环$$那么显然边双缩点，点权为0/1（如果bcc大小&gt;1）$$之后LCA求2点之间的路径长度就好，记得特判LCA$$答案ans=2^{环的个数}$ // // Created by TaoSama on 2016-08-07 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, m; vector&lt;int&gt; G[N], T[N]; int dfn[N], low[N], sz[N], id[N], bcc, dfsNum; int stk[N], top; void tarjan(int u, int f) { dfn[u] = low[u] = ++dfsNum; stk[++top] = u; for(int v : G[u]) { if(v == f) continue; if(!dfn[v]) { tarjan(v, u); low[u] = min(low[u], low[v]); } else low[u] = min(low[u], dfn[v]); } if(low[u] == dfn[u]) { ++bcc; while(true) { int v = stk[top--]; ++sz[bcc]; id[v] = bcc; if(v == u) break; } } } const int LOG = 17; int dep[N], dis[N], p[LOG][N]; void dfs(int u, int f) { p[0][u] = f; dis[u] = dis[f] + (sz[u] &gt; 1); for(int i = 1; i &lt; LOG; ++i) p[i][u] = p[i - 1][p[i - 1][u]]; for(int v : T[u]) { if(v == f) continue; dep[v] = dep[u] + 1; dfs(v, u); } } int lca(int u, int v) { if(dep[u] &gt; dep[v]) swap(u, v); for(int i = 0; i &lt; LOG; ++i) if(dep[v] - dep[u] &gt;&gt; i &amp; 1) v = p[i][v]; if(u == v) return u; for(int i = LOG - 1; ~i; --i) if(p[i][u] != p[i][v]) u = p[i][u], v = p[i][v]; return p[0][u]; } int get(int u, int v) { int g = lca(u, v); return dis[u] + dis[v] - 2 * dis[g] + (sz[g] &gt; 1); } void init() { bcc = dfsNum = 0; memset(dfn, 0, sizeof dfn); tarjan(1, -1); } int ksm(int x, int n) { int ret = 1; for(; n; n &gt;&gt;= 1) { if(n &amp; 1) ret = 1LL * ret * x % MOD; x = 1LL * x * x % MOD; } return ret; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= m; ++i) { int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); } init(); for(int i = 1; i &lt;= n; ++i) { int u = id[i]; for(int j : G[i]) { int v = id[j]; if(u == v) continue; T[u].push_back(v); } } dfs(1, 0); int q; scanf(&quot;%d&quot;, &amp;q); while(q--) { int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); int d = get(id[x], id[y]); int ans = ksm(2, d); printf(&quot;%d\n&quot;, ans); } return 0; }]]></content>
      <categories>
        <category>图论</category>
        <category>连通图</category>
      </categories>
      <tags>
        <tag>边双缩点</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5803 Zhu’s Math Problem（数位dp）]]></title>
    <url>%2F2016%2F08%2F08%2FHDU%205803%20Zhu%E2%80%99s%20Math%20Problem%EF%BC%88%E6%95%B0%E4%BD%8Ddp%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $给定A，B，C，D\in[1, 10^{18} ]$$求满足a+c&gt;b+d \cup a+d\ge b+c且a\in[0, A], b\in [0, B], c\in[0, C], d\in[0, D]$$的不同的四元组(a, b, c, d)个数$ 分析： $数位dp，每次转移4个数，开1个msk表示每个数被限制的情况$$加状态表示a+c&gt;b+d和a+d\ge b+c$$f[i][msk][f1][f2]:=从高到低第i位，状态如上的满足四元组个数$$分解成二进制来转移，仔细想想可以发现f1，f2\in[-2, 2]$$如果越界一定满足/不满足，所以就可以做了$$时间复杂度O(60\times 2^4\times 5\times 5\times 2^4)$ // // Created by TaoSama on 2016-08-08 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; typedef long long LL; LL a[4]; int f[61][1 &lt;&lt; 4][5][5]; //[-2, 2] inline void add(int&amp; x, int y) { if((x += y) &gt;= MOD) x -= MOD; } //a+c-b-d&gt;0 a+d-b-c&gt;=0 const int O = 2; //offset int dfs(int x, int msk, int f1, int f2) { if(x == -1) return f1 &gt; 0 &amp;&amp; f2 &gt;= 0; int&amp; ret = f[x][msk][f1 + O][f2 + O]; if(~ret) return ret; ret = 0; int to[4]; for(int i = 0; i &lt; 4; ++i) to[i] = (msk &gt;&gt; i &amp; 1) ? 1 : a[i] &gt;&gt; x &amp; 1; for(int a = 0; a &lt;= to[0]; ++a) { for(int b = 0; b &lt;= to[1]; ++b) { for(int c = 0; c &lt;= to[2]; ++c) { for(int d = 0; d &lt;= to[3]; ++d) { int newF1 = f1 * 2 + a + c - b - d; int newF2 = f2 * 2 + a + d - b - c; if(newF1 &lt; -2 || newF2 &lt; -2) continue; newF1 = min(newF1, 2); newF2 = min(newF2, 2); int newMsk = msk; if(a != to[0]) newMsk |= 1 &lt;&lt; 0; if(b != to[1]) newMsk |= 1 &lt;&lt; 1; if(c != to[2]) newMsk |= 1 &lt;&lt; 2; if(d != to[3]) newMsk |= 1 &lt;&lt; 3; add(ret, dfs(x - 1, newMsk, newF1, newF2)); } } } } return ret; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { for(int i = 0; i &lt; 4; ++i) scanf(&quot;%I64d&quot;, a + i); memset(f, -1, sizeof f); printf(&quot;%d\n&quot;, dfs(60, 0, 0, 0)); } return 0; }]]></content>
      <categories>
        <category>动态规划</category>
        <category>数位dp</category>
      </categories>
      <tags>
        <tag>数位dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5799 This world need more Zhu（树上莫队）]]></title>
    <url>%2F2016%2F08%2F08%2FHDU%205799%20This%20world%20need%20more%20Zhu%EF%BC%88%E6%A0%91%E4%B8%8A%E8%8E%AB%E9%98%9F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $给定一颗N\le 10^5个点的树，点权A_i\le 10^9，Q\le 10^5，询问形如op u v a b$$op=1时，u=v，查询子树u中，gcd(\sum_{cnt[x]=a} x, \sum_{cnt[y]=b} y)$$op=2时，查询路径(u, v)中，gcd(\sum_{cnt[x]=a} x, \sum_{cnt[y]=b} y)$ 分析： $op=1，dfs序搞成序列上的莫队，op=2树上莫队$$板题\times 2$ // // Created by TaoSama on 2016-08-08 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; const int B = 250; typedef long long LL; int n, m, a[N], b[N]; struct Edge { int v, nxt; } edge[N &lt;&lt; 1]; int head[N], eCnt; void addEdge(int u, int v) { edge[eCnt] = {v, head[u]}; head[u] = eCnt++; } int L[N], R[N], dep[N], fa[N], vs[N], dfsNum; int id[N], blocks; int stk[N], top; void dfs(int u, int f) { L[u] = ++dfsNum; vs[dfsNum] = u; fa[u] = f; int btm = top; for(int i = head[u]; ~i; i = edge[i].nxt) { int v = edge[i].v; if(v == f) continue; dep[v] = dep[u] + 1; dfs(v, u); if(top - btm &gt;= B) { ++blocks; while(top != btm) { int v = stk[top--]; id[v] = blocks; } } } R[u] = dfsNum; stk[++top] = u; } struct Query { int l, r, block, a, b, id; }; bool cmpSeq(const Query&amp; a, const Query&amp; b) { return a.block &lt; b.block || a.block == b.block &amp;&amp; a.r &lt; b.r; } bool cmpTree(const Query&amp; a, const Query&amp; b) { return id[a.l] &lt; id[b.l] || id[a.l] == id[b.l] &amp;&amp; L[a.r] &lt; L[b.r]; } int cnt[N]; LL sum[N], ans[N]; void add(int x) { sum[cnt[b[x]]] -= a[x]; ++cnt[b[x]]; sum[cnt[b[x]]] += a[x]; } void del(int x) { sum[cnt[b[x]]] -= a[x]; --cnt[b[x]]; sum[cnt[b[x]]] += a[x]; } bool in[N]; int cross; void reverse(int x) { if(in[x]) { in[x] = false; del(x); } else { in[x] = true; add(x); } } void moveUp(int&amp; x) { if(!cross) { if(in[x] &amp;&amp; !in[fa[x]]) cross = x; else if(in[fa[x]] &amp;&amp; !in[x]) cross = fa[x]; } reverse(x); x = fa[x]; } void move(int a, int b) { if(a == b) return; cross = 0; if(in[b]) cross = b; while(dep[a] &gt; dep[b]) moveUp(a); while(dep[b] &gt; dep[a]) moveUp(b); while(a != b) moveUp(a), moveUp(b); reverse(a); reverse(cross); } void gao() { dfsNum = blocks = 0; dfs(1, 0); while(top) id[stk[top--]] = blocks; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); vector&lt;int&gt; xs(n); for(int i = 1; i &lt;= n; ++i) { scanf(&quot;%d&quot;, a + i); xs[i - 1] = a[i]; } sort(xs.begin(), xs.end()); xs.resize(unique(xs.begin(), xs.end()) - xs.begin()); for(int i = 1; i &lt;= n; ++i) b[i] = lower_bound(xs.begin(), xs.end(), a[i]) - xs.begin() + 1; eCnt = 0; memset(head, -1, sizeof head); for(int i = 1; i &lt; n; ++i) { int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); addEdge(u, v); addEdge(v, u); } gao(); vector&lt;Query&gt; qs, qt; for(int i = 1; i &lt;= m; ++i) { int op, u, v, a, b; scanf(&quot;%d%d%d%d%d&quot;, &amp;op, &amp;u, &amp;v, &amp;a, &amp;b); if(op == 1) { int p = L[u] / B; qs.push_back({L[u], R[u], p, a, b, i}); } else { if(id[u] &gt; id[v]) swap(u, v); qt.push_back({u, v, -1, a, b, i}); } } { //subtree sort(qs.begin(), qs.end(), cmpSeq); memset(cnt, 0, sizeof cnt); memset(sum, 0, sizeof sum); int l = 1, r = 0; for(auto&amp; q : qs) { while(r &lt; q.r) add(vs[++r]); while(l &lt; q.l) del(vs[l++]); while(r &gt; q.r) del(vs[r--]); while(l &gt; q.l) add(vs[--l]); ans[q.id] = __gcd(sum[q.a], sum[q.b]); } } { //path sort(qt.begin(), qt.end(), cmpTree); memset(cnt, 0, sizeof cnt); memset(sum, 0, sizeof sum); memset(in, 0, sizeof in); add(1); in[1] = true; int l = 1, r = 0; for(auto&amp; q : qt) { move(l, q.l); move(r, q.r); l = q.l; r = q.r; ans[q.id] = __gcd(sum[q.a], sum[q.b]); } } static int kase = 0; printf(&quot;Case #%d:\n&quot;, ++kase); for(int i = 1; i &lt;= m; ++i) printf(&quot;%I64d\n&quot;, ans[i]); } return 0; }]]></content>
      <categories>
        <category>数据结构</category>
        <category>树上莫队</category>
      </categories>
      <tags>
        <tag>树上莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SPOJ Count on a tree II（树上莫队）]]></title>
    <url>%2F2016%2F08%2F08%2FSPOJ%20Count%20on%20a%20tree%20II%EF%BC%88%E6%A0%91%E4%B8%8A%E8%8E%AB%E9%98%9F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $给定一颗N\le 40000个点的树，点权A_i\le 10^9$$Q\le 10^5，询问(u, v)路径上有多少不同的点权$ 分析： $树上莫队板子题$$具体看集训队2013论文，《浅谈分块思想在一类数据处理问题中的应用》$$板子来自多校6的卿学姐博客题解代码$ // // Created by TaoSama on 2016-08-08 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; const int B = 200; int n, m, a[N], b[N]; struct Edge { int v, nxt; } edge[N &lt;&lt; 1]; int head[N], eCnt; void addEdge(int u, int v) { edge[eCnt] = {v, head[u]}; head[u] = eCnt++; } int L[N], R[N], dep[N], fa[N], vs[N], dfsNum; int id[N], blocks; int stk[N], top; void dfs(int u, int f) { L[u] = ++dfsNum; vs[dfsNum] = u; fa[u] = f; int btm = top; for(int i = head[u]; ~i; i = edge[i].nxt) { int v = edge[i].v; if(v == f) continue; dep[v] = dep[u] + 1; dfs(v, u); if(top - btm &gt;= B) { ++blocks; while(top != btm) { int v = stk[top--]; id[v] = blocks; } } } R[u] = dfsNum; stk[++top] = u; } struct Query { int l, r, id; }; bool cmpTree(const Query&amp; a, const Query&amp; b) { return id[a.l] &lt; id[b.l] || id[a.l] == id[b.l] &amp;&amp; L[a.r] &lt; L[b.r]; } int cnt[N]; int sum, ans[N]; void add(int x) { if(cnt[b[x]]++ == 0) ++sum; } void del(int x) { if(--cnt[b[x]] == 0) --sum; } bool in[N]; int cross; void reverse(int x) { if(in[x]) { in[x] = false; del(x); } else { in[x] = true; add(x); } } void moveUp(int&amp; x) { if(!cross) { if(in[x] &amp;&amp; !in[fa[x]]) cross = x; else if(in[fa[x]] &amp;&amp; !in[x]) cross = fa[x]; } reverse(x); x = fa[x]; } void move(int a, int b) { if(a == b) return; cross = 0; if(in[b]) cross = b; while(dep[a] &gt; dep[b]) moveUp(a); while(dep[b] &gt; dep[a]) moveUp(b); while(a != b) moveUp(a), moveUp(b); reverse(a); reverse(cross); } void gao() { dfsNum = blocks = 0; dfs(1, 0); while(top) id[stk[top--]] = blocks; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); vector&lt;int&gt; xs(n); for(int i = 1; i &lt;= n; ++i) { scanf(&quot;%d&quot;, a + i); xs[i - 1] = a[i]; } sort(xs.begin(), xs.end()); xs.resize(unique(xs.begin(), xs.end()) - xs.begin()); for(int i = 1; i &lt;= n; ++i) b[i] = lower_bound(xs.begin(), xs.end(), a[i]) - xs.begin() + 1; eCnt = 0; memset(head, -1, sizeof head); for(int i = 1; i &lt; n; ++i) { int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); addEdge(u, v); addEdge(v, u); } gao(); vector&lt;Query&gt; qt(m); for(int i = 1; i &lt;= m; ++i) { int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); if(id[u] &gt; id[v]) swap(u, v); qt[i - 1] = {u, v, i}; } sort(qt.begin(), qt.end(), cmpTree); sum = 0; memset(cnt, 0, sizeof cnt); memset(in, 0, sizeof in); add(1); in[1] = true; int l = 1, r = 0; for(auto&amp; q : qt) { move(l, q.l); move(r, q.r); l = q.l; r = q.r; ans[q.id] = sum; } for(int i = 1; i &lt;= m; ++i) printf(&quot;%d\n&quot;, ans[i]); return 0; }]]></content>
      <categories>
        <category>数据结构</category>
        <category>树上莫队</category>
      </categories>
      <tags>
        <tag>树上莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ 1086 王室联邦（块状树）]]></title>
    <url>%2F2016%2F08%2F08%2FBZOJ%201086%20%E7%8E%8B%E5%AE%A4%E8%81%94%E9%82%A6%EF%BC%88%E5%9D%97%E7%8A%B6%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $给定一颗N\le 1000个点的树$$要求将这棵树分成一些块，使每块大小在[B, 3B]之间，1\le B\le N$ 分析： $PO娘的博客讲的很清楚辣，手把手教你块状树$传送门 // // Created by TaoSama on 2016-08-08 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e3 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, B; vector&lt;int&gt; G[N]; int stk[N], top; int blocks, id[N], rt[N]; void dfs(int u, int f) { int btm = top; for(int i = 0; i &lt; G[u].size(); ++i) { int v = G[u][i]; if(v == f) continue; dfs(v, u); if(top - btm &gt;= B) { rt[++blocks] = u; while(top != btm) { int v = stk[top--]; id[v] = blocks; } } } stk[++top] = u; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); scanf(&quot;%d%d&quot;, &amp;n, &amp;B); for(int i = 1; i &lt; n; ++i) { int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); } dfs(1, 0); while(top) id[stk[top--]] = blocks; printf(&quot;%d\n&quot;, blocks); for(int i = 1; i &lt;= n; ++i) printf(&quot;%d%c&quot;, id[i], &quot; \n&quot;[i == n]); for(int i = 1; i &lt;= blocks; ++i) printf(&quot;%d%c&quot;, rt[i], &quot; \n&quot;[i == blocks]); return 0; }]]></content>
      <categories>
        <category>数据结构</category>
        <category>树上莫队</category>
      </categories>
      <tags>
        <tag>树上莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 3364 Lanterns（线性基）]]></title>
    <url>%2F2016%2F08%2F06%2FHDU%203364%20Lanterns%EF%BC%88%E7%BA%BF%E6%80%A7%E5%9F%BA%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N\le 50个灯，M\le 50个开关，每个开关控制一些灯$$Q\le 1000次询问，给定N个灯的状态，查询方法数$ 分析： $开关问题，直接暴力复杂度O(qn^2m)就算不压位都跑得飞快$$当然反过来，对每个开关构建矩阵，高斯消元求出线性基$$之后对于每个状态只要判断能否组合成就可以了$$压位之后，时间复杂度O({ n^2m \over 64 }+qn)$ 代码一（线性基）: // // Created by TaoSama on 2016-07-28 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 50 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, m; typedef long long LL; LL a[N]; int xorGauss(int n, int m) { int r = 0, c = 0; for(; r &lt; n &amp;&amp; c &lt; m; ++r, ++c) { int p = r; for(; p &lt; n; ++p) if(a[p] &gt;&gt; c &amp; 1) break; if(p == n) {--r; continue;} swap(a[p], a[r]); for(int i = 0; i &lt; n; ++i) { if(i != r) { if(a[i] &gt;&gt; c &amp; 1) a[i] ^= a[r]; } } } return r; } bool check(LL x, LL rnk) { LL mix = 0; int r = 0, c = 0; for(; r &lt; rnk &amp;&amp; c &lt; m; ++c) { bool have = mix &gt;&gt; c &amp; 1; bool need = x &gt;&gt; c &amp; 1; if(have == need) continue; bool ok = false; if(need) { while(r &lt; rnk &amp;&amp; !ok) { if(a[r] &gt;&gt; c &amp; 1) { mix ^= a[r]; ok = true; } ++r; } } if(!ok) return false; } return mix == x; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); clock_t _ = clock(); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%d%d&quot;, &amp;m, &amp;n); for(int i = 0; i &lt; n; ++i) { a[i] = 0; int cnt = 0; scanf(&quot;%d&quot;, &amp;cnt); while(cnt--) { int x; scanf(&quot;%d&quot;, &amp;x); a[i] |= 1LL &lt;&lt; x - 1; } } int r = xorGauss(n, m); static int kase = 0; printf(&quot;Case %d:\n&quot;, ++kase); int q; scanf(&quot;%d&quot;, &amp;q); while(q--) { LL target = 0; for(int i = 0; i &lt; m; ++i) { int x; scanf(&quot;%d&quot;, &amp;x); if(x) target |= 1LL &lt;&lt; i; } LL ans = check(target, r) ? 1LL &lt;&lt; n - r : 0; printf(&quot;%I64d\n&quot;, ans); } } #ifdef LOCAL printf(&quot;\nTime cost: %.2fs\n&quot;, 1.0 * (clock() - _) / CLOCKS_PER_SEC); #endif return 0; } 代码二（暴力）： // // Created by TaoSama on 2016-07-28 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 50 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, m; int a[N][N], b[N][N]; int xorGauss(int n, int m) { int r = 0, c = 0; for(; r &lt; n &amp;&amp; c &lt; m; ++r, ++c) { int p = r; for(; p &lt; n; ++p) if(a[p][c]) break; if(p == n) {--r; continue;} swap(a[p], a[r]); for(int i = 0; i &lt; n; ++i) { if(i != r &amp;&amp; a[i][c]) { for(int j = c; j &lt;= m; ++j) a[i][j] ^= a[r][j]; } } } for(int i = r; i &lt; n; ++i) if(a[i][m]) return -1; return m - r; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); clock_t _ = clock(); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); memset(b, 0, sizeof b); for(int j = 0; j &lt; m; ++j) { int k; scanf(&quot;%d&quot;, &amp;k); while(k--) { int x; scanf(&quot;%d&quot;, &amp;x); --x; b[x][j] = 1; } } static int kase = 0; printf(&quot;Case %d:\n&quot;, ++kase); int q; scanf(&quot;%d&quot;, &amp;q); while(q--) { memcpy(a, b, sizeof b); for(int i = 0; i &lt; n; ++i) scanf(&quot;%d&quot;, a[i] + m); int freeX = xorGauss(n, m); long long tot = ~freeX ? 1LL &lt;&lt; freeX : 0; printf(&quot;%I64d\n&quot;, tot); } } #ifdef LOCAL printf(&quot;\nTime cost: %.2fs\n&quot;, 1.0 * (clock() - _) / CLOCKS_PER_SEC); #endif return 0; }]]></content>
      <categories>
        <category>数学</category>
        <category>高斯消元</category>
      </categories>
      <tags>
        <tag>线性基</tag>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4418 Time travel（高斯消元解期望dp）]]></title>
    <url>%2F2016%2F08%2F06%2FHDU%204418%20Time%20travel%EF%BC%88%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E8%A7%A3%E6%9C%9F%E6%9C%9Bdp%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $给定N\le 100长度的路，这个路是来回走的$$比如4个点，0, 1, 2, 3, 2, 1, 0, 1, …$$给定每次最大步数M，以及每个步数x\in[1, M]行走的概率p_x，保证\sum p_x=1$$给定起点x，终点y，以及方向d，0正着1反着$$求到达终点的期望步数$ 分析： $测了下数据里并没有d=-1，这傻叉题d=-1根本不知道是干嘛的，无视就行了$$来回走的周期cycle=2n-2，所以d=1把起点x映射一下x=(cycle-x)\%cycle$$dp状态是f[i]:=i点到达终点的期望步数$$f[i]=\sum p_j\times (f[(i+j)\%cycle]+j)$$之后bfs一下，求出每个点的可达性，然后对于每个点建立方程$$注意终点有2个就行，高斯消元一波就做完了$$时间复杂度O(n^3)$ 代码: // // Created by TaoSama on 2016-07-29 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 200 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; const double EPS = 1e-8; int sgn(double x) { return x &lt; -EPS ? -1 : x &gt; EPS; } int n, m, y, x, d; double p[N]; double a[N][N], ans[N]; bool isFreeX[N]; void getAns(int n, int m, int r) { // memset(ans, 0, sizeof ans); //not necessary for(int i = r - 1; ~i; --i) { for(int j = 0; j &lt; m; ++j) { if(!sgn(a[i][j])) continue; ans[j] = a[i][m]; for(int k = j + 1; k &lt; m; ++k) ans[j] -= a[i][k] * ans[k]; ans[j] = ans[j] / a[i][j]; break; } } } int gauss(int n, int m) { for(int i = 0; i &lt; m; ++i) isFreeX[i] = false; int r = 0, c = 0; for(; r &lt; n &amp;&amp; c &lt; m; ++r, ++c) { int maxR = r; //row transform for(int i = r + 1; i &lt; n; ++i) if(abs(a[i][c]) &gt; abs(a[maxR][c])) maxR = i; if(maxR != r) swap(a[maxR], a[r]); if(!sgn(a[r][c])) { --r; isFreeX[c] = true; continue;} //eliminate coefficient for(int i = r + 1; i &lt; n; ++i) { if(sgn(a[i][c])) { double delta = a[i][c] / a[r][c]; for(int j = c; j &lt;= m; ++j) a[i][j] -= delta * a[r][j]; } } } for(int i = r; i &lt; n; i++) if(sgn(a[i][m])) return -1; getAns(n, m, r); //at last, r is rank, m - r is the number of freeX return r; } bool can[N]; bool bfs(int sx) { memset(can, 0, sizeof can); queue&lt;int&gt; q; q.push(sx); can[sx] = true; bool ok = false; while(q.size()) { int u = q.front(); q.pop(); if(u == y || u == (n - y) % n) ok = true; for(int i = 1; i &lt;= m; ++i) { if(!sgn(p[i])) continue; int v = (u + i) % n; if(can[v]) continue; can[v] = true; q.push(v); } } return ok; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); clock_t _ = clock(); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%d%d%d%d%d&quot;, &amp;n, &amp;m, &amp;y, &amp;x, &amp;d); for(int i = 1; i &lt;= m; ++i) { int x; scanf(&quot;%d&quot;, &amp;x); p[i] = x / 100.0; } n = 2 * n - 2; // 0,1,2,3,2,1 =&gt; 0,1,2,3,4,5 //start coincides with destination if(n == 0) {puts(&quot;0.00&quot;); continue;} if(d &gt; 0) x = (n - x) % n; if(!bfs(x)) {puts(&quot;Impossible !&quot;); continue;} memset(a, 0, sizeof a); //E_i = sum((E_j + j)*P_j) =&gt; E_i - sum(E_j*P_j) = sum(j*P_j) for(int i = 0; i &lt; n; ++i) { if(i == y || i == (n - y) % n) { a[i][i] = 1; a[i][n] = 0; //E_destination = 0; continue; } a[i][i] = 1; for(int j = 1; j &lt;= m; ++j) { if(!sgn(p[j])) continue; int x = (i + j) % n; if(!can[x]) continue; a[i][x] -= p[j]; a[i][n] += j * p[j]; } } gauss(n, n); printf(&quot;%.2f\n&quot;, ans[x]); } #ifdef LOCAL printf(&quot;\nTime cost: %.2fs\n&quot;, 1.0 * (clock() - _) / CLOCKS_PER_SEC); #endif return 0; }]]></content>
      <categories>
        <category>数学</category>
        <category>高斯消元</category>
      </categories>
      <tags>
        <tag>期望dp</tag>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 3949 XOR（线性基、kth异或和）]]></title>
    <url>%2F2016%2F08%2F06%2FHDU%203949%20XOR%EF%BC%88%E7%BA%BF%E6%80%A7%E5%9F%BA%E3%80%81kth%E5%BC%82%E6%88%96%E5%92%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $给定N\le 10^5个数，1\le A_i\le 10^{18}，Q\le 10^5询问$$选择一个非空子集可以得到一个异或和，对于所有的不同的异或和$$每次询问第1\le K\le 10^{18}小的是多少$ 分析： $先求出线性基，并且同时也得到了矩阵的秩r，即r个线性基$$那么r个线性基，能表示的数的个数有2^r-1个（非空）$$如果r\neq n，说明异或出0了，那么最小值必然为0，特判这种情况$$对于其他情况直接将k二进制分解，求出这个数即可$ 代码: // // Created by TaoSama on 2016-07-27 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, q; typedef long long LL; LL a[N]; int xorGauss() { int r = 0, c = 63; for(; r &lt; n &amp;&amp; ~c; ++r, --c) { int p = r; for(; p &lt; n; ++p) if(a[p] &gt;&gt; c &amp; 1) break; if(p == n) {--r; continue;} swap(a[p], a[r]); for(int i = 0; i &lt; n; ++i) { if(i != r) { if(a[i] &gt;&gt; c &amp; 1) a[i] ^= a[r]; } } } return r; //rank } LL kth(LL k, int r) { if(r != n) --k; // if(k &gt;= 1LL &lt;&lt; r) return -1; LL ret = 0; for(int i = 0; i &lt; 64; ++i) if(k &gt;&gt; i &amp; 1) ret ^= a[r - i - 1]; return ret; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); clock_t _ = clock(); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%d&quot;, &amp;n); for(int i = 0; i &lt; n; ++i) scanf(&quot;%I64d&quot;, a + i); int r = xorGauss(); static int kase = 0; printf(&quot;Case #%d:\n&quot;, ++kase); scanf(&quot;%d&quot;, &amp;q); while(q--) { LL k; scanf(&quot;%I64d&quot;, &amp;k); printf(&quot;%I64d\n&quot;, kth(k, r)); } } #ifdef LOCAL printf(&quot;\nTime cost: %.2fs\n&quot;, 1.0 * (clock() - _) / CLOCKS_PER_SEC); #endif return 0; }]]></content>
      <categories>
        <category>数学</category>
        <category>高斯消元</category>
      </categories>
      <tags>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高斯消元小结]]></title>
    <url>%2F2016%2F08%2F05%2F%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Ⅰ. 高斯消元认知 $这东西英文名叫Gaussian Elimination$ $高斯消元对矩阵进行操作，对满足一定运算规律的方程利用矩阵初等变换进行消元$ $主要用来求解线性方程组、矩阵的秩、以及可逆方阵的逆矩阵$ $还可以用来线性空间的基向量，比如线性基（线性无关的极大子集）$ $PS:关于线性相关，具体可以读2014集训队论文《浅谈线性相关》$ Ⅱ. 高斯消元模版浮点数高斯消元double a[N][N], ans[N]; bool isFreeX[N]; void getAns(int n, int m, int r) { // memset(ans, 0, sizeof ans); //not necessary for(int i = r - 1; ~i; --i) { for(int j = 0; j &lt; m; ++j) { if(!sgn(a[i][j])) continue; ans[j] = a[i][m]; for(int k = j + 1; k &lt; m; ++k) ans[j] -= a[i][k] * ans[k]; ans[j] = ans[j] / a[i][j]; break; } } } int gauss(int n, int m) { for(int i = 0; i &lt; m; ++i) isFreeX[i] = false; int r = 0, c = 0; for(; r &lt; n &amp;&amp; c &lt; m; ++r, ++c) { int maxR = r; //row transform for(int i = r + 1; i &lt; n; ++i) if(abs(a[i][c]) &gt; abs(a[maxR][c])) maxR = i; if(maxR != r) swap(a[maxR], a[r]); if(!sgn(a[r][c])) { --r; isFreeX[c] = true; continue;} //eliminate coefficient for(int i = r + 1; i &lt; n; ++i) { if(sgn(a[i][c])) { double delta = a[i][c] / a[r][c]; for(int j = c; j &lt;= m; ++j) a[i][j] -= delta * a[r][j]; } } } for(int i = r; i &lt; n; i++) if(sgn(a[i][m])) return -1; getAns(n, m, r); //at last, r is rank, m - r is the number of freeX return r; } 模意义下高斯消元int a[N][N], ans[N]; bool isFreeX[N]; inline int inv(int x) {return 1;} int getAns(int n, int m, int r) { int ret = 0; for(int i = r - 1; ~i; --i) { for(int j = 0; j &lt; m; ++j) { if(!a[i][j]) continue; ans[j] = a[i][m]; for(int k = j + 1; k &lt; m; ++k) { ans[j] -= a[i][k] * ans[k]; ans[j] %= MOD; if(ans[j] &lt; 0) ans[j] += MOD; } ans[j] = ans[j] * inv(a[i][j]) % MOD; break; } } for(int i = 0; i &lt; m; ++i) ret += ans[i]; return ret; } int gauss(int n, int m) { for(int i = 0; i &lt; m; ++i) isFreeX[i] = false; int r = 0, c = 0; for(; r &lt; n &amp;&amp; c &lt; m; ++r, ++c) { int maxR = r; //row transform for(int i = r + 1; i &lt; n; ++i) if(abs(a[i][c]) &gt; abs(a[maxR][c])) maxR = i; if(maxR != r) swap(a[maxR], a[r]); if(!a[r][c]) { --r; isFreeX[c] = true; continue;} //eliminate coefficient for(int i = r + 1; i &lt; n; ++i) { if(a[i][c]) { int delta = a[i][c] * inv(a[r][c]); for(int j = c; j &lt;= m; ++j) { a[i][j] -= delta * a[r][j]; a[i][j] %= MOD; if(a[i][j] &lt; 0) a[i][j] += MOD; } } } } for(int i = r; i &lt; n; i++) if(a[i][m]) return -1; //at last, r is rank, m - r is the number of freeX return r; } int getMinAns(int n, int m, int r) { int ret = INF, freeX = m - r; for(int s = 0; s &lt; 1 &lt;&lt; freeX; ++s) { if(__builtin_popcount(s) &gt;= ret) continue; int cnt = 0; for(int j = 0; j &lt; m; ++j) { if(isFreeX[j]) { ans[j] = s &gt;&gt; cnt &amp; 1; ++cnt; } } ret = min(ret, getAns(n, m, r)); } return ret; } XOR高斯消元int a[N][N], ans[N]; int xorGauss() { int r = 0, c = 0; for(; r &lt; n &amp;&amp; c &lt; n; ++r, ++c) { int p = r; for(; p &lt; n; ++p) if(a[p][c]) break; if(p == n) {--r; continue;} swap(a[p], a[r]); for(int i = 0; i &lt; n; ++i) { if(i != r &amp;&amp; a[i][c]) { for(int j = c; j &lt;= n; ++j) a[i][j] ^= a[r][j]; } } } for(int i = r; i &lt; n; ++i) if(a[i][n]) return -1; //memset(ans, 0, sizeof ans); //not necessary for(int i = r - 1; ~i; --i) for(int j = 0; j &lt; n; ++j) if(a[i][j]) {ans[j] = a[i][n]; break;} return r; } Ⅲ. 题目讲解HDU 4200 Bad Wiring分析:$开关问题，POJ的几个数据都比较弱，所以就选了这个$$建立模2意义下的方程组，然后高斯消元，要求最小解，二进制枚举自由变元回代即可$代码： // // Created by TaoSama on 2016-07-28 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 100 + 10, INF = 0x3f3f3f3f, MOD = 2; int n, d; int a[N][N], ans[N]; bool isFreeX[N]; inline int inv(int x) {return 1;} int getAns(int n, int m, int r) { int ret = 0; for(int i = r - 1; ~i; --i) { for(int j = 0; j &lt; m; ++j) { if(!a[i][j]) continue; ans[j] = a[i][m]; for(int k = j + 1; k &lt; m; ++k) { ans[j] -= a[i][k] * ans[k]; ans[j] %= MOD; if(ans[j] &lt; 0) ans[j] += MOD; } ans[j] = ans[j] * inv(a[i][j]) % MOD; break; } } for(int i = 0; i &lt; m; ++i) ret += ans[i]; return ret; } int gauss(int n, int m) { for(int i = 0; i &lt; m; ++i) isFreeX[i] = false; int r = 0, c = 0; for(; r &lt; n &amp;&amp; c &lt; m; ++r, ++c) { int maxR = r; //row transform for(int i = r + 1; i &lt; n; ++i) if(abs(a[i][c]) &gt; abs(a[maxR][c])) maxR = i; if(maxR != r) swap(a[maxR], a[r]); if(!a[r][c]) { --r; isFreeX[c] = true; continue;} //eliminate coefficient for(int i = r + 1; i &lt; n; ++i) { if(a[i][c]) { int delta = a[i][c] * inv(a[r][c]); for(int j = c; j &lt;= m; ++j) { a[i][j] -= delta * a[r][j]; a[i][j] %= MOD; if(a[i][j] &lt; 0) a[i][j] += MOD; } } } } for(int i = r; i &lt; n; i++) if(a[i][m]) return -1; //at last, r is rank, m - r is the number of freeX return r; } int getMinAns(int n, int m, int r) { int ret = INF, freeX = m - r; for(int s = 0; s &lt; 1 &lt;&lt; freeX; ++s) { if(__builtin_popcount(s) &gt;= ret) continue; int cnt = 0; for(int j = 0; j &lt; m; ++j) { if(isFreeX[j]) { ans[j] = s &gt;&gt; cnt &amp; 1; ++cnt; } } ret = min(ret, getAns(n, m, r)); } return ret; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); clock_t _ = clock(); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%d%d&quot;, &amp;n, &amp;d); memset(a, 0, sizeof a); for(int i = 0; i &lt; n; ++i) { int v; scanf(&quot;%d&quot;, &amp;v); a[i][n] = -v + MOD; for(int j = max(0, i - d); j &lt;= min(n - 1, i + d); ++j) a[i][j] = 1; } int r = gauss(n, n); if(~r) printf(&quot;%d\n&quot;, getMinAns(n, n, r)); else puts(&quot;impossible&quot;); } #ifdef LOCAL printf(&quot;\nTime cost: %.2fs\n&quot;, 1.0 * (clock() - _) / CLOCKS_PER_SEC); #endif return 0; } SGU 275 To xor or not to xor分析：$求N个数的子集的最大异或和，高斯消元后求出的是极大线性无关组即线性基$$线性基异或起来显然就是最大异或和了$代码： // // Created by TaoSama on 2016-07-28 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; typedef long long LL; int n; LL a[N]; int xorGauss() { int r = 0, c = 63; for(; r &lt; n &amp;&amp; ~c; ++r, --c) { int p = r; for(; p &lt; n; ++p) if(a[p] &gt;&gt; c &amp; 1) break; if(p == n) {--r; continue;} swap(a[p], a[r]); for(int i = 0; i &lt; n; ++i) if(i != r &amp;&amp; a[i] &gt;&gt; c &amp; 1) a[i] ^= a[r]; } return r; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); clock_t _ = clock(); scanf(&quot;%d&quot;, &amp;n); for(int i = 0; i &lt; n; ++i) scanf(&quot;%lld&quot;, a + i); int r = xorGauss(); LL ans = 0; for(int i = 0; i &lt; r; ++i) ans ^= a[i]; printf(&quot;%lld\n&quot;, ans); #ifdef LOCAL printf(&quot;\nTime cost: %.2fs\n&quot;, 1.0 * (clock() - _) / CLOCKS_PER_SEC); #endif return 0; } HDU 2262 Where is the canteen分析：$高斯消元求解期望dp$$f[x][y]:=(x, y)到终点的期望次数，显然终点的期望是0，即f[ex][ey]=0$$期望倒推，f[x][y]=(\sum p_i\times f[nx][ny]) + 1$$bfs求出每个点的可达性，之后对于每个点建立期望方程，然后高斯消元求解即可$代码： // // Created by TaoSama on 2016-07-28 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 15 * 15 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; const double EPS = 1e-8; int sgn(double x) { return x &lt; -EPS ? -1 : x &gt; EPS; } int n, m; char s[N][N]; double a[N][N], ans[N]; bool isFreeX[N]; void getAns(int n, int m, int r) { // memset(ans, 0, sizeof ans); //not necessary for(int i = r - 1; ~i; --i) { for(int j = 0; j &lt; m; ++j) { if(!sgn(a[i][j])) continue; ans[j] = a[i][m]; for(int k = j + 1; k &lt; m; ++k) ans[j] -= a[i][k] * ans[k]; ans[j] = ans[j] / a[i][j]; break; } } } int gauss(int n, int m) { for(int i = 0; i &lt; m; ++i) isFreeX[i] = false; int r = 0, c = 0; for(; r &lt; n &amp;&amp; c &lt; m; ++r, ++c) { int maxR = r; //row transform for(int i = r + 1; i &lt; n; ++i) if(abs(a[i][c]) &gt; abs(a[maxR][c])) maxR = i; if(maxR != r) swap(a[maxR], a[r]); if(!sgn(a[r][c])) { --r; isFreeX[c] = true; continue;} //eliminate coefficient for(int i = r + 1; i &lt; n; ++i) { if(sgn(a[i][c])) { double delta = a[i][c] / a[r][c]; for(int j = c; j &lt;= m; ++j) a[i][j] -= delta * a[r][j]; } } } for(int i = r; i &lt; n; i++) if(sgn(a[i][m])) return -1; getAns(n, m, r); //at last, r is rank, m - r is the number of freeX return r; } inline int ID(int x, int y) { return x * m + y; } bool can[N][N]; const int d[][2] = { -1, 0, 0, -1, 1, 0, 0, 1}; bool bfs(int sx, int sy) { memset(can, 0, sizeof can); queue&lt;pair&lt;int, int&gt; &gt; q; q.push({sx, sy}); can[sx][sy] = true; bool ok = false; while(q.size()) { auto u = q.front(); q.pop(); int x, y; tie(x, y) = u; if(s[x][y] == &#39;$&#39;) ok = true; for(int i = 0; i &lt; 4; ++i) { int nx = x + d[i][0], ny = y + d[i][1]; if(nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= m) continue; if(s[nx][ny] == &#39;#&#39; || can[nx][ny]) continue; can[nx][ny] = true; q.push({nx, ny}); } } return ok; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); clock_t _ = clock(); while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) == 2) { int sx, sy; sx = sy = -1; for(int i = 0; i &lt; n; ++i) { scanf(&quot;%s&quot;, s[i]); if(~sx) continue; for(int j = 0; j &lt; m; ++j) if(s[i][j] == &#39;@&#39;) sx = i, sy = j; } if(!bfs(sx, sy)) {puts(&quot;-1&quot;); continue;} //E_i = sum(E_j)/cnt + 1 =&gt; sum(E_j) - cnt*E_i = -cnt memset(a, 0, sizeof a); for(int i = 0; i &lt; n; ++i) { for(int j = 0; j &lt; m; ++j) { if(s[i][j] == &#39;#&#39;) continue; //obstacle if(s[i][j] == &#39;$&#39;) { //destination a[ID(i, j)][ID(i, j)] = 1; a[ID(i, j)][n * m] = 0; //E_exit = 0; continue; } int cnt = 0; for(int k = 0; k &lt; 4; ++k) { int x = i + d[k][0], y = j + d[k][1]; if(x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= m || !can[x][y]) continue; ++cnt; a[ID(i, j)][ID(x, y)] = 1; } a[ID(i, j)][ID(i, j)] = -cnt; a[ID(i, j)][n * m] = -cnt; } } // for(int i = 0; i &lt; n * m; ++i) // for(int j = 0; j &lt;= n * m; ++j) // printf(&quot;%.3f%c&quot;, a[i][j], &quot; \n&quot;[j == n * m]); gauss(n * m, n * m); double result = ans[ID(sx, sy)]; printf(&quot;%.6f\n&quot;, result); } #ifdef LOCAL printf(&quot;\nTime cost: %.2fs\n&quot;, 1.0 * (clock() - _) / CLOCKS_PER_SEC); #endif return 0; }]]></content>
      <categories>
        <category>小结</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HDU 5755 Gambler Bo（高斯消元）]]></title>
    <url>%2F2016%2F08%2F05%2FHDU%205755%20Gambler%20Bo%EF%BC%88%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $给定N\times M的矩阵，N，M\le 30，每个格子里的数A_{ij}\in [0, 3)$$每次可以按一个格子，使得这个格子+2，上下左右4个格子+1，数加完后会模3$$输出1个可以使得所有格子都变成0的操作，保证数据有解$ 分析： $对N\times M个格子建立方程，每个格子含有5个变元$$高斯消元解方程，打印解即可$$时间复杂度O((NM)^3)$ 代码: // // Created by TaoSama on 2016-07-26 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 30 * 30 + 10, INF = 0x3f3f3f3f, MOD = 3; int n, m, val[N]; int a[N][N], ans[N]; bool isFreeX[N]; inline int inv(int x) {return x;} void getAns(int n, int m, int r) { for(int i = r - 1; ~i; --i) { for(int j = 0; j &lt; m; ++j) { if(!a[i][j]) continue; ans[j] = a[i][m]; for(int k = j + 1; k &lt; m; ++k) { ans[j] -= a[i][k] * ans[k]; ans[j] %= MOD; if(ans[j] &lt; 0) ans[j] += MOD; } ans[j] = ans[j] * inv(a[i][j]) % MOD; break; } } } int gauss(int n, int m) { for(int i = 0; i &lt; m; ++i) isFreeX[i] = false; int r = 0, c = 0; for(; r &lt; n &amp;&amp; c &lt; m; ++r, ++c) { int maxR = r; //row transform for(int i = r + 1; i &lt; n; ++i) if(abs(a[i][c]) &gt; abs(a[maxR][c])) maxR = i; if(maxR != r) swap(a[maxR], a[r]); if(!a[r][c]) { --r; isFreeX[c] = true; continue;} //eliminate coefficient for(int i = r + 1; i &lt; n; ++i) { if(a[i][c]) { int delta = a[i][c] * inv(a[r][c]); for(int j = c; j &lt;= m; ++j) { a[i][j] -= delta * a[r][j]; a[i][j] %= MOD; if(a[i][j] &lt; 0) a[i][j] += MOD; } } } } for(int i = r; i &lt; n; i++) if(a[i][m]) return -1; getAns(n, m, r); //at last, r is rank, m - r is the number of freeX return r; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); clock_t _ = clock(); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); memset(a, 0, sizeof a); for(int i = 0; i &lt; n * m; ++i) { scanf(&quot;%d&quot;, val + i); int x = i / m, y = i % m; a[i][i] = 2; static int d[][2] = { -1, 0, 0, -1, 1, 0, 0, 1}; for(int j = 0; j &lt; 4; ++j) { int nx = x + d[j][0], ny = y + d[j][1]; if(nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= m) continue; a[i][nx * m + ny] = 1; } a[i][n * m] = -val[i] + MOD; } gauss(n * m, n * m); vector&lt;pair&lt;int, int&gt; &gt; v; for(int i = 0; i &lt; n * m; ++i) { int x = i / m, y = i % m; // printf(&quot;%d, %d : %d\n&quot;, x, y, ans[i]); while(ans[i]--) { v.push_back({x + 1, y + 1}); // static int d[][2] = { -1, 0, 0, -1, 1, 0, 0, 1}; // val[i] = (val[i] + 2) % MOD; // for(int j = 0; j &lt; 4; ++j) { // int nx = x + d[j][0], ny = y + d[j][1]; // if(nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= m) continue; // val[nx * m + ny] ++; // val[nx * m + ny] %= MOD; // } } } // if(count(val, val + n * m, 0) != n * m) puts(&quot;WA&quot;); // else puts(&quot;AC&quot;); printf(&quot;%d\n&quot;, v.size()); for(auto&amp; p : v) printf(&quot;%d %d\n&quot;, p.first, p.second); } #ifdef LOCAL printf(&quot;\nTime cost: %.2fs\n&quot;, 1.0 * (clock() - _) / CLOCKS_PER_SEC); #endif return 0; }]]></content>
      <categories>
        <category>数学</category>
        <category>高斯消元</category>
      </categories>
      <tags>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5769 Substring（后缀数组）]]></title>
    <url>%2F2016%2F08%2F05%2FHDU%205769%20Substring%EF%BC%88%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $给定N\le 10^5的字符串，求包含一个特定字母X的不同子串的个数$ 分析： $考虑不带特定字母的版本，对于每个后缀sa[i]的贡献是n-sa[i]-height[i]$$由于必须包含X，所以对于每个sa[i]，记录一下之后最近的X的位置nxt[sa[i]]$$那么贡献应该是n-nxt[sa[i]]，两者取min就好了$$即n-max(nxt[sa[i]], sa[i]+height[i])为每个sa[i]的贡献$ 代码: // // Created by TaoSama on 2016-08-01 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n; char str[N], x[2]; int s[N], c[N], t[2][N]; int sa[N], rk[N], height[N]; // sa[0] is empty suffix, 1 ~ n // height[i]:= lcp of sa[i-1] and sa[i] void build(int n, int m) { int i, k, p, *x = t[0], *y = t[1]; memset(c, 0, m &lt;&lt; 2); for(i = 0; i &lt; n; ++i) ++c[x[i] = s[i]]; for(i = 1; i &lt; m; ++i) c[i] += c[i - 1]; for(i = n - 1; i &gt;= 0; --i) sa[--c[x[i]]] = i; for(k = 1; k &lt;= n; k &lt;&lt;= 1) { p = 0; for(i = n - k; i &lt; n; ++i) y[p++] = i; for(i = 0; i &lt; n; ++i) if(sa[i] &gt;= k) y[p++] = sa[i] - k; memset(c, 0, m &lt;&lt; 2); for(i = 0; i &lt; n; ++i) ++c[x[y[i]]]; for(i = 1; i &lt; m; ++i) c[i] += c[i - 1]; for(i = n - 1; i &gt;= 0; --i) sa[--c[x[y[i]]]] = y[i]; swap(x, y); p = 1; x[sa[0]] = 0; for(i = 1; i &lt; n; ++i) x[sa[i]] = (y[sa[i - 1]] == y[sa[i]] &amp;&amp; y[sa[i - 1] + k] == y[sa[i] + k]) ? p - 1 : p++; if(p &gt;= n) break; m = p; } for(i = 0; i &lt; n; ++i) rk[sa[i]] = i; for(i = 0, k = 0; i &lt; n; ++i) { if(k) k--; if(!rk[i]) continue; int j = sa[rk[i] - 1]; while(s[i + k] == s[j + k]) k++; height[rk[i]] = k; } } void see(int n) { for(int i = 0; i &lt; n; ++i) printf(&quot;%d: %s\n&quot;, i, str + sa[i]); printf(&quot;sa: &quot;); for(int i = 0; i &lt; n; ++i) printf(&quot;%d &quot;, sa[i]); puts(&quot;&quot;); printf(&quot;rk: &quot;); for(int i = 0; i &lt; n; ++i) printf(&quot;%d &quot;, rk[i]); puts(&quot;&quot;); printf(&quot;ht: &quot;); for(int i = 0; i &lt; n; ++i) printf(&quot;%d &quot;, height[i]); puts(&quot;&quot;); } int nxt[N]; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%s%s&quot;, x, str); n = strlen(str); for(int i = 0; i &lt; n; ++i) s[i] = str[i] - &#39;a&#39; + 1; s[n] = 0; build(n + 1, 30); // see(n + 1); nxt[n] = n; for(int i = n - 1; ~i; --i) { nxt[i] = nxt[i + 1]; if(str[i] == *x) nxt[i] = i; } long long ans = 0; for(int i = 1; i &lt;= n; ++i) { ans += n - max(nxt[sa[i]], sa[i] + height[i]); } static int kase = 0; printf(&quot;Case #%d: %I64d\n&quot;, ++kase, ans); } return 0; }]]></content>
      <categories>
        <category>字符串</category>
        <category>SA/SAM</category>
      </categories>
      <tags>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5772 String problem（最大权闭合子图）]]></title>
    <url>%2F2016%2F08%2F05%2FHDU%205772%20String%20problem%EF%BC%88%E6%9C%80%E5%A4%A7%E6%9D%83%E9%97%AD%E5%90%88%E5%AD%90%E5%9B%BE%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $懒得翻译题目了 - -$ 分析： $最大权闭合子图详细见胡波涛的论文$$建图就源向正权点连边，容量是正权，负权就负权点向汇连边，容量是负权的绝对值$$对于原图中依赖关系，保留在网络流图中，容量是INF$$答案是\sum 正权-最小割$ 本题，官方题解写的很清楚了 代码: // // Created by TaoSama on 2016-08-02 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; const int M = 1e6 + 10; //必须添加超源超汇 0-&gt;s n+1-&gt;t //特判起终点相同的情况 -&gt; WA struct Edge { int v, nxt, cap, flow; } edge[M]; int head[N], cnt; void addEdge(int u, int v, int c1) { edge[cnt] = {v, head[u], c1, 0}; head[u] = cnt++; edge[cnt] = {u, head[v], 0, 0}; head[v] = cnt++; } int lev[N], cur[N]; bool bfs(int s, int t) { queue&lt;int&gt; q; memset(lev, 0, sizeof lev); q.push(s); lev[s] = 1; while(q.size() &amp;&amp; !lev[t]) { int u = q.front(); q.pop(); for(int i = head[u]; ~i; i = edge[i].nxt) { int v = edge[i].v; if(edge[i].cap &gt; edge[i].flow &amp;&amp; !lev[v]) { lev[v] = lev[u] + 1; q.push(v); } } } return lev[t]; } int dfs(int u, int t, int delta) { if(u == t || !delta) return delta; int ret = 0; for(int i = cur[u]; ~i; i = edge[i].nxt) { int v = edge[i].v; if(edge[i].cap &gt; edge[i].flow &amp;&amp; lev[v] == lev[u] + 1) { int d = dfs(v, t, min(delta, edge[i].cap - edge[i].flow)); cur[u] = i; ret += d; delta -= d; edge[i].flow += d; edge[i ^ 1].flow -= d; if(delta == 0) return ret; } } lev[u] = 0; return ret; } int dinic(int s, int t) { int ret = 0; while(bfs(s, t)) { for(int i = s; i &lt;= t; ++i) cur[i] = head[i]; ret += dfs(s, t, INF); } return ret; } const int C = 100; int n, a[C], b[C]; char str[C]; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); int T; scanf(&quot;%d&quot;, &amp;T); while(T--) { scanf(&quot;%d%s&quot;, &amp;n, str + 1); for(int i = 0; i &lt;= 9; ++i) scanf(&quot;%d%d&quot;, a + i, b + i); cnt = 0; memset(head, -1, sizeof head); int s = 0, t = n * n + n + 10 + 1; //w_ij: 1~n^2 s_i: n^2+1 ~ n^2+n //10: n^2+n+1 ~ n^2+n+10 int sum = 0; int delta[] = {0, n * n, n* n + n}; for(int i = 0; i &lt; 10; ++i) addEdge(delta[2] + i + 1, t, -(a[i] - b[i])); //10 -&gt; t for(int i = 1; i &lt;= n; ++i) { addEdge(delta[1] + i, t, a[str[i] - &#39;0&#39;]); //s_i -&gt; t addEdge(delta[1] + i, delta[2] + str[i] - &#39;0&#39; + 1, INF); //s_i -&gt; 10 for(int j = 1; j &lt;= n; ++j) { int w; scanf(&quot;%d&quot;, &amp;w); sum += w; addEdge(s, (i - 1) * n + j, w); //s -&gt; w_ij if(i == j) continue; addEdge((i - 1) * n + j, delta[1] + i, INF); //w_ij -&gt; s_i addEdge((i - 1) * n + j, delta[1] + j, INF); //w_ij -&gt; s_j } } static int kase = 0; printf(&quot;Case #%d: %d\n&quot;, ++kase, sum - dinic(s, t)); } return 0; }]]></content>
      <categories>
        <category>图论</category>
        <category>网络流</category>
      </categories>
      <tags>
        <tag>最大权闭合子图</tag>
        <tag>最小割</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5768 Lucky7（容斥、CRT）]]></title>
    <url>%2F2016%2F08%2F05%2FHDU%205768%20Lucky7%EF%BC%88%E5%AE%B9%E6%96%A5%E3%80%81CRT%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $给定0&lt;L &lt; R &lt; 10^{18}，给定N\le 15个非法条件$$即x\%p_i=a_i，a_i&lt;p_i\le 10^5，\prod p_i\le 10^{18}$$求[L, R]区间内能被7整除，且合法的数字的个数$ 分析： $非法条件有15个，显然的容斥一下，对于每个条件窝萌可以用CRT算出个数$$但是这里有被7整除的条件，不如把这个条件当作强制条件$$之后把全集变成模7域下的全集，即[L, R]整除7的数的个数tot$$最后ans=tot-容斥的结果$$时间复杂度O(n\times 2^n\times nlogC)$ 代码: // // Created by TaoSama on 2016-07-28 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; typedef long long LL; LL exgcd(LL a, LL b, LL&amp; x, LL&amp; y) { LL g = a; if(!b) x = 1, y = 0; else { g = exgcd(b, a % b, y, x); y -= a / b * x; } return g; } int n; LL x, y; LL a[N], b[N], m[N]; int r[N], p[N]; pair&lt;LL, LL&gt; excrt(int n, LL* a, LL* b, LL* m) { LL B = 0, M = 1; for(int i = 1; i &lt;= n; ++i) { LL A = (M * a[i]) % m[i], c = (b[i] - B * a[i]) % m[i]; LL x, y, g = exgcd(A, m[i], x, y); if(c % g) return { -1, -1}; x = c / g * x % (m[i] / g); B += x * M; M *= m[i] / g; B %= M; } B = (B + M) % M; if(!B) B = M; return {B, M}; } LL calc(LL x, LL B, LL M) { LL ret = x &gt;= B; ret += (x - B) / M; return ret; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); clock_t _ = clock(); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%d%I64d%I64d&quot;, &amp;n, &amp;x, &amp;y); for(int i = 0; i &lt; n; ++i) scanf(&quot;%d%d&quot;, p + i, r + i); LL no = 0; for(int s = 1; s &lt; 1 &lt;&lt; n; ++s) { int idx = 0; for(int i = 0; i &lt; n; ++i) { if(s &gt;&gt; i &amp; 1) { ++idx; a[idx] = 1; b[idx] = r[i]; m[idx] = p[i]; } } ++idx; a[idx] = 1, b[idx] = 0, m[idx] = 7; auto ret = excrt(idx, a, b, m); LL B, M; tie(B, M) = ret; // pr(s); pr(B); prln(M); LL tmp = calc(y, B, M) - calc(x - 1, B, M); if(idx - 1 &amp; 1) no += tmp; else no -= tmp; } // prln(no); LL ans = (y / 7) - (x - 1) / 7 - no; static int kase = 0; printf(&quot;Case #%d: %I64d\n&quot;, ++kase, ans); } #ifdef LOCAL printf(&quot;\nTime cost: %.2fs\n&quot;, 1.0 * (clock() - _) / CLOCKS_PER_SEC); #endif return 0; }]]></content>
      <categories>
        <category>数学</category>
        <category>CRT</category>
      </categories>
      <tags>
        <tag>容斥</tag>
        <tag>CRT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5741 Helter Skelter（数形结合、二分）]]></title>
    <url>%2F2016%2F08%2F05%2FHDU%205741%20Helter%20Skelter%EF%BC%88%E6%95%B0%E5%BD%A2%E7%BB%93%E5%90%88%E3%80%81%E4%BA%8C%E5%88%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $给定一个压缩过的0开头的01交替字符串，比如00110表示为\{ 2, 2, 1 \}$$表示数字个数N\le 1000，x_i \le 10^6，Q\le 5\times 10^5次查询$$每次给定a, b，问是否存在原串的子串0有a个，1有b个$ 分析： $我们把所有的a和b n^2枚举一下，如果把这些(a, b)表示在二维平面上$$手玩一下可以发现[0\ldots 0]这种子串表示出来的(a, b)必然在图形的下部$$也可以发现[1\ldots 1]这种子串表示出来的(a, b)必然在图形的下部$$还可以发现图形是连通且封闭的，现在窝萌可以把这个图形抠出来一个凸包$$假设这些下部点是红点，上部点是绿点，其它点是蓝点$$画出一个图，然后根据性质抠一下就好了$$红点在竖线的底端，绿点在竖线的顶端$$之后对于每个询问，只要二分一下a，得到b的下界和上界，即可知道是否合法$$时间复杂度O(n^2+qlogn^2)$ 代码: // // Created by TaoSama on 2016-07-25 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e3 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, m, a[N]; char ans[N * N]; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); clock_t _ = clock(); /* | ___B | G ___| | | ___| _____| |___| | | _____| R | | ___|___|_____________ 0| */ int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 0; i &lt; n; ++i) scanf(&quot;%d&quot;, a + i); vector&lt;pair&lt;int, int&gt; &gt; up, dw; for(int i = 0; i &lt; n; ++i) { int zero = 0, one = 0; for(int j = i; j &lt; n; ++j) { if(j % 2 == 0) zero += a[j]; else one += a[j]; //red points if(i % 2 == 0 &amp;&amp; j % 2 == 0) dw.push_back({zero, one}); //green points if(i % 2 == 1 &amp;&amp; j % 2 == 1) up.push_back({zero, one}); } } sort(dw.begin(), dw.end()); sort(up.begin(), up.end()); n = 0; //erase blues points, save lower red points for(int i = 0, j; i &lt; dw.size(); i = j) { //jump vertical line for(j = i; j &lt; dw.size() &amp;&amp; dw[j].first == dw[i].first; ++j); //pop upper ones, save this lowest one while(n &gt; 0 &amp;&amp; dw[n - 1].second &gt;= dw[i].second) --n; dw[n++] = dw[i]; } dw.resize(n); n = 0; //erase blues points, save upper green points for(int i = 0, j; i &lt; up.size(); i = j) { //go vertical line&#39;s top for(j = i; j &lt; up.size() &amp;&amp; up[j].first == up[i].first; ++j); //if upper if(!n || up[j - 1].second &gt;= up[n - 1].second) up[n++] = up[j - 1]; } up.resize(n); for(int i = 0; i &lt; m; ++i) { int a, b; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); auto st = lower_bound(dw.begin(), dw.end(), make_pair(a, -INF)); auto ed = upper_bound(up.begin(), up.end(), make_pair(a, +INF)); ans[i] = &#39;0&#39;; if(st != dw.end()) { --ed; if(b &gt;= st-&gt;second &amp;&amp; b &lt;= ed-&gt;second) ans[i] = &#39;1&#39;; } } ans[m] = 0; puts(ans); } #ifdef LOCAL printf(&quot;\nTime cost: %.2fs\n&quot;, 1.0 * (clock() - _) / CLOCKS_PER_SEC); #endif return 0; } /* dw: 3 0 up: 0 4 dw: 3 0 4 2 up: 0 2 dw: 3 0 4 2 6 3 7 7 8 11 10 12 up: 0 7 1 8 2 9 3 12 4 16 7 18 8 19 */]]></content>
      <categories>
        <category>思维</category>
        <category>数形结合</category>
      </categories>
      <tags>
        <tag>数形结合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5790 Prefix（字典树、主席树）]]></title>
    <url>%2F2016%2F08%2F05%2FHDU%205790%20Prefix%EF%BC%88%E5%AD%97%E5%85%B8%E6%A0%91%E3%80%81%E4%B8%BB%E5%B8%AD%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N\le 10^5个字符串，保证\sum |L_i|\le 10^5，Q\le 10^5次询问$$在线查询[L, R]区间有多少个不同的前缀$ 分析： $- - 求区间有多少个不同的数的套路$$考虑离线的做法，询问右端点排序$$字典树插入每个字符串i，记录每个前缀上次哪里出现$$然后上次-1，这次+1，对于每个以i为右端点的询问答案就是sum(L, i)$$这题强制在线，只要可持久化一下就好了$$时间复杂度O(\sum |L|+qlogn)$ 代码: // // Created by TaoSama on 2016-08-03 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, q; char s[N]; int root[N]; struct PersistentSegTree { static const int M = 1e5 * 40; int sz; struct Node { int ls, rs, sum; } tree[M]; void init() { sz = 0; root[0] = 0; } int newNode(int rt) { tree[++sz] = tree[rt]; return sz; } void update(int o, int v, int l, int r, int&amp; rt) { rt = newNode(rt); tree[rt].sum += v; if(l == r) return; int m = l + r &gt;&gt; 1; if(o &lt;= m) update(o, v, l, m, tree[rt].ls); else update(o, v, m + 1, r, tree[rt].rs); } int query(int L, int R, int l, int r, int rt) { if(L &lt;= l &amp;&amp; r &lt;= R) return tree[rt].sum; int m = l + r &gt;&gt; 1, ret = 0; if(L &lt;= m) ret += query(L, R, l, m, tree[rt].ls); if(R &gt; m) ret += query(L, R, m + 1, r, tree[rt].rs); return ret; } } T; struct Trie { static const int M = 1e5 + 10, S = 26; int sz, rt, nxt[M][S]; int val[M]; int newNode() { val[sz] = 0; memset(nxt[sz], 0, sizeof nxt[sz]); return sz++; } void init() { sz = 0; rt = newNode(); } void insert(char* s, int id) { int u = rt; for(int i = 0; s[i]; ++i) { int&amp; v = nxt[u][s[i] - &#39;a&#39;]; if(!v) v = newNode(); if(val[v]) T.update(val[v], -1, 1, n, root[id]); val[v] = id; T.update(val[v], 1, 1, n, root[id]); u = v; } } } trie; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); while(scanf(&quot;%d&quot;, &amp;n) == 1) { T.init(); trie.init(); for(int i = 1; i &lt;= n; ++i) { scanf(&quot;%s&quot;, s); root[i] = root[i - 1]; trie.insert(s, i); } int z = 0; scanf(&quot;%d&quot;, &amp;q); while(q--) { int l, r; scanf(&quot;%d%d&quot;, &amp;l, &amp;r); l = (z + l) % n + 1; r = (z + r) % n + 1; if(l &gt; r) swap(l, r); z = T.query(l, n, 1, n, root[r]); printf(&quot;%d\n&quot;, z); } } return 0; }]]></content>
      <categories>
        <category>数据结构</category>
        <category>主席树</category>
      </categories>
      <tags>
        <tag>主席树</tag>
        <tag>字典树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5787 K-wolf Number（数位dp）]]></title>
    <url>%2F2016%2F08%2F05%2FHDU%205787%20K-wolf%20Number%EF%BC%88%E6%95%B0%E4%BD%8Ddp%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $求1\le L\le R\le 10^{18}范围内，每2\le K\le 5个数字都不同的数字有多少$ 分析： $显然数位dp一下就做完了$$f[i][pre][5]:=从高到低，填到第i位，且之前的数字是pre，pre已经有1\sim 4位数合法数字数$$由于不能有前导0，所以开个first判一判，其他套个板子就好了$ 代码: // // Created by TaoSama on 2016-08-02 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e4 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; typedef long long LL; LL l, r, f[20][N][5]; int k; const int ten[] = {1, 10, 100, 1000, 10000, 100000}; int get(int x, int i) { return x / ten[i] % 10; } int add(int x, int y) { return (x * 10 + y) % ten[k - 1]; } int digit[20]; LL dfs(int i, int pre, int num, bool first, bool e) { if(!i) return 1; if(!e &amp;&amp; ~f[i][pre][num]) return f[i][pre][num]; LL ret = 0; int to = e ? digit[i] : 9; for(int d = 0; d &lt;= to; ++d) { bool ok = true; for(int j = 0; j &lt; min(k - 1, num) &amp;&amp; ok; ++j) if(get(pre, j) == d) ok = false; if(!ok) continue; ret += dfs(i - 1, first &amp;&amp; !d ? 0 : add(pre, d), first &amp;&amp; !d ? 0 : min(k - 1, num + 1), first &amp;&amp; !d, e &amp;&amp; d == to); } return e ? ret : f[i][pre][num] = ret; } LL calc(LL x) { int cnt = 0; for(; x; x /= 10) digit[++cnt] = x % 10; return dfs(cnt, 0, 0, 1, 1); } bool judge(int x, int k) { int cnt = 0; for(; x; x /= 10) digit[++cnt] = x % 10; for(int i = 1; i &lt;= cnt; ++i) { bool ok = true; for(int j = 1; j &lt; k; ++j) { if(i - j &gt;= 1 &amp;&amp; digit[i] == digit[i - j]) { ok = false; break; } } if(!ok) return false; } return true; } int sum[1000005]; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); // for(k = 2; k &lt;= 5; ++k) { // memset(f, -1, sizeof f); // for(int i = 1; i &lt;= 10000; ++i) { // sum[i] = sum[i - 1] + judge(i, k); // if(sum[i] + 1 != calc(i)) { // printf(&quot;%d: %d %I64d %d\n&quot;, i, sum[i] + 1, calc(i), k); // printf(&quot;WA\n&quot;); // break; // } // } // } while(scanf(&quot;%I64d%I64d%d&quot;, &amp;l, &amp;r, &amp;k) == 3) { memset(f, -1, sizeof f); LL ans = calc(r) - calc(l - 1); printf(&quot;%I64d\n&quot;, ans); } return 0; }]]></content>
      <categories>
        <category>动态规划</category>
        <category>数位dp</category>
      </categories>
      <tags>
        <tag>数位dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5794 A Simple Chess（dp、容斥、Lucas）]]></title>
    <url>%2F2016%2F08%2F05%2FHDU%205794%20A%20Simple%20Chess%EF%BC%88dp%E3%80%81%E5%AE%B9%E6%96%A5%E3%80%81Lucas%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $给定N\times M的棋盘，N，M\le 10^{18}，棋盘上有R\le 100个障碍物$$现有一个马从(1, 1)到(N, M)，只能向右和下走，问方法数$ 分析： $考虑到达(x, y)没有障碍物的方法数，其实假设右跳a次，下跳b次$$即2a+b=x, a+2b=y, \Rightarrow a + b = { x + y \over 3 }$$即a=x - { x + y \over 3 }, b = y - { x + y \over 3 }$$显然方法数是C_{a+b}^a$$不过泥打表找规律发现杨辉三角，找到有解的直线方程转化也是兹磁的，(窝萌是这么干的)$$之后就是容斥了，把经过障碍物的减掉$$首先对障碍物排序，然后dp一波根据偏序关系来$$令全集ans=calc(n, m)$$f[i]:=到达i，且以i为第一个障碍物的方法数$$最终答案必然是ans=ans-\sum f[i]\times calc(n-obstacle[i].x+1, m-obstacle[i].y+1)$$显然每个f[i]是互斥事件，因为这些路径是不重复的，注意那个第一个(这个是统计套路。。$$并且所有经过障碍物的路径必然被其中一个f[i]包含$$所以所有的f[i]构成经过障碍物的全集$$f[i]=calc(obstacle[i].x, obstacle[i].y)$$-\sum f[j]\times calc(obstacle[i].x-obstacle[j].x+1, obstacle[i].y-obstacle[j].y+1)$$obstacle[j]偏序小于obstacle[i]$$注意判断不可达别用0，因为会模出来0，$→_→$时间复杂度O(P+r^2 log P)$ 代码: // // Created by TaoSama on 2016-08-04 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 2e5 + 10, INF = 0x3f3f3f3f, MOD = 110119; typedef long long LL; LL n, m, ox[N], oy[N]; int r; LL g[1005][1005]; void DP() { memset(g, 0, sizeof(g)); g[1][1] = 1; for(int j = 1; j &lt;= n; j++) { for(int k = 1; k &lt;= m; k++) { int ok = 1; for(int i = 1; i &lt;= r; i++) { if(j == ox[i] &amp;&amp; k == oy[i]) { ok = 0; break; } } //if(!ok) printf(&quot;NO\n&quot;); if(!ok) { g[j][k] = 0; continue; } g[j + 1][k + 2] += g[j][k]; g[j + 2][k + 1] += g[j][k]; g[j + 1][k + 2] %= MOD; g[j + 2][k + 1] %= MOD; } } } LL quick(LL x, LL n) { LL ret = 1; for(; n; n &gt;&gt;= 1) { if(n &amp; 1) ret = ret * x % MOD; x = x * x % MOD; } return ret; } LL fact[N], invf[N]; void gao() { fact[0] = invf[0] = 1; for(int i = 1; i &lt;= MOD; ++i) { fact[i] = fact[i - 1] * i % MOD; invf[i] = quick(fact[i], MOD - 2); } } LL C(int n, int m) { if(n &lt; m) return 0; return fact[n] * invf[m] % MOD * invf[n - m] % MOD; } LL lucas(LL n, LL m) { if(m == 0) return 1; return C(n % MOD, m % MOD) * lucas(n / MOD, m / MOD) % MOD; } LL calc(LL x, LL y) { LL n = x + y + 1; if(n % 3) return -1; n /= 3; if(x &lt; n || y &lt; n) return -1; LL m = x - n; n--; return lucas(n, m); } int id[N]; LL f[N]; //to i, and let i be the first obstacle int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;, &quot;w&quot;, stdout); #endif ios_base::sync_with_stdio(0); gao(); while(scanf(&quot;%I64d%I64d%d&quot;, &amp;n, &amp;m, &amp;r) == 3) { for(int i = 1; i &lt;= r; ++i) scanf(&quot;%I64d%I64d&quot;, ox + i, oy + i); for(int i = 1; i &lt;= r; ++i) id[i] = i; sort(id + 1, id + 1 + r, [&amp;](int x, int y) { return make_pair(ox[x], oy[x]) &lt; make_pair(ox[y], oy[y]); }); LL ans = calc(n, m); if(~ans) { for(int i = 1; i &lt;= r; ++i) { int u = id[i]; LL&amp; cur = f[i]; cur = calc(ox[u], oy[u]); if(cur == -1) continue; LL to = calc(n - ox[u] + 1, m - oy[u] + 1); if(to == -1) continue; for(int j = 1; j &lt; i; ++j) { if(f[j] == -1) continue; int v = id[j]; if(ox[u] &gt; ox[v] &amp;&amp; oy[u] &gt; oy[v]) { LL tmp = calc(ox[u] - ox[v] + 1, oy[u] - oy[v] + 1); if(tmp == -1) continue; cur -= f[j] * tmp % MOD; cur %= MOD; } } ans = (ans - cur * to % MOD) % MOD; } } else ans = 0; ans = (ans + MOD) % MOD; // DP(); // if(g[n][m] != ans) { // puts(&quot;WA&quot;); // pr(g[n][m]); prln(ans); // } static int kase = 0; printf(&quot;Case #%d: %I64d\n&quot;, ++kase, ans); } return 0; } /* 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 4 0 0 0 2 0 0 1 0 0 0 0 0 0 0 0 0 0 0 5 0 0 1 0 0 3 0 0 1 0 0 0 0 0 0 0 0 0 6 0 0 0 0 3 0 0 4 0 0 1 0 0 0 0 0 0 0 7 0 0 0 1 0 0 6 0 0 5 0 0 1 0 0 0 0 0 8 0 0 0 0 0 4 0 0 10 0 0 6 0 0 1 0 0 0 9 0 0 0 0 1 0 0 10 0 0 15 0 0 7 0 0 1 0 10 0 0 0 0 0 0 5 0 0 20 0 0 21 0 0 8 0 0 11 0 0 0 0 0 1 0 0 15 0 0 35 0 0 28 0 0 9 12 0 0 0 0 0 0 0 6 0 0 35 0 0 56 0 0 36 0 13 0 0 0 0 0 0 1 0 0 21 0 0 70 0 0 84 0 0 14 0 0 0 0 0 0 0 0 7 0 0 56 0 0 126 0 0 120 15 0 0 0 0 0 0 0 1 0 0 28 0 0 126 0 0 210 0 16 0 0 0 0 0 0 0 0 0 8 0 0 84 0 0 252 0 0 17 0 0 0 0 0 0 0 0 1 0 0 36 0 0 210 0 0 462 18 0 0 0 0 0 0 0 0 0 0 9 0 0 120 0 0 462 0 */]]></content>
      <categories>
        <category>数学</category>
        <category>容斥</category>
      </categories>
      <tags>
        <tag>容斥</tag>
        <tag>Lucas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5785 Interesting（Manacher | 回文树）]]></title>
    <url>%2F2016%2F08%2F04%2FHDU%205785%20Interesting%EF%BC%88Manacher%20%20%E5%9B%9E%E6%96%87%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $给定N\le 10^6的字符串，现在寻找所有三元组(i, j, k)，1\le i\le j&lt;k\le N$$使得s[i\ldots j]和s[j+1\ldots k]都是回文串，求\sum\sum i\times k mod 10^9+7$ 分析： $赛上做法比较那啥，回文树硬肝的，a、b为某2个回文串长度$$[i\ldots j-1]、[j\ldots k]$$\sum\sum i\times k=\sum\sum (j-1-a+1)(j+b-1)$$=\sum\sum (j-a)(j+b-1)$$=preCnt\times sufCnt\times j^2$$+(preCnt\times (sufSum-sufCnt)-preSum\times sufCnt)j$$-preSum\times(sufSum-sufCnt)$$preCnt[i]:=以i结尾的回文串个数，preSum[i]:=以i结尾的回文串的长度和$$suf同理$$然后回文树预处理一下就做完了，时间复杂度O(n)$ $\sum\sum i\times k=\sum i\times \sum k$$Manacher的话直接预处理sum[2][i]:=0开头，1结尾的右/左端点的和$$对于一个以i为中心的延伸距离为p[i]的最长回文串$$显然l=i-(p[i]-1)，r=i+p[i]-1$$对于sum[0][i]，i\in[l, i]右端点的贡献是r\sim i$$这是一个首项为r，公差为-1的等差数列$$由于所有更新都是静态的，窝萌可以partial sum搞一波$$对于一个更新[L, R]，首项为a，公差为d的等差数列$$delta数组记录公差，sum数组记录结果$delta[L+1] += d // [L+1, R]的区间有公差delta[R+1] -= dsum[L] += asum[R+1] -= a + (R-L)*d //这里要去掉公差累计的影响$累计的时候累计上公差就可以了$$直接在Manacher数组上搞就行，最后除2就好$$然后就做完了$ 代码一: // // Created by TaoSama on 2016-08-02 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e6 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; struct PalindromicTree { static const int M = 1e6 + 10, S = 26; int n, sz, last; int nxt[M][S], fail[M], len[M]; char s[M]; int cnt[M], sum[M]; int newnode(int l) { len[sz] = l; sum[sz] = cnt[sz] = 0; memset(nxt[sz], 0, sizeof(nxt[sz])); return sz++; } void init() { sz = last = 0; newnode(0); newnode(-1); s[n = 0] = -1; fail[0] = 1; } int getfail(int u) { while(s[n - len[u] - 1] != s[n]) u = fail[u]; return u; } pair&lt;int, int&gt; add(int c) { s[++n] = c; int u = getfail(last); int&amp; v = nxt[u][c]; if(!v) { int cur = newnode(len[u] + 2); fail[cur] = nxt[getfail(fail[u])][c]; v = cur; // pr(len[fail[v]]); prln(len[v]); cnt[v] = cnt[fail[v]] + 1; sum[v] = sum[fail[v]] + len[v]; if(sum[v] &gt;= MOD) sum[v] -= MOD; // prln(sum[v]); } last = v; return {cnt[v], sum[v]}; } } pt; int n; char s[N]; int preCnt[N], preSum[N]; typedef long long LL; LL mul(LL x, LL y) { return x * y % MOD; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); while(scanf(&quot;%s&quot;, s + 1) == 1) { n = strlen(s + 1); pt.init(); for(int i = 1; i &lt;= n; ++i) { auto ret = pt.add(s[i] - &#39;a&#39;); tie(preCnt[i], preSum[i]) = ret; } pt.init(); LL ans = 0; for(int i = n; i &gt; 1; --i) { auto ret = pt.add(s[i] - &#39;a&#39;); int sufCnt, sufSum; tie(sufCnt, sufSum) = ret; // prln(i); // printf(&quot;%d %d %d %d\n&quot;, preCnt[i - 1], preSum[i - 1], sufCnt, sufSum); LL sqI = mul(mul(mul(i, i), preCnt[i - 1]), sufCnt); LL mid = mul(preCnt[i - 1], sufSum - sufCnt) - mul(sufCnt, preSum[i - 1]); mid %= MOD; mid = mul(mid, i); LL rht = mul(sufSum - sufCnt, preSum[i - 1]); ans += sqI + mid - rht; ans %= MOD; // prln(ans); } ans = (ans + MOD) % MOD; printf(&quot;%I64d\n&quot;, ans); } return 0; } 代码二： // // Created by TaoSama on 2016-08-03 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e6 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; // 原串 a[i]: w a a b w s w f d // 新串 s[i]: # w # a # a # b # w # s # w # f # d # // 辅助数组 p[i]: 1 2 1 2 3 2 1 2 1 2 1 4 1 2 1 2 1 2 1 // p[i] := 新串以 s[i] 为中心向右延伸的回文距离 + 1 （自己） // p[i]-1 := 原串以 s[i] 为中心的回文长度 int n; char s[N]; struct Manacher { static const int M = N &lt;&lt; 1; char s[M]; int n, p[M]; int delta[2][M], sum[2][M]; void init(char* a) { s[0] = &#39;@&#39;; s[1] = &#39;#&#39;; n = 2; for(int i = 1; a[i]; ++i) s[n++] = a[i], s[n++] = &#39;#&#39;; s[n] = 0; } int gao() { int mx = 0, id, ret = 0; for(int i = 1; i &lt; n; ++i) { p[i] = mx &gt; i ? min(mx - i, p[2 * id - i]) : 1; while(s[i - p[i]] == s[i + p[i]]) ++p[i]; if(mx &lt; i + p[i]) mx = i + p[i], id = i; ret = max(ret, p[i] - 1); } return ret; } inline void add(int&amp; x, int y) { if(y &lt; 0) y += MOD; if((x += y) &gt;= MOD) x -= MOD; } //0-&gt;start 1-&gt;end void process() { memset(delta, 0, sizeof delta); memset(sum, 0, sizeof sum); for(int i = 1; i &lt; n; ++i) { int r = i + p[i] - 1, l = i - (p[i] - 1); add(sum[0][l], r); add(sum[0][i + 1], -r - (i - l) * (-1)); //+ r ~ i add(delta[0][l + 1], -1); add(delta[0][i + 1], 1); //d + -1 add(sum[1][i], i); add(sum[1][r + 1], -i - (r - i) * (-1)); //+ i ~ l add(delta[1][i + 1], -1); add(delta[1][r + 1], 1); //d + -1 } for(int i = 1; i &lt; n; ++i) { for(int j = 0; j &lt; 2; ++j) { add(delta[j][i], delta[j][i - 1]); add(sum[j][i], sum[j][i - 1]); add(sum[j][i], delta[j][i]); } } } bool ok(int l, int r) { l &lt;&lt;= 1; r &lt;&lt;= 1; int k = l + r &gt;&gt; 1; return k + p[k] - 1 &gt;= r; } } ma; int quick(int x, int n) { int ret = 1; for(; n ; n &gt;&gt;= 1) { if(n &amp; 1) ret = 1LL * ret * x % MOD; x = 1LL * x * x % MOD; } return ret; } const int invTwo = 500000004; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); while(scanf(&quot;%s&quot;, s + 1) == 1) { ma.init(s); ma.gao(); ma.process(); n = strlen(s + 1); int* preSum = ma.sum[0], *sufSum = ma.sum[1]; int ans = 0; for(int i = 1; i &lt; n; ++i) { sufSum[i &lt;&lt; 1] = 1LL * sufSum[i &lt;&lt; 1] * invTwo % MOD; preSum[i + 1 &lt;&lt; 1] = 1LL * preSum[i + 1 &lt;&lt; 1] * invTwo % MOD; ans += 1LL * sufSum[i &lt;&lt; 1] * preSum[i + 1 &lt;&lt; 1] % MOD; if(ans &gt;= MOD) ans -= MOD; } printf(&quot;%d\n&quot;, ans); } return 0; }]]></content>
      <categories>
        <category>字符串</category>
        <category>Manacher/回文树</category>
      </categories>
      <tags>
        <tag>回文树</tag>
        <tag>Manacher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5784 How Many Triangles（极角排序）]]></title>
    <url>%2F2016%2F08%2F04%2FHDU%205784%20How%20Many%20Triangles%EF%BC%88%E6%9E%81%E8%A7%92%E6%8E%92%E5%BA%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $给定N\le 2000个二维平面不重点，求形成的锐角三角形的个数$ 分析： $总而言之，这种就是极角排序之后然后two pointers$$由于是个环倍增一下，无论你atan2搞还是点积叉积搞，思路都是一样的$$来看看这题的两种计算姿势，一种是题解的比较tricky一点：$$锐角三角形={cnt_{锐角}-2\times(cnt_{直角、钝角})\over 3}，注意这里是角$$至于怎么算的，看贡献，锐角三角形贡献3个锐角，直角、钝角三角形贡献2个锐角$$这个统计方法也比较simple，two pointers先统计锐角、然后再统计锐、直、钝一起$$一减就得到了想要的2个东西$$对于第二种做法，比较general一点：$$锐角三角形=总三角形数-直角、钝角、平角三角形数，注意这里是三角形$$two pointers统计的时候直接把锐角和0°一起统计了$$直角、钝角、平角三角形数=C(n-1, 2)-统计出来的$$最后再用C(n, 3)减一下就好了$$两者时间复杂度都是O(n^2logn)$$注意atan2的精度，毕竟atan2(2e9, 1)在$ 1e-10 $的量级，多取2个量级取$ 1e-12 就好 代码一: // // Created by TaoSama on 2016-08-02 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; const double EPS = 1e-12, PI = acos(-1); int sgn(double x) { return x &lt; -EPS ? -1 : x &gt; EPS; } int n; struct Point { int x, y; double ang; void read() {scanf(&quot;%d%d&quot;, &amp;x, &amp;y);} } p[N]; int calc(vector&lt;Point&gt;&amp; v, double delta) { int angle = 0; for(int i = 0, j = 0, k = 0; i &lt; n - 1; i = k + 1) { //collinear while(k + 1 &lt; n - 1 &amp;&amp; sgn(v[k + 1].ang - v[i].ang) == 0) ++k; j = max(j, k); while(j &lt; v.size() &amp;&amp; sgn(v[j].ang - v[i].ang - delta) &lt; 0) ++j; angle += (k - i + 1) * (j - k - 1); } return angle; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); while(scanf(&quot;%d&quot;, &amp;n) == 1) { for(int i = 1; i &lt;= n; ++i) p[i].read(); int acute = 0, obtuse = 0; for(int i = 1; i &lt;= n; ++i) { vector&lt;Point&gt; v; for(int j = 1; j &lt;= n; ++j) if(j != i) v.push_back(p[j]); for(int j = 0; j &lt; n - 1; ++j) v[j].ang = atan2(v[j].y - p[i].y, v[j].x - p[i].x); sort(v.begin(), v.end(), [&amp;](Point x, Point y) { return x.ang &lt; y.ang; }); //double it for(int j = 0; j &lt; n - 1; ++j){ Point tmp = v[j]; tmp.ang += 2 * PI; v.push_back(tmp); } int curAcute = calc(v, PI / 2); int tot = calc(v, PI); acute += curAcute; obtuse += tot - curAcute; } int ans = (acute - 2 * obtuse) / 3; printf(&quot;%d\n&quot;, ans); } return 0; } 代码二：(来自mathon) /************************************************ *Author :mathon *Email :luoxinchen96@gmail.com *************************************************/ #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; #include &lt;queue&gt; #include &lt;set&gt; #include &lt;map&gt; #include &lt;string&gt; #include &lt;cmath&gt; #include &lt;cstdlib&gt; #include &lt;ctime&gt; #include &lt;stack&gt; using namespace std; typedef pair&lt;int, int&gt; pii; typedef long long ll; typedef unsigned long long ull; #define xx first #define yy second #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; &quot; &lt;&lt; x &lt;&lt; endl template&lt;class T&gt; inline T lowbit(T x) { return x &amp; (-x); } const int MAXN = 2000 + 5; struct Point { ll x, y; Point() {} Point(ll x, ll y): x(x), y(y) {} void read() { scanf(&quot;%lld%lld&quot;, &amp;x, &amp;y); } Point operator - (const Point&amp; b) const { return Point(x - b.x, y - b.y); } ll cross(const Point&amp; b) const { return x * b.y - y * b.x; } ll dot(const Point&amp; b) const { return x * b.x + y * b.y; } void print() { printf(&quot;x = %lld, y = %lld\n&quot;, x, y); } } ps[MAXN]; int n; bool cmp(const Point&amp; a, const Point&amp; b) { if(a.y * b.y &lt;= 0) { if(a.y &gt; 0 || b.y &gt; 0) return a.y &lt; b.y; if(a.y == 0 &amp;&amp; b.y == 0) return a.x &lt; b.x; } return a.cross(b) &gt; 0; } Point buf[MAXN * 2]; int main(void) { #ifdef MATHON freopen(&quot;1004.in&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout); #endif while(scanf(&quot;%d&quot;, &amp;n) == 1) { for(int i = 0; i &lt; n; i++) { ps[i].read(); } ll ans = 0; for(int k = 0; k &lt; n; k++) { int cnt = 0; for(int j = 0; j &lt; n; j++) { if(k == j) continue; buf[cnt++] = ps[j] - ps[k]; } sort(buf, buf + cnt, cmp); memcpy(buf + cnt, buf, sizeof(Point) * cnt); ll tmp = 0; for(int i = 0, j = 0; i &lt; cnt; i++) { if(i == j) while(j &lt; i + cnt &amp;&amp; buf[i].cross(buf[j]) == 0 &amp;&amp; buf[i].dot(buf[j]) &gt; 0) j++; while(j &lt; i + cnt &amp;&amp; buf[i].cross(buf[j]) &gt; 0 &amp;&amp; buf[i].dot(buf[j]) &gt; 0) j++; tmp += j - i - 1; // pr(i); prln(j); } // prln(tmp); tmp = (cnt) * (cnt - 1) / 2 - tmp; ans += tmp; } ans = ll(n) * (n - 1) * (n - 2) / 6 - ans; cout &lt;&lt; ans &lt;&lt; endl; } return 0; }]]></content>
      <categories>
        <category>计算几何</category>
        <category>极角排序</category>
      </categories>
      <tags>
        <tag>极角排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5781 ATM Mechine（期望dp）]]></title>
    <url>%2F2016%2F08%2F03%2FHDU%205781%20ATM%20Mechine%EF%BC%88%E6%9C%9F%E6%9C%9Bdp%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $给定1\le K\le 2000的钱的上界，即钱x\in[0, K]，1\le W\le 2000次警告次数$$&gt;会被警告，\le 可以直接取走钱，警告次数超过W会被警察带走$$人采取最优策略的情况下，问取完所有钱的期望次数$ 分析： $期望dp，f[k][w]:=上界为k，警告次数为w的取完钱的期望次数$$因为要考虑x\in [0, k]的所有情况：$$显然有k=1时，f[1][w]=1$$0要取一次，warn一下就知道没钱，1取1，因为是上界知道取完了，(1+1)/2=1$$w=1时，只能每次取1，\forall x\in [0, k)都是x+1次，k因为是上界不用多一次知道没钱，所以是k$$f[k][1] = \frac{ { (1+k)\times k\over 2 }+k } { k+1 }$$其他情况暴力枚举所有能取的钱即i\in[1, k]$$显然被警告的概率是p(i&gt;x)={ i\over k+1 }，即x\in[0, i)$$不被警告的概率p(i\le x)={ k-i+1\over k+1 }，即x\in[i, k]$$转移即为f[k][w] =\displaystyle \min_{ i\in[1, k] } \{ { i\over k+1 }\times f[i-1][w-1]+{ k-i+1\over k+1 } \times f[k-i][w]+1 \}$$当前这个是O(n^3)的，过不了$$人最优策略的话，显然他可以算出来这些期望，然后采取最优策略$$我们来估测一下，二分仅仅是不太好的策略，但显然可以知道W的上界是O(log_2n)的$$然后复杂度就变成了O(n^2logn)了，就可以过了$ 代码: // // Created by TaoSama on 2016-08-03 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 2e3 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int k, w; double f[N][20]; bool vis[N][20]; double dfs(int k, int w) { double&amp; ret = f[k][w]; if(vis[k][w]) return ret; if(k == 0) ret = 0; else if(w == 1) ret = (1.0 * (1 + k) * k / 2 + k) / (k + 1); //1+..+k + k else { ret = INF; for(int i = 1; i &lt;= k; ++i) { ret = min(ret, 1. * (k - i + 1) / (k + 1) * dfs(k - i, w) + 1. * i / (k + 1) * dfs(i - 1, w - 1) + 1); } } vis[k][w] = true; return ret; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); memset(vis, 0, sizeof vis); for(int i = 0; i &lt;= 2000; ++i) for(int j = 1; j &lt;= 15; ++j) dfs(i, j); while(scanf(&quot;%d%d&quot;, &amp;k, &amp;w) == 2) { w = min(w, 15); printf(&quot;%.6f\n&quot;, f[k][w]); } return 0; }]]></content>
      <categories>
        <category>动态规划</category>
        <category>概率/期望dp</category>
      </categories>
      <tags>
        <tag>期望dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 3977 Subset（折半搜索）]]></title>
    <url>%2F2016%2F08%2F01%2FPOJ%203977%20Subset%EF%BC%88%E6%8A%98%E5%8D%8A%E6%90%9C%E7%B4%A2%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N\le 35个数的集合S，|A_i|\le 10^{15}$$求1个非空子集S’，使得|\sum_{S’\in S}A_i|最小，同时使得元素个数最少$ 分析： $数据范围都告诉你是折半搜索辣$$显然预处理2^{N/2}个非空子集的答案先存起来排序(特么窝忘记排序了调一年)$$之后枚举后2^{N-N/2}个非空子集，假设当前子集是sum, cnt$$那么显然应该去枚举-sum，但是由于可能不存在$$所以应该lower_bound这个(-sum, -INF)一波$$显然找到的就是大于等于的那个最小的，并且cnt也是最小的$$之后这个lower_bound-1就是小于的那个$$但是这个时候由于重复的，找到cnt是最大的，不是可选解$$显然取出这个值sum’，再去lower_bound查找一下(sum’, -INF)$$就是要求的最小的cnt的那个辣$$时间复杂度O(n2^nlog2^n)$ 代码: // // Created by TaoSama on 2016-07-29 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n; typedef long long LL; LL a[40]; LL ABS(const LL&amp; x) { if(x &lt; 0) return -x; return x; } void checkAns(pair&lt;LL, LL&gt;&amp; ans, pair&lt;LL, LL&gt; rhs, LL sum, LL cnt) { LL lftSum = rhs.first, lftCnt = rhs.second; ans = min(ans, make_pair(ABS(sum + lftSum), cnt + lftCnt)); } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); clock_t _ = clock(); while(scanf(&quot;%d&quot;, &amp;n) == 1 &amp;&amp; n) { for(int i = 0; i &lt; n; ++i) scanf(&quot;%lld&quot;, a + i); pair&lt;LL, LL&gt; ans((LL)1e18, (LL)1e18); int half = n &gt;&gt; 1, lft = n - half; vector&lt;pair&lt;LL, LL&gt; &gt; v; for(int i = 1; i &lt; 1 &lt;&lt; half; ++i) { LL sum = 0, cnt = 0; for(int j = 0; j &lt; half; ++j) { if(i &gt;&gt; j &amp; 1) { ++cnt; sum += a[j]; } } v.push_back(make_pair(sum, cnt)); checkAns(ans, make_pair(0, 0), sum, cnt); } sort(v.begin(), v.end()); for(int i = 1; i &lt; 1 &lt;&lt; lft; ++i) { LL sum = 0, cnt = 0; for(int j = 0; j &lt; lft; ++j) { if(i &gt;&gt; j &amp; 1) { ++cnt; sum += a[half + j]; } } checkAns(ans, make_pair(0, 0), sum, cnt); int x = lower_bound(v.begin(), v.end(), make_pair(-sum, (LL) - INF)) - v.begin(); if(x != v.size()) checkAns(ans, v[x], sum, cnt); if(x) { --x; x = lower_bound(v.begin(), v.end(), make_pair(v[x].first, (LL) - INF)) - v.begin(); checkAns(ans, v[x], sum, cnt); } } printf(&quot;%lld %lld\n&quot;, ans.first, ans.second); } #ifdef LOCAL printf(&quot;\nTime cost: %.2fs\n&quot;, 1.0 * (clock() - _) / CLOCKS_PER_SEC); #endif return 0; }]]></content>
      <categories>
        <category>技巧</category>
        <category>折半搜索</category>
      </categories>
      <tags>
        <tag>折半搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 3276 Face The Right Way（反转问题）]]></title>
    <url>%2F2016%2F08%2F01%2FPOJ%203276%20Face%20The%20Right%20Way%EF%BC%88%E5%8F%8D%E8%BD%AC%E9%97%AE%E9%A2%98%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N\le 5000个奶牛，有初始朝向B/F$$现要通过每次反转K个奶牛操作，即B/F状态互换，使得所有奶牛最终都是F状态$$求出最小反转次数M，以及这个最小M的下的最小K$ 分析： $这类问题都一个苛刻的性质，即当前状态必然确定这个位置是否反转$$本题考虑枚举K，对于每个K来求M$$考虑使用f[i]:=记录f[i\sim i-k+1]这个区间是否被反转$$那么所有能影响i这个位置的f[i]为f[i-k+1\sim i-1]$$看这个和以及当前B/F状态即可知道i需不需要被反转$$最后根据n-k+2\sim n以及对应影响的f[i]和即可知道是否合法$$对于f[i]和，直接用一个变量维护即可$$时间复杂度为O(n^2)$ 代码: // // Created by TaoSama on 2016-07-29 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, a[N]; int f[N]; int calc(int k) { memset(f, 0, sizeof f); int sum = 0, ret = 0; for(int i = 1; i + k - 1 &lt;= n; ++i) { if(a[i] + sum &amp; 1) { ++ret; f[i] = 1; } sum += f[i]; if(i - k + 1 &gt;= 1) sum -= f[i - k + 1]; } for(int i = n - k + 2; i &lt;= n; ++i) { if(a[i] + sum &amp; 1) return INF; if(i - k + 1 &gt;= 1) sum -= f[i - k + 1]; } return ret; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); clock_t _ = clock(); scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, a + i); for(int i = 1; i &lt;= n; ++i) { char buf[2]; scanf(&quot;%s&quot;, buf); a[i] = *buf == &#39;B&#39;; } pair&lt;int, int&gt; ans = make_pair(INF, INF); // m k for(int i = 1; i &lt;= n; ++i) { int o = calc(i); ans = min(ans, make_pair(o, i)); } printf(&quot;%d %d\n&quot;, ans.second, ans.first); #ifdef LOCAL printf(&quot;\nTime cost: %.2fs\n&quot;, 1.0 * (clock() - _) / CLOCKS_PER_SEC); #endif return 0; }]]></content>
      <categories>
        <category>技巧</category>
        <category>反转问题</category>
      </categories>
      <tags>
        <tag>反转问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 2566 Bound Found（two pointers）]]></title>
    <url>%2F2016%2F08%2F01%2FPOJ%202566%20Bound%20Found%EF%BC%88two%20pointers%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N\le 10^5个数，|A_i|\le 10^4，现有K\le 100次询问$$每次给定1个值x，求1个非空区间，使得|sum|=|\sum_{i=l}^r A_i|与x的差值尽量小$$即使得||sum|-x|尽量小，输出这个|sum|，以及区间端点$ 分析： $首先求个prefixSum_i，显然sum(l, r)=prefix_r-prefix_{l-1}$$由于外面套了一个绝对值，|sum(l, r)|=|prefix_r-prefix_{l-1}|=|prefix_{l-1}-prefix_r|$$那么prefixSum_i的顺序就无所谓了，窝萌可以排个序$$排序后就有单调性了，就可以做很多事情了$$比如窝萌就可以用two pointers来枚举所有区间来更新答案了$$由于整个序列都可以作为答案，two pointers枚举的话为了方便可以丢个prefixSum_0进去$$其他注意细节就好了$ 代码: // // Created by TaoSama on 2016-07-29 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, q; pair&lt;int, int&gt; s[N]; int ans, diff, L, R; void update(int l, int r, int x) { if(s[l].second == s[r].second) return; //empty range int sum = abs(s[r].first - s[l].first); int newDiff = abs(sum - x); if(newDiff &lt; diff) { diff = newDiff; ans = sum; L = s[l].second; R = s[r].second; if(L &gt; R) swap(L, R); } } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); while(scanf(&quot;%d%d&quot;, &amp;n, &amp;q) &amp;&amp; (n || q)) { s[0] = make_pair(0, 0); for(int i = 1; i &lt;= n; ++i) { int x; scanf(&quot;%d&quot;, &amp;x); s[i].first = s[i - 1].first + x; s[i].second = i; } sort(s, s + n + 1); while(q--) { int x; scanf(&quot;%d&quot;, &amp;x); diff = INF; int sum = 0; for(int l = 0, r = 0; l &lt;= n; ++l) { sum = s[r].first - s[l].first; update(l, r, x); while(r &lt; n &amp;&amp; sum &lt; x) { ++r; update(l, r, x); sum = s[r].first - s[l].first; } } printf(&quot;%d %d %d\n&quot;, ans, L + 1, R); } } return 0; }]]></content>
      <categories>
        <category>技巧</category>
        <category>two pointers</category>
      </categories>
      <tags>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 85C Petya and Tree（树形dp）]]></title>
    <url>%2F2016%2F08%2F01%2FCodeforces%2085C%20Petya%20and%20Tree%EF%BC%88%E6%A0%91%E5%BD%A2dp%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N\le 10^5的一棵满二叉搜索树，点权1\le A_i\le 10^9$$满二叉搜索树：每个节点的儿子个数为0或者2$$给定Q\le 10^5询问，每次查询一个值1\le q\le 10^9，保证值没有在BST中出现过$$并且查询过程中一定会出错有且仅有一次，即本该去左子树去了右子树，反之亦然$$求在BST中查询这个值的期望$ 分析： $这是一道分析想法题，首先有个很显然的结论：$$所有正确查询情况下出现在同一个叶子的期望值必然相等，$$并且对于最后一层的2个叶子，只会出现在其中1个$$玩玩样例(看看别人代码)可以发现：$$如果某个值在查询过程中，这次出错了，假设本应该去左子树$$但去了右子树，那么显然在右子树中只能不断往左走，即贡献应该是那个最小值$$反之同理，贡献是个最大值$$问题解决了一半，树形dp维护子树的最大值和最小值$$并通过这个再次树形dp计算出每个叶子的贡献累和$$接下来考虑一下如何找到这个叶子$$再玩玩样例(看看别人代码)可以发现：$$找到这个数有3种可能，直接在所有点权upper_bound$$1个是直接找到，不然找不到一定是最后那个$$还有1种情况必然是某个叶子的父亲，只要取它的左儿子就好了$$因为比这个值大，要往左走$$至此做完了，时间复杂度为O(n+nlogn)$ 代码: // // Created by TaoSama on 2016-08-01 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, val[N]; int rt, ls[N], rs[N]; int minv[N], maxv[N], dep[N]; double f[N]; void dfs1(int u) { if(!ls[u]) { minv[u] = maxv[u] = val[u]; return; } int v1 = ls[u], v2 = rs[u]; dfs1(v1); dfs1(v2); minv[u] = minv[v1]; maxv[u] = maxv[v2]; } void dfs2(int u) { if(!ls[u]) return; int v1 = ls[u], v2 = rs[u]; dep[v1] = dep[v2] = dep[u] + 1; f[v1] = f[u] + minv[v2]; f[v2] = f[u] + maxv[v1]; dfs2(v1); dfs2(v2); } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); scanf(&quot;%d&quot;, &amp;n); vector&lt;pair&lt;int, int&gt; &gt; keys; for(int i = 1; i &lt;= n; ++i) { int fa; scanf(&quot;%d%d&quot;, &amp;fa, val + i); if(fa == -1) rt = i; else if(!ls[fa]) ls[fa] = i; else rs[fa] = i; if(val[ls[fa]] &gt; val[rs[fa]]) swap(ls[fa], rs[fa]); keys.push_back({val[i], i}); } sort(keys.begin(), keys.end()); dfs1(rt); dfs2(rt); int q; scanf(&quot;%d&quot;, &amp;q); while(q--) { int x; scanf(&quot;%d&quot;, &amp;x); auto iter = upper_bound(keys.begin(), keys.end(), make_pair(x, -INF)); if(iter == keys.end()) --iter; if(ls[iter-&gt;second]) --iter; //must be leaves int y = iter-&gt;second; printf(&quot;%.10f\n&quot;, f[y] / dep[y]); } return 0; }]]></content>
      <categories>
        <category>动态规划</category>
        <category>树形dp</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5737 Differencia（归并树）]]></title>
    <url>%2F2016%2F07%2F25%2FHDU%205737%20Differencia%EF%BC%88%E5%BD%92%E5%B9%B6%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N\le 10^5长度的A，B两个数组，A_i，B_i\le 10^9$$Q\le 3\times 10^6次查询，2种查询$$+ l r x:把A数组的[l, r]区间数变为x$$? l r:查询[l, r]区间A_i\ge B_i的下标个数$ 分析： $首先O(qlog^2)的归并树做法很显然，每个节点维护B数组的有序表$$之后对于每次查询只需要在每个节点二分一下即可$$由于Q巨大，所以这么做要T，事实上由于不会操作B数组，对于查询可以提前维护一点东西$$维护有序表第i个数进入左右子树时的位置（即有多少数\le 第i个数）$ $那么查询在线段树上就可以O(1)得到这个数在左右子树的rank变化$ $这个对线段树往下push lazy标记也是适用的，就去掉了1个log$$时间复杂度O(qlogn)就可以草过去了$ 代码: // // Created by TaoSama on 2016-07-25 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, q, A, B; int a[N], b[N]; int rnd(int&amp; last, int&amp; a, int&amp; b) { int C = ~(1 &lt;&lt; 31), M = (1 &lt;&lt; 16) - 1; a = (36969 + (last &gt;&gt; 3)) * (a &amp; M) + (a &gt;&gt; 16); b = (18000 + (last &gt;&gt; 3)) * (b &amp; M) + (b &gt;&gt; 16); return (C &amp; ((a &lt;&lt; 16) + b)) % 1000000000; } namespace Discretization { vector&lt;int&gt; xs; void init() { xs = vector&lt;int&gt;(b + 1, b + 1 + n); sort(xs.begin(), xs.end()); for(int i = 1; i &lt;= n; ++i) { b[i] = lower_bound(xs.begin(), xs.end(), b[i]) - xs.begin() + 1; a[i] = upper_bound(xs.begin(), xs.end(), a[i]) - xs.begin(); } } int get(int x) { return upper_bound(xs.begin(), xs.end(), x) - xs.begin(); } } namespace Allocator { int data[N &lt;&lt; 6], *p; void init() { p = data; } int* allocate(int len) { p += len; return p - len; } } struct Node { int* indexLeft, *indexRight; int tag, sum; void setTag(int v) { tag = sum = v; } int goLeft(int v) { if(v) return indexLeft[v]; return 0; } int goRight(int v) { if(v) return indexRight[v]; return 0; } } tree[N &lt;&lt; 2]; void pushUp(int rt) { tree[rt].sum = tree[rt &lt;&lt; 1].sum + tree[rt &lt;&lt; 1 | 1].sum; } void pushDown(int rt) { if(~tree[rt].tag) { int v = tree[rt].tag; int ls = rt &lt;&lt; 1, rs = ls | 1; tree[ls].setTag(tree[rt].goLeft(v)); tree[rs].setTag(tree[rt].goRight(v)); tree[rt].tag = -1; } } void merge(int rt, int l, int r) { static int tmp[N]; int m = l + r &gt;&gt; 1; int* vl = b + l - 1, *vr = b + m; int sl = m - l + 1, sr = r - m; int i = 1, j = 1, k = 1; while(i &lt;= sl &amp;&amp; j &lt;= sr) { if(vl[i] &lt; vr[j]) { tree[rt].indexLeft[k] = i; tree[rt].indexRight[k] = j - 1; tmp[k++] = vl[i++]; } else { tree[rt].indexLeft[k] = i - 1; tree[rt].indexRight[k] = j; tmp[k++] = vr[j++]; } } while(i &lt;= sl) { tree[rt].indexLeft[k] = i; tree[rt].indexRight[k] = j - 1; tmp[k++] = vl[i++]; } while(j &lt;= sr) { tree[rt].indexLeft[k] = i - 1; tree[rt].indexRight[k] = j; tmp[k++] = vr[j++]; } memcpy(b + l, tmp + 1, r - l + 1 &lt;&lt; 2); } void build(int l, int r, int rt) { tree[rt].tag = -1; tree[rt].indexLeft = Allocator::allocate(r - l + 1); tree[rt].indexRight = Allocator::allocate(r - l + 1); if(l == r) { tree[rt].sum = a[l] &gt;= b[l]; return; } int m = l + r &gt;&gt; 1; build(l, m, rt &lt;&lt; 1); build(m + 1, r, rt &lt;&lt; 1 | 1); pushUp(rt); merge(rt, l, r); } void update(int L, int R, int v, int l, int r, int rt) { if(L &lt;= l &amp;&amp; r &lt;= R) { tree[rt].setTag(v); return; } int m = l + r &gt;&gt; 1; pushDown(rt); if(L &lt;= m) update(L, R, tree[rt].goLeft(v), l, m, rt &lt;&lt; 1); if(R &gt; m) update(L, R, tree[rt].goRight(v), m + 1, r, rt &lt;&lt; 1 | 1); pushUp(rt); } int query(int L, int R, int l, int r, int rt) { if(L &lt;= l &amp;&amp; r &lt;= R) return tree[rt].sum; int m = l + r &gt;&gt; 1, ret = 0; pushDown(rt); if(L &lt;= m) ret += query(L, R, l, m, rt &lt;&lt; 1); if(R &gt; m) ret += query(L, R, m + 1, r, rt &lt;&lt; 1 | 1); return ret; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); clock_t _ = clock(); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;q, &amp;A, &amp;B); for(int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, a + i); for(int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, b + i); Allocator::init(); Discretization::init(); build(1, n, 1); int ans = 0, last = 0; for(int i = 1; i &lt;= q; ++i) { int l = rnd(last, A, B) % n + 1; int r = rnd(last, A, B) % n + 1; int x = rnd(last, A, B) + 1; if(l &gt; r) swap(l, r); if(l + r + x &amp; 1) { x = Discretization::get(x); // printf(&quot;+ %d %d %d\n&quot;, l, r, x); update(l, r, x, 1, n, 1); } else { last = query(l, r, 1, n, 1); // printf(&quot;? %d %d ans = %d\n&quot;, l, r, last); ans += 1LL * i * last % MOD; if(ans &gt;= MOD) ans -= MOD; } } printf(&quot;%d\n&quot;, ans); } #ifdef LOCAL printf(&quot;\nTime cost: %.2fs\n&quot;, 1.0 * (clock() - _) / CLOCKS_PER_SEC); #endif return 0; } /* + 2 3 5 ? 2 2 ans = 1 ? 1 4 ans = 3 ? 2 4 ans = 2 ? 3 4 ans = 1 + 1 1 5 + 1 5 5 ? 5 5 ans = 1 ? 5 5 ans = 1 ? 1 4 ans = 4 81 + 1 4 5 ? 4 5 ans = 1 ? 2 4 ans = 3 ? 3 4 ans = 2 + 1 5 5 ? 2 5 ans = 4 + 1 4 5 ? 4 4 ans = 1 ? 1 3 ans = 3 ? 2 2 ans = 1 88 ? 1 5 ans = 3 + 4 4 5 + 2 4 5 + 3 4 5 ? 3 4 ans = 2 ? 1 4 ans = 4 + 1 1 5 + 3 5 5 + 1 3 5 ? 1 5 ans = 5 87 */]]></content>
      <categories>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>归并树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5735 Born Slippy（dp、分块、可持久化）]]></title>
    <url>%2F2016%2F07%2F25%2FHDU%205735%20Born%20Slippy%EF%BC%88dp%E3%80%81%E5%88%86%E5%9D%97%E3%80%81%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N\le 2^{16}个节点的一棵树，点权w_i &lt; 2^{16}，现从树上抓出来一条链序列$$对于起点s\in [1, N]，找出1个序列，v_1=s, v_2, \cdots, v_m$$使得f(s)=w_{v_1}+\sum\limits_{i=2}^{m}w_{v_i} \text{ opt } w_{v_{i-1}}最大，opt可以是AND，OR，XOR$$求每个f(i)$ 分析： $考虑序列上的情况，以and为例，显然有dp，f[i]=ans[i]-w_s=\max\limits_{j &lt; i} \{ f[j]+w_j\text{ and }w_i \}$$蓝儿转移O(n)，总复杂度O(n^2)是不行的，考虑维护东西降低转移复杂度$$观察w_i&lt;2^{16}，我们把转移拆一下$$f[i]=\max\limits_{j &lt; i} \{ f[j]+w_j[后8位]\text{ and }w_i[后8位]+w_j[前8位]\text{ and }w_i[前8位] \text{&lt;&lt;} 8 \}$$之后我们维护1个，ds[x][y]:=表示w_j前8位为x，w_i后8位为y时， f[j]+w_j[后8位]\text{ and }w_i[后8位]的最值$$令w_i=a\text{ &lt;&lt; }8\text{ | }b，更新f[i]只要枚举x，f[i]=\max\{ ds[x][b]+x\text{ and }a\text{ &lt;&lt; }8 \}$$转移复杂度就变成了O(\sqrt{n})，同理，用f[i]更新ds[x][y]$$推广到树上，从根往下转移的时候，备份被修改的，之后再拷贝回去（即可持久化一下）$$总时间复杂度为O(n\sqrt{n})$ 代码: // // Created by TaoSama on 2016-07-25 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = (1 &lt;&lt; 16) + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; const int S = 1 &lt;&lt; 8; typedef unsigned int UINT; int n, w[N]; vector&lt;int&gt; G[N]; UINT f[N], backup[N][S], ds[S][S]; //w_fa prefix8, w_u suffix8 -&gt; max suffix char op[10]; UINT opt(UINT a, UINT b) { if(*op == &#39;A&#39;) return a &amp; b; else if(*op == &#39;O&#39;) return a | b; return a ^ b; } void getMax(UINT&amp; x, UINT y) { if(x == -1 || x &lt; y) x = y; } void dfs(int u) { UINT a = w[u] &gt;&gt; 8, b = w[u] &amp; 255; UINT tmp = 0; for(int i = 0; i &lt; S; ++i) if(ds[i][b] != -1) getMax(tmp, ds[i][b] + (opt(i, a) &lt;&lt; 8)); f[u] = w[u] + tmp; memcpy(backup[u], ds[a], S &lt;&lt; 2); for(int i = 0; i &lt; S; ++i) getMax(ds[a][i], tmp + opt(i, b)); for(int v : G[u]) dfs(v); memcpy(ds[a], backup[u], S &lt;&lt; 2); } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); clock_t _ = clock(); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%d%s&quot;, &amp;n, op); for(int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, w + i); for(int i = 1; i &lt;= n; ++i) G[i].clear(); for(int i = 2; i &lt;= n; ++i) { int fa; scanf(&quot;%d&quot;, &amp;fa); G[fa].push_back(i); } memset(ds, -1, sizeof ds); dfs(1); int ans = 0; for(int i = 1; i &lt;= n; ++i) { ans += 1LL * i * f[i] % MOD; if(ans &gt;= MOD) ans -= MOD; } printf(&quot;%d\n&quot;, ans); } #ifdef LOCAL printf(&quot;\nTime cost: %.2fs\n&quot;, 1.0 * (clock() - _) / CLOCKS_PER_SEC); #endif return 0; }]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>分块优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[51nod 1532 带可选字符的多字符串匹配（dp、bitset优化）]]></title>
    <url>%2F2016%2F07%2F24%2F51nod%201532%20%E5%B8%A6%E5%8F%AF%E9%80%89%E5%AD%97%E7%AC%A6%E7%9A%84%E5%A4%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%EF%BC%88dp%E3%80%81bitset%E4%BC%98%E5%8C%96%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N\le 2\times 10^6的母串，M\le 500的模式串$$模式串的每个字符c_i有cnt_i\le 62个可选字符$$求母串哪些位置可以匹配模式串$ 分析： $f[i][j]:=母串匹配到i，模式串匹配到j，能否匹配$$把所有可选字符压起来成LL，复杂度是O(nm)的，并不行$$f[i][j]=f[i-1][j-1]，t[j]&gt;&gt;s[i] and 1为真$$由于dp状态是bool，并且状态只与i-1有关，考虑bitset压位$$预处理出模式串字符集在模式串的位置到bitset中$$每次转移只要左移一次然后与母串字符的状态即可$$这样就能一次直接转移整个模式串的状态$$时间复杂度为O(nm/64)$$表示百毒之星的那个数据其实是有毒的，贴个两边都能过的$$(参考了百毒之星ranklist的那个人的如何在坑爹数据下的过题办法。。$ 代码: // // Created by TaoSama on 2016-07-23 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; #include &lt;bitset&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 2e6 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; const int M = 500 + 10; int n; char s[N], t[M]; typedef bitset&lt;M&gt; Sta; Sta f[2], g[256]; //f[M][N] int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); clock_t _ = clock(); while(gets(s + 1)) { scanf(&quot; %d&quot;, &amp;n); for(int i = 0; i &lt; 256; ++i) g[i].reset(); for(int i = 1; i &lt;= n; ++i) { int cnt; scanf(&quot;%d%s&quot;, &amp;cnt, t + 1); for(int j = 1; j &lt;= cnt; ++j) g[t[j]][i] = 1; } bool ok = false; int p = 0; f[p].reset(); f[p][0] = 1; for(int i = 1; s[i]; ++i) { f[!p] = (f[p] &lt;&lt; 1) &amp; g[s[i]]; f[!p][0] = 1; if(f[!p][n]) { ok = true; printf(&quot;%d\n&quot;, i - n + 1); } p = !p; } if(!ok) puts(&quot;NULL&quot;); scanf(&quot;%*c&quot;); } #ifdef LOCAL printf(&quot;\nTime cost: %.2fs\n&quot;, 1.0 * (clock() - _) / CLOCKS_PER_SEC); #endif return 0; }]]></content>
      <categories>
        <category>动态规划</category>
        <category>bitset优化</category>
      </categories>
      <tags>
        <tag>bitset</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5745 La Vie en rose（dp、bitset优化）]]></title>
    <url>%2F2016%2F07%2F24%2FHDU%205745%20La%20Vie%20en%20rose%EF%BC%88dp%E3%80%81bitset%E4%BC%98%E5%8C%96%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N\le 10^5的母串，M\le 5000的模式串$$对于模式串，不相邻的2个字符可以和相邻的交换$$即abcd，ab换和cd也可以换，但bc换了cd就不能换了$$求每个位置是否能匹配模式串$ 分析： $f[i][j][3]:=母串匹配到i，模式串匹配到j，0和前面换，1正好匹配，2和后面换$$转移：f[i][j][0]=f[i-1][j-1][2]，s_i=t_{j-1}$$f[i][j][1]=f[i-1][j-1][0] | f[i-1][j-1][1]，s_i=t_j$$f[i][j][2]=f[i-1][j-1][0] | f[i-1][j-1][1]，s_i=t_{j+1}$$由于dp维护的都是bool，且只从i-1转移过来$$所以我们可以预处理母串字符集在母串中的位置到bitset中$$对于每次转移只要左移一次并且与上匹配的模式串的字符的状态就好$$即整体转移母串所有字符，左移一次相当于对上了当前状态的位置$$时间复杂度为O(nm/64)，bitset标准库里压ULL$$事实上搞模式串的状态也是可以的$ 代码: // // Created by TaoSama on 2016-07-22 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; #include &lt;bitset&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; typedef bitset&lt;N&gt; Sta; int n, m; char s[N], t[N]; Sta f[2][3]; //f[N][2][3] 0-&gt;pre 1-&gt;cur 2-&gt;nxt Sta g[26]; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); clock_t _ = clock(); int T; scanf(&quot;%d&quot;, &amp;T); while(T--) { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); scanf(&quot;%s%s&quot;, s + 1, t + 1); for(int i = 0; i &lt; 26; ++i) g[i].reset(); for(int i = 1; i &lt;= n; ++i) g[s[i] - &#39;a&#39;][i] = 1; int p = 0; for(int i = 0; i &lt; 3; ++i) f[p][i].reset(); f[p][1].set(); //f[x][0][1] = 1 for(int i = 1; i &lt;= m; ++i) { int pre = t[i - 1] - &#39;a&#39;, cur = t[i] - &#39;a&#39;, nxt = t[i + 1] - &#39;a&#39;; if(i &gt; 1) f[!p][0] = (f[p][2] &lt;&lt; 1) &amp; g[pre]; else f[!p][0].reset(); f[!p][1] = (f[p][1] | f[p][0]) &lt;&lt; 1 &amp; g[cur]; if(i &lt; m) f[!p][2] = (f[p][1] | f[p][0]) &lt;&lt; 1 &amp; g[nxt]; else f[!p][2].reset(); p = !p; } for(int i = 1; i &lt;= n - m + 1; ++i) { bool ans = f[p][0][i + m - 1] | f[p][1][i + m - 1]; putchar(&quot;01&quot;[ans]); } for(int i = n - m + 2; i &lt;= n; ++i) putchar(&#39;0&#39;); puts(&quot;&quot;); } #ifdef LOCAL printf(&quot;\nTime cost: %.2fs\n&quot;, 1.0 * (clock() - _) / CLOCKS_PER_SEC); #endif return 0; }]]></content>
      <categories>
        <category>动态规划</category>
        <category>bitset优化</category>
      </categories>
      <tags>
        <tag>bitset</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5739 Fantasia（点双连通、树形dp）]]></title>
    <url>%2F2016%2F07%2F24%2FHDU%205739%20Fantasia%EF%BC%88%E7%82%B9%E5%8F%8C%E8%BF%9E%E9%80%9A%E3%80%81%E6%A0%91%E5%BD%A2dp%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N\le 10^5个点，M\le 2\times 10^5的无向图$$定义一个图的权值：图连通就是点权积，不连通就是连通分量的权值和$$问删去i点后的图G_i的权值$ 分析： $时间复杂度O(n+m)$ 代码: // // Created by TaoSama on 2016-07-22 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 2e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, m, val[N]; vector&lt;int&gt; G[N], T[N]; int dfn[N], low[N], cut[N], bcc, dfsNum; vector&lt;int&gt; block[N]; int stk[N], top; void tarjan(int u, int f) { dfn[u] = low[u] = ++dfsNum; stk[++top] = u; int son = 0; for(int v : G[u]) { if(v == f) continue; if(!dfn[v]) { ++son; tarjan(v, u); low[u] = min(low[u], low[v]); if(low[v] &gt;= dfn[u]) { cut[u] = true; block[++bcc].push_back(u); while(true) { int x = stk[top--]; block[bcc].push_back(x); if(x == v) break; } } } else low[u] = min(low[u], dfn[v]); } if(f &lt; 0 &amp;&amp; son == 1) cut[u] = false; } void init() { bcc = n; dfsNum = 0; memset(dfn, 0, sizeof dfn); memset(cut, 0, sizeof cut); } typedef long long LL; LL quick(LL x, LL n) { LL ret = 1; for(; n; n &gt;&gt;= 1) { if(n &amp; 1) ret = ret * x % MOD; x = x * x % MOD; } return ret; } void add(LL&amp; x, LL y) { if(y &lt; 0) y += MOD; if((x += y) &gt;= MOD) x -= MOD; } bool vis[N]; LL f[N], g[N], sum; void dfs1(int u) { vis[u] = true; f[u] = val[u]; for(int v : T[u]) { if(vis[v]) continue; dfs1(v); f[u] = f[u] * f[v] % MOD; } } void dfs2(int u, int fa, int rt) { vis[u] = true; for(int v : T[u]) { if(v == fa) continue; dfs2(v, u, rt); } if(u &lt;= n) { LL up = f[rt] * quick(f[u], MOD - 2) % MOD, dw = 0; for(int v : T[u]) { if(v == fa) continue; add(dw, f[v]); } // pr(rt); pr(u); pr(up); prln(dw); if(!T[u].size() || u == rt) up = 0; g[u] = (sum - f[rt] + up + dw) % MOD; } } const int C = 2000; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;, &quot;w&quot;, stdout); #endif ios_base::sync_with_stdio(0); clock_t _ = clock(); int kase = 0; int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); if(++kase == C) printf(&quot;%d %d\n&quot;, n, m); for(int i = 1; i &lt;= 2 * n; ++i) { val[i] = 1; G[i].clear(); T[i].clear(); block[i].clear(); } for(int i = 1; i &lt;= n; ++i) { scanf(&quot;%d&quot;, val + i); if(kase == C) printf(&quot;%d &quot;, val[i]); } if(kase == C) puts(&quot;&quot;); for(int i = 1; i &lt;= m; ++i) { int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); if(kase == C) printf(&quot;%d %d\n&quot;, u, v); G[u].push_back(v); G[v].push_back(u); } init(); for(int i = 1; i &lt;= n; ++i) if(!dfn[i]) tarjan(i, -1); for(int u = n + 1; u &lt;= bcc; ++u) { for(int v : block[u]) { T[u].push_back(v); T[v].push_back(u); } } sum = 0; memset(vis, 0, sizeof vis); for(int i = 1; i &lt;= n; ++i) if(!vis[i]) {dfs1(i); add(sum, f[i]);} memset(vis, 0, sizeof vis); for(int i = 1; i &lt;= n; ++i) if(!vis[i]) dfs2(i, -1, i); LL ans = 0; for(int i = 1; i &lt;= n; ++i) add(ans, i * g[i] % MOD); printf(&quot;%I64d\n&quot;, ans); } #ifdef LOCAL printf(&quot;\nTime cost: %.2fs\n&quot;, 1.0 * (clock() - _) / CLOCKS_PER_SEC); #endif return 0; }]]></content>
      <categories>
        <category>图论</category>
        <category>连通图</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
        <tag>点双连通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5738 Eureka（贡献、极角排序）]]></title>
    <url>%2F2016%2F07%2F24%2FHDU%205738%20Eureka%EF%BC%88%E8%B4%A1%E7%8C%AE%E3%80%81%E6%9E%81%E8%A7%92%E6%8E%92%E5%BA%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N\le 10^3个点，求有多少子集共线$ 分析： $首先合并重点，然后把点字典序排序，直线向量x就恒正了$$枚举1个端点，对于所有字典序比它大的点极角排序一波$$对于所有共线的点，就是左端点选一个非空子集，右端点选一个非空子集$$所以贡献E_1=(2^{cnt_1}-1)\times (2^{cnt_2}-1)$$当然重点自己也要算下贡献，E_2=2^{cnt}-1-cnt$$这个就是选取2个端点（外面空0个点），然后外面空1个，2个点…里面随便选$$E_2=2^{cnt-2}+2\times 2^{cnt-3}+3\times 2^{cnt-4}+\cdots+(cnt-2)\times 2^1+(cnt-1)$$乘2错位一下，2E_2=2^{cnt-1}+2\times 2^{cnt-2}+3\times 2^{cnt-3}+(cnt-1)\times 2^1$$一减，E_2=2^{cnt-1}+2^{cnt-2}+2^{cnt-3}+\cdots+2^1-(cnt-1)$$等比数列求和一下，E_2=\frac{2\times (1-2^{cnt-1})}{1-2}-(cnt-1)=2^{cnt}-2-cnt+1=2^{cnt}-1-cnt$$然后就做完了，时间复杂度，常数很小的O(n^2logn)$ 代码: // // Created by TaoSama on 2016-07-22 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e3 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n; struct Point { int x, y; void read() {scanf(&quot;%d%d&quot;, &amp;x, &amp;y);} Point() {} Point(int x, int y): x(x), y(y) {} bool operator&lt;(const Point&amp; rhs) const { return make_pair(x, y) &lt; make_pair(rhs.x, rhs.y); } bool operator==(const Point&amp; rhs) const { return make_pair(x, y) == make_pair(rhs.x, rhs.y); } Point operator-(const Point&amp; rhs) const { return Point(x - rhs.x, y - rhs.y); } void reduce() { int g = __gcd(abs(x), abs(y)); if(g) x /= g, y /= g; } } p[N]; int two[N] = {1}; void add(int&amp; x, int y) { if((x += y) &gt;= MOD) x -= MOD; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); clock_t _ = clock(); for(int i = 1; i &lt; N; ++i) two[i] = 2 * two[i - 1] % MOD; int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%d&quot;, &amp;n); map&lt;Point, int&gt; mp; for(int i = 1; i &lt;= n; ++i) { p[i].read(); ++mp[p[i]]; } vector&lt;pair&lt;Point, int&gt; &gt; cnt(mp.begin(), mp.end()); int ans = 0; for(int i = 0; i &lt; cnt.size(); ++i) { Point p; int c1; tie(p, c1) = cnt[i]; vector&lt;pair&lt;Point, int&gt; &gt; v; for(int j = i + 1; j &lt; cnt.size(); ++j) { Point np; int c2; tie(np, c2) = cnt[j]; Point o = np - p; o.reduce(); v.push_back({o, c2}); } sort(v.begin(), v.end()); add(ans, two[c1] - 1 - c1); //x points is collinear for(int x = 0, y; x &lt; v.size(); x = y) { int c2 = 0; for(y = x; y &lt; v.size(); ++y) { if(v[x].first == v[y].first) c2 += v[y].second; else break; } int e = 1LL * (two[c1] - 1) * (two[c2] - 1) % MOD; add(ans, e); } } printf(&quot;%d\n&quot;, ans); } #ifdef LOCAL printf(&quot;\nTime cost: %.2fs\n&quot;, 1.0 * (clock() - _) / CLOCKS_PER_SEC); #endif return 0; }]]></content>
      <categories>
        <category>数学</category>
        <category>贡献</category>
      </categories>
      <tags>
        <tag>贡献</tag>
        <tag>极角排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5733 tetrahedron（三维几何？公式题。。）]]></title>
    <url>%2F2016%2F07%2F24%2FHDU%205733%20tetrahedron%EF%BC%88%E4%B8%89%E7%BB%B4%E5%87%A0%E4%BD%95%EF%BC%9F%E5%85%AC%E5%BC%8F%E9%A2%98%E3%80%82%E3%80%82%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $给定4个点，判断能否构成四面体，能输出内心坐标和内切球半径$ 分析： $混合积判断四面体存在，delta = A det B dot C$$delta不为0四面体就存在，然后内切球半径R=\frac{V}{\sum S_{面}}$$然后内心坐标：$ 代码: // // Created by TaoSama on 2016-07-19 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; const double EPS = 1e-8, PI = acos(-1); int sgn(double x) { return x &lt; -EPS ? -1 : x &gt; EPS; } struct Point3 { double x, y, z; bool read() { if(scanf(&quot;%lf%lf%lf&quot;, &amp;x, &amp;y, &amp;z) == 3) return true; return false; } Point3 operator+(const Point3&amp; p) { return {x + p.x, y + p.y, z + p.z}; } Point3 operator-(const Point3&amp; p) { return {x - p.x, y - p.y, z - p.z}; } double operator*(const Point3&amp; p) { return x * p.x + y * p.y + z * p.z; } Point3 operator^(const Point3&amp; p) { return {y* p.z - z * p.y, z* p.x - x * p.z, x* p.y - y * p.x}; } double length() { return sqrt(*this * *this); } void norm() { double l = length(); x /= l; y /= l; z /= l; } void print() { printf(&quot;%.4f %.4f %.4f&quot;, x, y, z); } } ps[4]; using Vector3 = Point3; bool isParallel(Vector3 A, Vector3 B) { return sgn((A ^ B).length()) &lt;= 0; } double point3ToLine(Point3 P, Point3 A, Vector3 v) { Vector3 w = P - A; return (v ^ w).length() / v.length(); } double point3ToPlane(Point3 p, Point3 A, Point3 B, Point3 C) { Vector3 v = B - A, w = C - A; Vector3 o = v ^ w; double pToO = point3ToLine(p, A, o); double pToA = (p - A).length(); return sqrt(pToA * pToA - pToO * pToO); } bool read() { for(int i = 0; i &lt; 4; ++i) if(!ps[i].read()) return false; return true; } bool judge() { Vector3 A = ps[1] - ps[0], B = ps[2] - ps[0], C = ps[3] - ps[0]; Vector3 o = A ^ B; if(isParallel(A, B)) return false; if(sgn(o * C) == 0) return false; return true; } double getS(Point3 A, Point3 B, Point3 C) { double ab = (A - B).length(); double bc = (B - C).length(); double ac = (A - C).length(); double p = (ab + bc + ac) / 2; double S = sqrt(p * (p - ab) * (p - bc) * (p - ac)); return S; } void solve() { double S1 = getS(ps[0], ps[1], ps[2]); //3 double S2 = getS(ps[0], ps[1], ps[3]); //2 double S3 = getS(ps[0], ps[2], ps[3]); //1 double S4 = getS(ps[3], ps[1], ps[2]); //0 double h = calc(ps[3], ps[0], ps[1], ps[2]); double V = S1 * h; double sum = S1 + S2 + S3 + S4; double R = V / (sum); double x = (ps[0].x * S4 + ps[1].x * S3 + ps[2].x * S2 + ps[3].x * S1); x /= sum; double y = (ps[0].y * S4 + ps[1].y * S3 + ps[2].y * S2 + ps[3].y * S1); y /= sum; double z = (ps[0].z * S4 + ps[1].z * S3 + ps[2].z * S2 + ps[3].z * S1); z /= sum; printf(&quot;%.4f %.4f %.4f %.4f\n&quot;, x, y, z, R); } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); clock_t _ = clock(); while(read()) { if(!judge()) { puts(&quot;O O O O&quot;); continue; } solve(); } #ifdef LOCAL printf(&quot;\nTime cost: %.2fs\n&quot;, 1.0 * (clock() - _) / CLOCKS_PER_SEC); #endif return 0; }]]></content>
      <categories>
        <category>计算几何</category>
        <category>三维几何</category>
      </categories>
      <tags>
        <tag>三维几何</tag>
        <tag>四面体内心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5732 Subway（树哈希）]]></title>
    <url>%2F2016%2F07%2F24%2FHDU%205732%20Subway%EF%BC%88%E6%A0%91%E5%93%88%E5%B8%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $给定N\le 10^5个节点的2棵树，保证2棵树同构$$输出一种2棵树的节点映射方式$ 分析： $树同构，想一个和节点顺序无关的哈希函数将树表示$$一种方法：首先找树的中点，然后将中点作为根$$叶子节点哈希值为1，对于每一颗树，把它的所有子树的哈希 值排序，然后算出新的哈希值作为总体的哈希值$$有2个中点的树2个中点都试一下。为了保险可以检查下哈希值有没有重的$$双hash速度跟标程一样。。所以还不如。$$直接$map&lt;vector&lt;int&gt;, int&gt;$搞都行。。10^5的数据只有2个$$时间复杂度O(nlogn)$ 代码: // // Created by TaoSama on 2016-07-21 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; typedef long long LL; const LL seed[2] = {999999937, 999999929}; const LL mod[2] = {1000000007, 1000000009}; //1e9+7/+9 struct Hash { LL h[2]; Hash() {} Hash(const LL&amp; first) { for(int i = 0; i &lt; 2; ++i) h[i] = first; } Hash operator+(const Hash&amp; rhs) const { Hash ret = *this; for(int i = 0; i &lt; 2; ++i) { ret.h[i] = ret.h[i] * seed[i] % mod[i]; if((ret.h[i] += rhs.h[i]) &gt;= mod[i]) ret.h[i] -= mod[i]; } return ret; } bool operator&lt;(const Hash&amp; rhs) const { return make_pair(h[0], h[1]) &lt; make_pair(rhs.h[0], rhs.h[1]); } bool operator==(const Hash&amp; rhs) const { return make_pair(h[0], h[1]) == make_pair(rhs.h[0], rhs.h[1]); } void see() { printf(&quot;(%llu %llu)\n&quot;, h[0], h[1]); } }; int n; vector&lt;int&gt; G[2][N]; void getDiameter(int u, int f, int d, int idx, pair&lt;int, int&gt;&amp; diameter) { diameter = max(diameter, make_pair(d, u)); vector&lt;int&gt;&amp; cur = G[idx][u]; for(auto&amp; v : cur) { if(v == f) continue; getDiameter(v, u, d + 1, idx, diameter); } } bool getPath(int u, int f, int t, int idx, vector&lt;int&gt;&amp; path) { path.push_back(u); if(u == t) return true; vector&lt;int&gt;&amp; cur = G[idx][u]; for(auto&amp; v : cur) { if(v == f) continue; if(getPath(v, u, t, idx, path)) return true; } path.pop_back(); return false; } vector&lt;pair&lt;Hash, int&gt; &gt; treeHash[2][N]; Hash getHash(int u, int f, int idx) { vector&lt;int&gt;&amp; cur = G[idx][u]; vector&lt;pair&lt;Hash, int&gt; &gt; sons; for(auto&amp; v : cur) { if(v == f) continue; sons.push_back({getHash(v, u, idx), v}); } Hash h(1); sort(sons.begin(), sons.end()); for(auto&amp; v : sons) h = h + v.first; treeHash[idx][u].swap(sons); return h; } map&lt;string, int&gt; mp[2]; vector&lt;string&gt; names[2]; int ID(string s, int idx) { if(mp[idx].count(s)) return mp[idx][s]; names[idx].push_back(s); mp[idx][s] = names[idx].size(); return mp[idx][s]; } void init(int idx) { mp[idx].clear(); names[idx].clear(); for(int i = 1; i &lt;= n; ++i) G[idx][i].clear(); } void OLE(string s) { while(1) puts(s.c_str()); } void RE() { printf(&quot;%d\n&quot;, *((int*)0)); } bool match(vector&lt;pair&lt;Hash, int&gt; &gt;&amp; cur, vector&lt;pair&lt;Hash, int&gt; &gt;&amp; nxt, vector&lt;pair&lt;int, int&gt; &gt;&amp; ans) { if(cur.size() != nxt.size()) return false; int cnt = 0; for(int i = 0; i &lt; cur.size(); ++i) { bool ok = false; for(int j = i; j &lt; nxt.size() &amp;&amp; cur[i].first == nxt[j].first; ++j) { swap(nxt[i], nxt[j]); if(match(treeHash[0][cur[i].second], treeHash[1][nxt[i].second], ans)) { ++cnt; ok = true; ans.push_back({cur[i].second, nxt[i].second}); break; } } if(!ok) { while(cnt--) ans.pop_back(); return false; } } return true; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\1010.in&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;, &quot;w&quot;, stdout); #endif ios_base::sync_with_stdio(0); clock_t _ = clock(); while(scanf(&quot;%d&quot;, &amp;n) == 1) { for(int i = 0; i &lt; 2; ++i) { init(i); for(int j = 1; j &lt; n; ++j) { char a[20], b[20]; scanf(&quot;%s%s&quot;, a, b); int u = ID(a, i), v = ID(b, i); // printf(&quot;%d-&gt;%d\n&quot;, u, v); G[i][u].push_back(v); G[i][v].push_back(u); } // puts(&quot;&quot;); } vector&lt;pair&lt;Hash, int&gt; &gt; hashes[2]; for(int i = 0; i &lt; 2; ++i) { pair&lt;int, int&gt; diameter = { -INF, -INF}; getDiameter(1, -1, 0, i, diameter); int u = diameter.second; diameter = { -INF, -INF}; getDiameter(u, -1, 0, i, diameter); int v = diameter.second; // printf(&quot;diameter %d -&gt; %d\n&quot;, u, v); vector&lt;int&gt; path; getPath(u, -1, v, i, path); int sz = path.size(); int x = path[sz &gt;&gt; 1], y = -1; if(~path.size() &amp; 1) y = path[sz / 2 - 1]; hashes[i].push_back({getHash(x, y, i), x}); if(~y) hashes[i].push_back({getHash(y, x, i), y}); // printf(&quot;start %d %d\n&quot;, x, y); sort(hashes[i].begin(), hashes[i].end()); } vector&lt;pair&lt;int, int&gt; &gt; ans; if(!match(hashes[0], hashes[1], ans)) RE(); // prln(ans.size()); if(ans.size() != n) OLE(&quot;WA&quot;); for(int i = 0; i &lt; ans.size(); ++i) { int u, v; tie(u, v) = ans[i]; printf(&quot;%s %s\n&quot;, names[0][u - 1].c_str(), names[1][v - 1].c_str()); } } #ifdef LOCAL printf(&quot;\nTime cost: %.2fs\n&quot;, 1.0 * (clock() - _) / CLOCKS_PER_SEC); #endif return 0; }]]></content>
      <categories>
        <category>技巧</category>
        <category>哈希</category>
      </categories>
      <tags>
        <tag>树哈希</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5730 Shell Necklace（dp、cdq分治+FFT）]]></title>
    <url>%2F2016%2F07%2F24%2FHDU%205730%20Shell%20Necklace%EF%BC%88dp%E3%80%81cdq%E5%88%86%E6%B2%BB%2BFFT%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $给定N\le 10^5个贝壳的项链，每连续i\le N个贝壳模式的贡献是a_i$$对于某种串项链的方式，假设含有模式b_1, b_2, \cdots, b_m，总贡献为\prod_{i=1}^m a_{b_i} $$求所有串项链方式的贡献和$ 分析： $首先有显然的dp，f[i]:=以i结尾的贝壳的贡献和$$f[i]=\sum_{j=1}^i f[i-j]\times a_j$$但是转移是O(n)的，总复杂度是O(n^2)，考虑优化$$发现转移是个卷积形式，由于模数不是费马素数，所以cdq分治+FFT一波就好了$$时间复杂度是O(nlog^2n)$ 代码: // // Created by TaoSama on 2016-07-20 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; #include &lt;complex&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 313; const double PI = acos(-1); int n, a[N]; int f[N]; typedef complex&lt;double&gt; Complex; void rader(Complex* y, int len) { for(int i = 1, j = len / 2; i &lt; len - 1; i++) { if(i &lt; j) swap(y[i], y[j]); int k = len / 2; while(j &gt;= k) {j -= k; k /= 2;} if(j &lt; k) j += k; } } void fft(Complex* y, int len, int op) { rader(y, len); for(int h = 2; h &lt;= len; h &lt;&lt;= 1) { double ang = op * 2 * PI / h; Complex wn(cos(ang), sin(ang)); for(int j = 0; j &lt; len; j += h) { Complex w(1, 0); for(int k = j; k &lt; j + h / 2; k++) { Complex u = y[k]; Complex t = w * y[k + h / 2]; y[k] = u + t; y[k + h / 2] = u - t; w = w * wn; } } } if(op == -1) for(int i = 0; i &lt; len; i++) y[i] /= len; } Complex A[N &lt;&lt; 1], B[N &lt;&lt; 1]; void cdq(int l, int r) { if(l == r) return; int mid = (l + r) &gt;&gt; 1; cdq(l, mid); int len = 1; while(len &lt;= r - l + 1) len &lt;&lt;= 1; for(int i = 0; i &lt; len; i++) { A[i] = Complex(l + i &lt;= mid ? f[l + i] : 0, 0); B[i] = Complex(l + i + 1 &lt;= r ? a[i + 1] : 0, 0); } fft(A, len, 1); fft(B, len, 1); for(int i = 0; i &lt; len; i++) A[i] *= B[i]; fft(A, len, -1); for(int i = mid + 1; i &lt;= r; i++) { f[i] += fmod(A[i - l - 1].real(), MOD) + 0.5; if(f[i] &gt;= MOD) f[i] -= MOD; } cdq(mid + 1, r); } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); clock_t _ = clock(); while(scanf(&quot;%d&quot;, &amp;n) == 1 &amp;&amp; n) { for(int i = 1; i &lt;= n; ++i) { scanf(&quot;%d&quot;, a + i); a[i] %= MOD; } memset(f, 0, sizeof f); f[0] = 1; cdq(0, n); printf(&quot;%d\n&quot;, f[n]); } #ifdef LOCAL printf(&quot;\nTime cost: %.2fs\n&quot;, 1.0 * (clock() - _) / CLOCKS_PER_SEC); #endif return 0; }]]></content>
      <categories>
        <category>数学</category>
        <category>FFT/NTT/FWT</category>
      </categories>
      <tags>
        <tag>FFT</tag>
        <tag>cdq分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5726 GCD（dp、倍增）]]></title>
    <url>%2F2016%2F07%2F24%2FHDU%205726%20GCD%EF%BC%88dp%E3%80%81%E5%80%8D%E5%A2%9E%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $给定一个N\le 10^5个数，|A_i| \le 10^9，Q\le 10^5次询问$$定义gcd(l, r)=gcd(a_l, a_{l+1}, \cdots, a_r)$$每次询问给定一个[l, r]，查询\forall_{1\le l’\le r’\le N}，gcd(l’, r’)=gcd(l, r)的(l’, r’)个数$ 分析： vector&lt;pair&lt;int, int&gt; &gt;$ f[i]:=以i结尾的区间，且gcd为first，个数为second$$由于1个数有log级别的质因子个数，所以不同的gcd的个数也是log级别的$$这样就可以通过dp预处理出全局的mp[g]:=gcd为g的区间个数$$之后再通过倍增预处理出g[i][j]:=以i开始向右长度为2^j的gcd$$对于每次询问就可以类似RMQ的做法O(1)求出gcd(l, r)了$$总时间复杂度为O(nlog^2n)$ 代码: // // Created by TaoSama on 2016-07-20 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; typedef long long LL; int n, a[N]; vector&lt;pair&lt;int, int&gt; &gt; f[2]; map&lt;int, LL&gt; mp; int g[17][N]; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); clock_t _ = clock(); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, a + i); mp.clear(); int p = 0; f[p].clear(); f[p].push_back({0, 1}); for(int i = 1; i &lt;= n; ++i) { f[!p].clear(); f[!p].push_back({0, 1}); for(auto&amp; u : f[p]) { int x, cnt; tie(x, cnt) = u; x = __gcd(x, a[i]); bool ok = true; for(auto&amp; v : f[!p]) { if(x == v.first) { ok = false; v.second += cnt; break; } } if(ok) f[!p].push_back({x, cnt}); // printf(&quot;%d: %d %d\n&quot;, i, x, cnt); mp[x] += cnt; //global } p = !p; } for(int i = 1; i &lt;= n; ++i) g[0][i] = a[i]; for(int i = 1; 1 &lt;&lt; i &lt;= n; ++i) for(int j = 1; j &lt;= n; ++j) g[i][j] = __gcd(g[i - 1][j], g[i - 1][j + (1 &lt;&lt; i - 1)]); static int kase = 0; printf(&quot;Case #%d:\n&quot;, ++kase); int q; scanf(&quot;%d&quot;, &amp;q); while(q--) { int l, r; scanf(&quot;%d%d&quot;, &amp;l, &amp;r); int k = 31 - __builtin_clz(r - l + 1); int gcd = __gcd(g[k][l], g[k][r - (1 &lt;&lt; k) + 1]); printf(&quot;%d %I64d\n&quot;, gcd, mp[gcd]); } } #ifdef LOCAL printf(&quot;\nTime cost: %.2fs\n&quot;, 1.0 * (clock() - _) / CLOCKS_PER_SEC); #endif return 0; }]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>倍增</tag>
        <tag>gcd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5727 Necklace（二分图最大匹配）]]></title>
    <url>%2F2016%2F07%2F24%2FHDU%205727%20Necklace%EF%BC%88%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $给定2\times N个珠子的环，其中N个为yang，N个为yin，N\le 9$$给定M\le N\times N个限制关系$$对于每个限制关系a_i, b_i，表示yang a_i会变暗如果与yin b_i相邻$$求最少的暗淡yang珠子数$ 分析： $由于是环，所以固定第1个珠子为1，然后8！枚举yin珠子的排列$$之后对于每2个yin珠子的间隔，与yang珠子建图，表示这个yang珠子不会暗淡$$跑二分图匹配，最大匹配数就是最大的不会暗淡的$$ans=n-maxMatch$$实际上匈牙利很快，然后如果都不暗淡提前退出就可以过去了$$集训队的不带剪枝都过去了，不知道为啥窝自带百倍常数$$时间复杂度O(8!\times nm)$ 代码: // // Created by TaoSama on 2016-07-20 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 10 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, m; int conflict[N][N]; struct Edge { int v, nxt; } edge[N * N]; int head[N], cnt; void addEdge(int u, int v) { edge[cnt] = {v, head[u]}; head[u] = cnt++; } int match[N], vis[N]; bool dfs(int u) { for(int i = head[u]; ~i; i = edge[i].nxt) { int v = edge[i].v; if(vis[v]) continue; vis[v] = true; if(match[v] == -1 || dfs(match[v])) { match[v] = u; return true; } } return false; } int hungary() { int matches = 0; memset(match, -1, sizeof match); for(int i = 1; i &lt;= n; ++i) { memset(vis, 0, sizeof vis); matches += dfs(i); } return matches; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); clock_t _ = clock(); while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) == 2) { memset(conflict, 0, sizeof conflict); for(int i = 1; i &lt;= m; ++i) { int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); conflict[u][v] = 1; //yang yin } int ans = -INF; //yin int ord[N]; ord[n + 1] = 1; for(int i = 1; i &lt;= n; ++i) ord[i] = i; do { // for(int i = 1; i &lt;= n + 1; ++i) printf(&quot;%d &quot;, ord[i]); puts(&quot;&quot;); cnt = 0; memset(head, -1, sizeof head); for(int i = 1; i &lt;= n; ++i) { //gap int l = ord[i], r = ord[i + 1]; for(int j = 1; j &lt;= n; ++j) { //yang if(conflict[j][l] || conflict[j][r]) continue; // printf(&quot;%d, %d\n&quot;, i, j); addEdge(i, j); } } if(cnt &lt;= ans) continue; ans = max(ans, hungary()); if(ans == n) break; } while(next_permutation(ord + 2, ord + n + 1)); printf(&quot;%d\n&quot;, n - ans); } #ifdef LOCAL printf(&quot;\nTime cost: %.2fs\n&quot;, 1.0 * (clock() - _) / CLOCKS_PER_SEC); #endif return 0; }]]></content>
      <categories>
        <category>图论</category>
        <category>连通图</category>
      </categories>
      <tags>
        <tag>二分图最大匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5724 Chess（sg打表）]]></title>
    <url>%2F2016%2F07%2F24%2FHDU%205724%20Chess%EF%BC%88sg%E6%89%93%E8%A1%A8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $给定一个N\times 20的棋盘，N\le 1000，每行有一些位置有棋子$$定义一个操作：任意选择1个棋子恰好向右移动1个空位，或者越过连续的一些棋子到一个空位$$现在2人轮流操作，且最优操作，问先手输赢情况$ 分析： $首先发现每行可以作为1个独立游戏$$之后2^{20}并不是很大，暴力打出sg值的表，然后合并一下就做完了$$时间复杂度O(20\times 2^{20})$ 代码: // // Created by TaoSama on 2016-07-20 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n; int sg[1 &lt;&lt; 20]; int getSg(int x) { if(~sg[x]) return sg[x]; bool mark[100]; memset(mark, 0, sizeof mark); for(int i = 0, j; i &lt; 20; ++i) { if(x &gt;&gt; i &amp; 1) { for(j = i + 1; (x &gt;&gt; j &amp; 1) &amp;&amp; j &lt; 20; ++j); if(j == 20) continue; int y = x ^ (1 &lt;&lt; i) | (1 &lt;&lt; j); mark[getSg(y)] = 1; } } for(int i = 0; ; ++i) if(!mark[i]) return sg[x] = i; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); clock_t _ = clock(); memset(sg, -1, sizeof sg); for(int i = 0; i &lt; 1 &lt;&lt; 20; ++i) getSg(i); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%d&quot;, &amp;n); int ans = 0; for(int i = 1; i &lt;= n; ++i) { int cur = 0; int k; scanf(&quot;%d&quot;, &amp;k); while(k--) { int x; scanf(&quot;%d&quot;, &amp;x); cur |= 1 &lt;&lt; x - 1; } ans ^= sg[cur]; } puts(ans ? &quot;YES&quot; : &quot;NO&quot;); } #ifdef LOCAL printf(&quot;\nTime cost: %.2fs\n&quot;, 1.0 * (clock() - _) / CLOCKS_PER_SEC); #endif return 0; }]]></content>
      <categories>
        <category>数学</category>
        <category>博弈</category>
      </categories>
      <tags>
        <tag>sg函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5720 Wool（扫描线）]]></title>
    <url>%2F2016%2F06%2F20%2FHDU%205720%20Wool%EF%BC%88%E6%89%AB%E6%8F%8F%E7%BA%BF%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $给定N\le 10^5个长度为A_i\le 10^{18}的线段，现有[L, R]的区间长度的线段$$问哪些长度不能与已有线段构成三角形$ 分析： $考虑三角形的边b，对于任意的a，那么c\in (a-b, a+b)$$现在要贪心使得这个区间长度L=2b最大，令a\ge b，那么就选择最大的那个b$$只要排序一波就可以得到所有的合法区间了$$扫描线合并一波，最后ans=R-L+1-tot$$时间复杂度O(nlogn)$ 代码: // // Created by TaoSama on 2016-07-20 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n; typedef long long LL; LL a[N], l, r; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); clock_t _ = clock(); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%d%I64d%I64d&quot;, &amp;n, &amp;l, &amp;r); for(int i = 1; i &lt;= n; ++i) scanf(&quot;%I64d&quot;, a + i); sort(a + 1, a + 1 + n); map&lt;LL, int&gt; mp; for(int i = 2; i &lt;= n; ++i) { LL c = a[i] - a[i - 1] + 1; LL d = a[i] + a[i - 1] - 1; c = max(c, l); d = min(d, r); ++mp[c]; --mp[d + 1]; } int sum = 0; LL last = mp.begin()-&gt;first, ans = 0; for(auto&amp; p : mp) { if(sum &gt;= 1) { ans += p.first - last; } sum += p.second; last = p.first; } ans = r - l + 1 - ans; printf(&quot;%I64d\n&quot;, ans); } #ifdef LOCAL printf(&quot;\nTime cost: %.2fs\n&quot;, 1.0 * (clock() - _) / CLOCKS_PER_SEC); #endif return 0; }]]></content>
      <categories>
        <category>思维</category>
        <category>扫描线</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 361 (Div. 2) E. Mike and Geometry Problem（扫描线）]]></title>
    <url>%2F2016%2F06%2F20%2FCodeforces%20Round%20361%20(Div.%202)%20E.%20Mike%20and%20Geometry%20Problem%EF%BC%88%E6%89%AB%E6%8F%8F%E7%BA%BF%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $给定N\le 2\times 10^5个线段，现任意选出K\le N个线段，求任意K个线段交点个数和$ 分析： $考虑每个点的贡献，问题就转换成了扫描线统计覆盖\ge K次的线段$$对于每个这样的线段，对答案的贡献是C_n^k$$时间复杂度O(nlogn)$ 代码: // // Created by TaoSama on 2016-07-20 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 2e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, k; int a[N]; typedef long long LL; LL fact[N], finv[N]; LL quick(LL x, LL n) { LL ret = 1; for(; n; n &gt;&gt;= 1) { if(n &amp; 1) ret = ret * x % MOD; x = x * x % MOD; } return ret; } LL C(int n, int m) { return fact[n] * finv[m] % MOD * finv[n - m] % MOD; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); clock_t _ = clock(); fact[0] = finv[0] = 1; for(int i = 1; i &lt; N; ++i) { fact[i] = fact[i - 1] * i % MOD; finv[i] = quick(fact[i], MOD - 2); } while(scanf(&quot;%d%d&quot;, &amp;n, &amp;k) == 2) { map&lt;int, int&gt; mp; for(int i = 1; i &lt;= n; ++i) { int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); ++mp[x]; --mp[y + 1]; } int sum = 0, ans = 0; int last = mp.begin()-&gt;first; for(auto&amp; p : mp) { if(sum &gt;= k) { ans += C(sum, k) * (p.first - last) % MOD; if(ans &gt;= MOD) ans -= MOD; } sum += p.second; last = p.first; } printf(&quot;%d\n&quot;, ans); } #ifdef LOCAL printf(&quot;\nTime cost: %.2fs\n&quot;, 1.0 * (clock() - _) / CLOCKS_PER_SEC); #endif return 0; }]]></content>
      <categories>
        <category>数学</category>
        <category>贡献</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2016 计蒜之道 微软的员工福利 （简单、中等）（dp）]]></title>
    <url>%2F2016%2F06%2F12%2F2016%20%E8%AE%A1%E8%92%9C%E4%B9%8B%E9%81%93%20%20%E5%BE%AE%E8%BD%AF%E7%9A%84%E5%91%98%E5%B7%A5%E7%A6%8F%E5%88%A9%20%EF%BC%88%E7%AE%80%E5%8D%95%E3%80%81%E4%B8%AD%E7%AD%89%EF%BC%89%EF%BC%88dp%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $给定一颗N个节点的树，根为1，每个点可以在2种物品价值中2选1$$每个节点会减少一定的价值f_i，其中x_i为所有直接儿子选择物品的极差(最大值-最小值)$$$f_i=\lceil{x_i\over 1000}\rceil\times 666\times i $$$求所有员工最大满意度的和$ 分析： $对于N\le 15的，直接二进制枚举谁拿第一种就好了，然后就做完了$$对于N\le 100的：$$显然的状态f[u][c]:=以u为根的子树，且这个点颜色是c(c=0第一种)的最大满意度和$$转移的时候就枚举最大值和最小值，他们的个数都是O(n)个的，所以转移O(n^2)$$总时间复杂度为O(n^3)$$细节比较多，需要仔细，具体看代码$$对于N\le 10^5的不会做。。其实看出来这个转移冗余很多，需要更多的性质，题解好神。$ 代码一: // // Created by TaoSama on 2016-06-11 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; typedef long long LL; int n; vector&lt;int&gt; G[N], T[N]; int r[N], p[N]; void dfs(int u, int f) { for(int v : G[u]) { if(v == f) continue; T[u].push_back(v); dfs(v, u); } } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); clock_t _ = clock(); while(scanf(&quot;%d&quot;, &amp;n) == 1) { for(int i = 0; i &lt; n; ++i) { scanf(&quot;%d%d&quot;, r + i, p + i); G[i].clear(); T[i].clear(); } for(int i = 1; i &lt; n; ++i) { int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); --x; --y; G[x].push_back(y); G[y].push_back(x); } dfs(0, -1); LL ans = -1e18; for(int i = 0; i &lt; 1 &lt;&lt; n; ++i) { int b[20] = {}; for(int j = 0; j &lt; n; ++j) if(i &gt;&gt; j &amp; 1) b[j] = r[j]; else b[j] = p[j]; LL tmp = 0; for(int j = 0; j &lt; n; ++j) { int maxv, minv; maxv = minv = b[j]; for(int son : T[j]) { maxv = max(maxv, b[son]); minv = min(minv, b[son]); } LL diff = maxv - minv; LL delta = 1LL * (diff + 999) / 1000 * 666 * (j + 1); tmp += b[j] - delta; } ans = max(ans, tmp); } printf(&quot;%lld\n&quot;, ans); } #ifdef LOCAL printf(&quot;\nTime cost: %.2fs\n&quot;, 1.0 * (clock() - _) / CLOCKS_PER_SEC); #endif return 0; } 代码二： // // Created by TaoSama on 2016-06-12 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, val[N][2]; vector&lt;int&gt; G[N]; int f[N][2]; void dfs(int u, int fa) { f[u][0] = f[u][1] = 0; vector&lt;int&gt; sons; for(int v : G[u]) { if(v == fa) continue; sons.push_back(v); dfs(v, u); } for(int i = 0; i &lt; 2; ++i) { int x = val[u][i], cur = -INF; vector&lt;int&gt; big, small; big.push_back(u); small.push_back(u); for(int v : sons) { if(val[v][0] &gt;= x || val[v][1] &gt;= x) big.push_back(v); if(val[v][0] &lt;= x || val[v][1] &lt;= x) small.push_back(v); } for(int a : big) { for(int j = 0; j &lt; 2; ++j) { if(a == u &amp;&amp; i != j) continue; int maxv = val[a][j]; if(maxv &lt; x) continue; for(int b : small) { for(int k = 0; k &lt; 2; ++k) { if(b == u &amp;&amp; i != k) continue; if(a == b &amp;&amp; j != k) continue; int minv = val[b][k]; if(minv &gt; x) continue; int tmp = f[a][j], ok = 1; if(a != b) tmp += f[b][k]; //fuck for(int v : sons) { if(v == a || v == b) continue; int choice = -INF; for(int c = 0; c &lt; 2; ++c) { int y = val[v][c]; if(y &lt; minv || y &gt; maxv) continue; choice = max(choice, f[v][c]); } if(choice == -INF) {ok = 0; break;} tmp += choice; } if(!ok) continue; int diff = maxv - minv; int delta = (diff + 999) / 1000 * 666 * u; cur = max(cur, tmp + x - delta); } } } } f[u][i] = cur; } } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); clock_t _ = clock(); while(scanf(&quot;%d&quot;, &amp;n) == 1) { for(int i = 1; i &lt;= n; ++i) for(int j = 0; j &lt; 2; ++j) scanf(&quot;%d&quot;, val[i] + j); for(int i = 1; i &lt;= n; ++i) G[i].clear(); for(int i = 1; i &lt; n; ++i) { int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); } dfs(1, -1); // for(int i = 1; i &lt;= n; ++i) { // for(int j = 0; j &lt; 2; ++j) // printf(&quot;f[%d][%d] = %d\n&quot;, i, j, f[i][j]); // } printf(&quot;%d\n&quot;, max(f[1][0], f[1][1])); } #ifdef LOCAL printf(&quot;\nTime cost: %.2fs\n&quot;, 1.0 * (clock() - _) / CLOCKS_PER_SEC); #endif return 0; }]]></content>
      <categories>
        <category>动态规划</category>
        <category>树形dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2016 计蒜之道 百度帐号的选取方案 （中等）（kmp、dp）]]></title>
    <url>%2F2016%2F06%2F12%2F2016%20%E8%AE%A1%E8%92%9C%E4%B9%8B%E9%81%93%20%E7%99%BE%E5%BA%A6%E5%B8%90%E5%8F%B7%E7%9A%84%E9%80%89%E5%8F%96%E6%96%B9%E6%A1%88%20%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89%EF%BC%88kmp%E3%80%81dp%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $字符串的循环次数：由某个子串形成字符串的最多重复次数$$给定L\le 10^3的字符串，现从中选取2个不相交的子串，使得2个子串循环次数相同$$问方法数$ 分析： $根据kmp的nxt数组，字符串的最小Cycle = l-nxt[l]$$字符串的最大循环次数Times=l \% Cycle ? 1:l/Cycle$$直接做l次求nxt就可以得到p[l][r]:=s[l\cdots r]子串的循环次数$$预处理f[i][p]:=以i开头，且循环次数为p的子串个数$$然后我们枚举左边的这个子串s[l][r]，累加右边suf[r+1][p[l][r]]就可以了$$预处理复杂度O(n^2)，dp也是O(n^2)，总复杂度O(n^2)$ 代码: // // Created by TaoSama on 2016-06-05 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e3 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; char s[N]; int n, nxt[N], p[N][N]; typedef long long LL; LL suf[N][N]; void getNxt(int st) { nxt[st] = st - 1; for(int i = st, j = st - 1; i &lt; n;) { if(j == st - 1 || s[i] == s[j]) nxt[++i] = ++j; else j = nxt[j]; } } int getTimes(int l, int r) { int len = r - l, cycle = len - (nxt[r] - l); return len % cycle ? 1 : len / cycle; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); clock_t _ = clock(); while(scanf(&quot;%s&quot;, s) == 1) { n = strlen(s); memset(suf, 0, sizeof suf); for(int i = 0; i &lt; n; ++i) { getNxt(i); for(int j = i; j &lt; n; ++j) { p[i][j] = getTimes(i, j + 1); ++suf[i][p[i][j]]; } } for(int i = n - 1; ~i; --i) for(int j = 1; j &lt;= n; ++j) suf[i][j] += suf[i + 1][j]; LL ans = 0; for(int i = 0; i &lt; n; ++i) for(int j = i; j &lt; n; ++j) ans += suf[j + 1][p[i][j]]; printf(&quot;%lld\n&quot;, ans); } #ifdef LOCAL printf(&quot;\nTime cost: %.2fs\n&quot;, 1.0 * (clock() - _) / CLOCKS_PER_SEC); #endif return 0; }]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>kmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5212 ZZX and Permutations（置换、线段树）]]></title>
    <url>%2F2016%2F06%2F04%2FHDU%205212%20ZZX%20and%20Permutations%EF%BC%88%E7%BD%AE%E6%8D%A2%E3%80%81%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $给定一个N\le 10^5的置换序列的Cycle Notation，然后现在把括号删掉了$$现在求一个加上括号的Cycle Notation的原始置换序列$$但要求输出最大字典序的$ 分析： $稍微懂点置换的思路的都可以看出这个规律：$$从Cycle Notation中找多个环出来，由于最大字典序$$找到1的时候，肯定填合法的最大的那个数$$能填的数就右边第一个，以及左边到自己 没使用过的任意一个$$看看谁大就填谁，如果是一种直接填，第二种就把这堆数直接成环了$$对于怎么模拟呢，赛上想多了，线段树上二分写不出，无奈写了二分+线段树T了$$主要是我自己太纠结于这个已经成环和已经使用的区分了。。导致写法爆炸。。$$然后队友不懂置换不能给我实质性的帮助，我自己也是逗比，深层次的总结写法能力弱$$事实上只要动态维护最大值就可以了，用过的从线段树中删除就行了。。$$至于查询区间，也就是第二种情况，只用维护成环的就好了。。$$这个只要用set来维护那些成环的区间就好了，每次二分查找一下当前可用的区间$$这样这个题的代码就非常简单了。。$$时间复杂度线段树和set都是logn每次，总复杂度O(nlogn)$ 代码: // // Created by TaoSama on 2016-05-26 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; #include &lt;cassert&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, a[N], wh[N], ans[N]; #define MP make_pair struct SegTree { int lazy[N &lt;&lt; 2], maxv[N &lt;&lt; 2]; void up(int rt) { maxv[rt] = max(maxv[rt &lt;&lt; 1], maxv[rt &lt;&lt; 1 | 1]); } void down(int rt) { if(lazy[rt]) { int ls = rt &lt;&lt; 1, rs = ls | 1; lazy[ls] = lazy[rs] = lazy[rt]; maxv[ls] = maxv[rs] = lazy[rt] = 0; } } void build(int l, int r, int rt) { lazy[rt] = 0; if(l == r) { maxv[rt] = a[l]; return; } int m = l + r &gt;&gt; 1; build(l, m, rt &lt;&lt; 1); build(m + 1, r, rt &lt;&lt; 1 | 1); up(rt); } void del(int L, int R, int l, int r, int rt) { if(L &lt;= l &amp;&amp; r &lt;= R) { lazy[rt] = 1; maxv[rt] = 0; return ; } int m = l + r &gt;&gt; 1; down(rt); if(L &lt;= m) del(L, R, l, m, rt &lt;&lt; 1); if(R &gt; m) del(L, R, m + 1, r, rt &lt;&lt; 1 | 1); up(rt); } int query(int L, int R, int l, int r, int rt) { if(L &lt;= l &amp;&amp; r &lt;= R) return maxv[rt]; int m = l + r &gt;&gt; 1; down(rt); int ret = 0; if(L &lt;= m) ret = max(ret, query(L, R, l, m, rt &lt;&lt; 1)); if(R &gt; m) ret = max(ret, query(L, R, m + 1, r, rt &lt;&lt; 1 | 1)); return ret; } } T; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); clock_t _ = clock(); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, a + i), wh[a[i]] = i; T.build(1, n, 1); set&lt;pair&lt;int, int&gt; &gt; done; memset(ans, 0, sizeof ans); for(int i = 1; i &lt;= n; ++i) { if(ans[i]) continue; int p = wh[i]; int l = 1, r = min(n, p + 1); auto iter = done.lower_bound({p, p}); if(iter != done.begin()) l = (--iter)-&gt;second + 1; int maxv = T.query(l, r, 1, n, 1); int from = wh[maxv]; if(from == p + 1) { ans[a[p]] = a[from]; T.del(from, from, 1, n, 1); //delete } else { //link for(int j = from; j &lt; p; ++j) ans[a[j]] = a[j + 1]; ans[a[p]] = a[from]; T.del(from, p, 1, n, 1); //delete done.insert({from, p}); //maintain the cycled intervals } } for(int i = 1; i &lt;= n; ++i) printf(&quot;%d%c&quot;, ans[i], &quot; \n&quot;[i == n]); } #ifdef LOCAL printf(&quot;\nTime cost: %.2fs\n&quot;, 1.0 * (clock() - _) / CLOCKS_PER_SEC); #endif return 0; }]]></content>
      <categories>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 355 (Div. 2) D. Vanya and Treasure（dp、二维BIT优化）]]></title>
    <url>%2F2016%2F06%2F03%2FCodeforces%20Round%20355%20(Div.%202)%20D.%20Vanya%20and%20Treasure%EF%BC%88dp%E3%80%81%E4%BA%8C%E7%BB%B4BIT%E4%BC%98%E5%8C%96%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N，M\le 300，P\le N\times M，给定一个N\times M图，每个格子A_{ij}是1\sim P的数字$$从(1, 1)出发，两个格子的距离定义为曼哈顿距离，按顺序取1\sim P的数字$$问最短路是多少$ 分析： $我们有一个显然的dp状态，f[x][y]:=到达(x, y)这个格子，并且取到数字的最短路$$f[x_2][y_2]=min\{ f[x_1][y_1]+dis((x_1,y_1), (x_2,y_2)) \},A[x_1][y_1]=i-1,A[x_2][y_2]=i$$裸的转移是O(nm)的，总复杂度就是O((nm)^2)了，显然是不行的，考虑优化$$优化一：$$令cnt[i]:=i这个数字的个数，当cnt[i-1]\times cnt[i]\le n\times m的时候直接更新，否则bfs一波$$这个时间复杂度是O(nm\sqrt{nm})，如果有人懂详细证明请教我。。$$优化二：$$我们展开这个dp转移方程：$$f[x_2][y_2]=min\{ f[x_1][y_1]+abs(x_1-x_2)+abs(y_1-y_2) \}$$发现对于曼哈顿距离其实有4种情况，根据x和y的大小关系，方便起见画个图：$$A点为我们当前要更新的点，B0\sim B3为代表根据x和y大小划分的4个区域$$我们可以得到新的转移方程：$$UL - f[x_2][y_2] = min \{ f[x_1][y_1] - x_1 - y_1 + x_2 + y_2 \}, B0区域$$UR - f[x_2][y_2] = min \{ f[x_1][y_1] + x_1 - y_1 - x_2 + y_2 \}, B1区域$$BR - f[x_2][y_2] = min \{ f[x_1][y_1] + x_1 + y_1 - x_2 - y_2 \}, B2区域$$BL - f[x_2][y_2] = min \{ f[x_1][y_1] - x_1 + y_1 + x_2 - y_2 \}, B3区域$$对于当前点A(x_2, y_2)来说，转移方程中关于x_2和y_2的部分是常数$$对于f[x_1][y_1]以及x_1和y_1的部分来说，是矩形区域，我们可以用二维线段树来维护$$观察这4个区域，发现不是前缀区域就是后缀区域，所以我们用4个二维BIT就可以了$$维护后缀区域只要转化一下就好了，具体见代码$ 代码一: // // Created by TaoSama on 2016-06-02 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 300 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, m, p; int s[N][N]; typedef pair&lt;int, int&gt; P; vector&lt;P&gt; G[N * N]; int f[N][N]; void getMin(int&amp; x, int y) { if(x &gt; y) x = y; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); clock_t _ = clock(); scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;p); for(int i = 1; i &lt;= n; ++i) { for(int j = 1; j &lt;= m; ++j) { scanf(&quot;%d&quot;, s[i] + j); G[s[i][j]].push_back({i, j}); f[i][j] = s[i][j] == 1 ? i + j - 2 : INF; } } for(int i = 1; i &lt; p; ++i) { vector&lt;P&gt;&amp; cur = G[i], &amp;nxt = G[i + 1]; int delta = cur.size() * nxt.size(); if(delta &lt;= n * m) { for(P&amp; u : cur) { for(P&amp; v : nxt) { int d = abs(u.first - v.first) + abs(u.second - v.second); getMin(f[v.first][v.second], f[u.first][u.second] + d); } } } else { static vector&lt;P&gt; q; q.clear(); static int d[N][N], in[N][N]; memset(d, 0x3f, sizeof d); memset(in, false, sizeof in); for(P&amp; u : cur) { q.push_back(u); in[u.first][u.second] = true; d[u.first][u.second] = f[u.first][u.second]; } static int dir[][2] = { -1, 0, 0, -1, 1, 0, 0, 1}; for(int j = 0; j &lt; q.size(); ++j) { P u = q[j]; in[u.first][u.second] = false; for(int k = 0; k &lt; 4; ++k) { P v = u; v.first += dir[k][0]; v.second += dir[k][1]; if(!s[v.first][v.second]) continue; if(d[v.first][v.second] &gt; d[u.first][u.second] + 1) { d[v.first][v.second] = d[u.first][u.second] + 1; if(!in[v.first][v.second]) { in[v.first][v.second] = true; q.push_back(v); } } } } for(P&amp; v : nxt) f[v.first][v.second] = d[v.first][v.second]; } } int x = G[p][0].first, y = G[p][0].second; printf(&quot;%d\n&quot;, f[x][y]); #ifdef LOCAL printf(&quot;\nTime cost: %.2fs\n&quot;, 1.0 * (clock() - _) / CLOCKS_PER_SEC); #endif return 0; } 代码二： // // Created by TaoSama on 2016-06-02 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; #include &lt;bitset&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 300 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, m, p; int s[N][N], f[N][N]; typedef pair&lt;int, int&gt; P; vector&lt;P&gt; G[N * N]; struct BIT { int n, b[N][N]; int timStp, vis[N][N]; void init(int _n) { n = _n; timStp = 1; memset(vis, 0, sizeof vis); } void newOne() { ++timStp; } void update(int x, int y, int v) { for(int i = x; i &lt;= n; i += i &amp; -i) { for(int j = y; j &lt;= n; j += j &amp; -j) { if(vis[i][j] != timStp) vis[i][j] = timStp, b[i][j] = INF; b[i][j] = min(b[i][j], v); } } } int query(int x, int y) { int ret = INF; for(int i = x; i; i -= i &amp; -i) for(int j = y; j; j -= j &amp; -j) if(vis[i][j] == timStp) ret = min(ret, b[i][j]); return ret; } } bit[4]; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); clock_t _ = clock(); scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;p); for(int i = 1; i &lt;= n; ++i) { for(int j = 1; j &lt;= m; ++j) { scanf(&quot;%d&quot;, s[i] + j); G[s[i][j]].push_back({i, j}); } } memset(f, 0x3f, sizeof f); int nm = max(n, m); for(int i = 0; i &lt; 4; ++i) bit[i].init(nm); //UL - f[x2][y2] = min { f[x1][y1] - x1 - y1 + x2 + y2 } //UR - f[x2][y2] = min { f[x1][y1] + x1 - y1 - x2 + y2 } //BR - f[x2][y2] = min { f[x1][y1] + x1 + y1 - x2 - y2 } //BL - f[x2][y2] = min { f[x1][y1] - x1 + y1 + x2 - y2 } for(int i = 0; i &lt; G[1].size(); ++i) { int x = G[1][i].first, y = G[1][i].second; f[x][y] = x + y - 2; bit[0].update(x, y, f[x][y] - x - y); bit[1].update(nm - x + 1, y, f[x][y] + x - y); bit[2].update(nm - x + 1, nm - y + 1, f[x][y] + x + y); bit[3].update(x, nm - y + 1, f[x][y] - x + y); } for(int i = 2; i &lt;= p; ++i) { for(int j = 0; j &lt; G[i].size(); ++j) { int x = G[i][j].first, y = G[i][j].second, val = INF; val = min(val, bit[0].query(x, y) + x + y); val = min(val, bit[1].query(nm - x + 1, y) - x + y); val = min(val, bit[2].query(nm - x + 1, nm - y + 1) - x - y); val = min(val, bit[3].query(x, nm - y + 1) + x - y); f[x][y] = val; } for(int j = 0; j &lt; 4; ++j) bit[j].newOne(); for(int j = 0; j &lt; G[i].size(); ++j) { int x = G[i][j].first, y = G[i][j].second; bit[0].update(x, y, f[x][y] - x - y); bit[1].update(nm - x + 1, y, f[x][y] + x - y); bit[2].update(nm - x + 1, nm - y + 1, f[x][y] + x + y); bit[3].update(x, nm - y + 1, f[x][y] - x + y); } } int x = G[p][0].first, y = G[p][0].second; printf(&quot;%d\n&quot;, f[x][y]); #ifdef LOCAL printf(&quot;\nTime cost: %.2fs\n&quot;, 1.0 * (clock() - _) / CLOCKS_PER_SEC); #endif return 0; }]]></content>
      <categories>
        <category>动态规划</category>
        <category>数据结构优化</category>
      </categories>
      <tags>
        <tag>二维BIT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 354 (Div. 2) E. The Last Fight Between Human and AI]]></title>
    <url>%2F2016%2F05%2F26%2FCodeforces%20Round%20354%20(Div.%202)%20E.%20The%20Last%20Fight%20Between%20Human%20and%20AI%2F</url>
    <content type="text"><![CDATA[题意： $给定一个N\le 10^5次多项式P(x)=a_nx^n+a_{n-1}x^{n-1}+\cdots+a_1x+a_0$$现2个人轮流随意填P(x)的系数，填过的不能再填$$现有一个多项式Q(x)=x-k，如果最终多项式P(x)可以整除Q(x)，那么后手赢$$有一部分系数数已经被2个人填了，?表示还没填$$现2个人最优操作的情况下，问后手是否能赢$ 分析： $假如所有系数a_i都是确定的，如果P(x)能被x-k整除$$说明x-k是P(x)的一个因子，显然x=k是P(x)=0的一个根，k\neq 0$$那么讨论一下k=0的情况：$$如果a[0]=0，那么Q(x)已经整除P(x)，反之则不能整除$$如果a[0]不确定，那么第一个填a[0]的人胜$$再仔细看一下k\neq 0的情况：$$如果系数全部确定的情况上面已经说了，代入x=k判断P(x)=0成立性$$对于不完全确定的情况，我们先看一下只有1个不确定的情况：$$令其他的确定系数的项的和为A，不确定的那项为a_ix^i$$由P(x)=A+a_ix^i=0得，a_i=-{A\over x^i}，由于a_i可以是实数$$那么最后一步的操作者有必胜策略$$这样分2种情况讨论，每种情况里又有2种情况讨论这题就做完了$ $对于如何算出P(k)，实际上只有从高位到低位乘起来$$如果中间大于N\times max\{A_i\}那么就无解了，然后判是不是0就好了$$当然对于zz选手的我，直接取很多素数对结果取模进行哈希判断也是可以哒$ 代码: // // Created by TaoSama on 2016-05-26 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, k; int a[N]; int calc(int mod) { int ret = 0; for(int i = n; ~i; --i) ret = (1LL * ret * k + a[i]) % mod; return ret; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); clock_t _ = clock(); while(scanf(&quot;%d%d&quot;, &amp;n, &amp;k) == 2) { int unknown = 0; for(int i = 0; i &lt;= n; ++i) { char buf[10]; scanf(&quot;%s&quot;, buf); a[i] = *buf == &#39;?&#39; ? INF : atoi(buf); unknown += a[i] == INF; } int used = n + 1 - unknown; if(k == 0) { //a[0] is 0 will win puts(a[0] == 0 || a[0] == INF &amp;&amp; (used &amp; 1) ? &quot;Yes&quot; : &quot;No&quot;); } else { if(!unknown) { bool ok = true; for(int i = 2e9; ; ++i) { if(calc(i)) {ok = false; break;} if(1.0 * (clock() - _) / CLOCKS_PER_SEC &gt; 0.95) break; } puts(ok ? &quot;Yes&quot; : &quot;No&quot;); } else puts(~(n + 1) &amp; 1 ? &quot;Yes&quot; : &quot;No&quot;); } } #ifdef LOCAL printf(&quot;\nTime cost: %.2fs\n&quot;, 1.0 * (clock() - _) / CLOCKS_PER_SEC); #endif return 0; }]]></content>
      <categories>
        <category>技巧</category>
        <category>哈希</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[背包问题（01背包、完全背包、多重背包）]]></title>
    <url>%2F2016%2F05%2F18%2F%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%8801%E8%83%8C%E5%8C%85%E3%80%81%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E3%80%81%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Ⅰ. 背包问题认知 $物品：不可拆分，具有三种属性(体积w_i, 价值v_i, 个数c_i)$ $背包问题：将物品装入V大小的背包获得最优价值的问题$ $c_i=1时，称为01背包$ $c_i=\infty 时，称为完全背包$ $c_i=不定值时，称为多重背包$ Ⅱ. 状态与初始化状态 $f[i][j]:前i件物品装入容量为j的背包所获得的最大价值$ $不放第i件物品: f[i-1][j]:= 前i-1件物品装入容量为j的背包$ $放入1件第i件物品: f[i-1][j-w_i]:= 前i-1件物品装入容量为j-w_i的背包$ 初始化 $如果不要正好装满: f[0][0\sim V] = 0$ $如果需要正好装满: f[0][0] = 0，f[0][1\sim V] = -INF$ $初始化dp数组就是初始化f[0][x]:= “0件物品的合法状态”$ $对于1，此时所有容量即f[0][x]都有合法的解0，即“什么都不装”$ $对于2，此时只有f[0][0]有合法解且解为0，其他属于非法状态，应赋值为-INF$ Ⅲ. 01背包//O(NV) f[0][0 ~ V] = 0; for(int i = 1; i &lt;= n; ++i) for(int j = 0; j &lt;= V; ++j) if(j &lt; w[i]) f[i][j] = f[i - 1][j]; else f[i][j] = max(f[i - 1][j], f[i - 1][j - w[i]] + v[i]); //O(NV) 滚动数组 f[0 ~ V] = 0; for(int i = 1; i &lt;= n; ++i) for(int j = V; j &gt;= w[i]; --j) f[j] = max(f[j], f[j - w[i]] + v[i]); Ⅳ. 完全背包//O(NVK) f[0][0 ~ V] = 0; for(int i = 1; i &lt;= n; ++i) for(int j = 0; j &lt;= V; ++j) for(int k = 0; k * w[i] &lt;= j; ++k) f[i][j] = max(f[i][j], f[i - 1][j - k * w[i]] + k * v[i]); //O(NV) f[0][0 ~ V] = 0; for(int i = 1; i &lt;= n; ++i) for(int j = 0; j &lt;= V; ++j) if(j &lt; w[i]) f[i][j] = f[i - 1][j]; else f[i][j] = max(f[i - 1][j], f[i][j - w[i]] + v[i]); //O(NV) 滚动数组 f[0 ~ V] = 0; for(int i = 1; i &lt;= n; ++i) for(int j = w[i]; j &lt;= V; ++j) f[j] = max(f[j], f[j - w[i]] + v[i]); Ⅴ. 多重背包//O(NVK) f[0][0 ~ V] = 0; for(int i = 1; i &lt;= n; ++i) for(int j = 0; j &lt;= V; ++j) for(int k = 0; k &lt;= c[i] &amp;&amp; k * w[i] &lt;= j; ++k) f[i][j] = max(f[i][j], f[i - 1][j - k * w[i]] + k * v[i]); //O(NVK) f[0 ~ V] = 0; for(int i = 1; i &lt;= n; ++i) for(int j = V; j &gt;= 0; --j) for(int k = 1; k &lt;= c[i] &amp;&amp; k * w[i] &lt;= j; ++k) f[j] = max(f[j], f[j - k * w[i]] + k * v[i]); Ⅵ. 多重背包の优化二进制优化 $c_i=1+2+4+\cdots+2^k+a, 0\le a &lt; 2^{k+1}$ $1, 2, 4, \cdots, 2^k可以表示0\sim 2^{k+1}-1的整数，基于二进制表示$ $再由a即可得到0\sim c_i的所有整数了$ $这样物品个数由c_i个变为logc_i个，时间复杂度即为O(NVlogK)$ //O(NVlogK) f[0 ~ V] = 0; for(int i = 1; i &lt;= n; ++i){ int num = c[i]; for(int k = 1; num &gt; 0; k &lt;&lt;= 1){ int mul = min(k, num); for(int j = V; mul * w[i] &lt;= j; --j){ f[i] = max(f[j], f[j - mul * w[i]] + mul * v[i]) } num -= mul; } } 单调队列优化 $先看O(NVK)的转移方程：f[i][j] = max\{f[i-1][j-k\times w_i]+k\times v_i\}, k\in [0, c_i]$ $首先j\%w_i不同的状态间是独立的，即f[i][p\times w_i+r]肯定是由f[i-1][q\times w_i + r]转移过来的$ $我们来推一推，令j=p\times w_i +r$ $f[i][j] = max\{f[i-1][j-k\times w_i]+k\times v_i\}, k\in [0, c_i]$$f[i][p\times w_i +r] = max\{f[i-1][(p-k)\times w_i + r]+k\times v_i\}, k\in [0, c_i]$$令q=p-k，得:$$f[i][p\times w_i +r] = max\{f[i-1][q\times w_i + r]+(p-q)\times v_i\}, q\in [p-c_i, p]$$按照w_i分类后p是定值，得:$$f[i][p\times w_i +r] = max\{f[i-1][q\times w_i + r]-q\times v_i\}+p\times v_i, q\in [p-c_i, p]$$令f(x)=x\times w_i + r，得:$$f(p)=max\{f(q)-q\times v_i\}+p\times v_i, q\in [p-c_i, p]$ $这个就是我们熟悉的窗口大小为c_i的单调队列优化的式子辣$ $单调队列优化搞一波，时间复杂度即为O(NV)$ //O(NV) int Q[V], f[2][V]; //单调队列，滚动数组 int z = 0; memset(f[z], 0, sizeof f[z]); f[z][0] = 0; for(int i = 1; i &lt;= n; ++i) { memset(f[!z], 0, sizeof f[!z]); for(int r = 0; r &lt; w[i]; ++r) { int L = 0, R = 0; for(int p = 0; p * w[i] + r &lt;= V; ++p) { while(L &lt; R &amp;&amp; f[z][Q[R - 1] * w[i] + r] - Q[R - 1] * v[i] &lt;= f[z][p * w[i] + r] - p * v[i]) --R; Q[R++] = p; while(L &lt; R &amp;&amp; p - c[i] &gt; Q[L]) ++L; int q = Q[L]; f[!z][p * w[i] + r] = (f[z][q * w[i] + r] - q * v[i]) + p * v[i]; } } z = !z; }]]></content>
      <categories>
        <category>小结</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 351 E. Levels and Regions（斜率优化dp）]]></title>
    <url>%2F2016%2F05%2F11%2FCodeforces%20Round%20351%20E.%20Levels%20and%20Regions%EF%BC%88%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96dp%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $将N\le 2\times 10^5个关卡划分成M\le min(50, n)个组，组内关卡连续，t_i\le 10^5$$定义游戏规则，每次选择第一个未全部完成的组，假设组处于关卡区间[l, r]$$选择到组内第一个未完成的关卡的概率p_i=\frac{t_i}{\sum_{i=l}^i t_i}$$求怎样划分组使得通过所有组的期望打关卡次数最小，求这个次数，误差小于10^{-4}$ 分析： $重复选择某个东西，选到的概率是p_i，那么期望次数就是{1\over p_i}$$f[j][i]:=前i个关卡分成j组的最小期望$$f[j][i]=min\{ f[j-1][k]+cost(k+1, i) \}，然后看到就知道是斜率优化了。。$$然后如何O(1)计算cost(k+1, i)呢$$cost(k+1, i)=\sum_{i=k+1}^i {1\over p_i}=\sum_{i=k+1}^i\frac{\sum_{i=k+1}^i t_i}{t_i}$$=\sum_{i=k+1}^i\frac{\sum_{i=1}^i t_i-\sum_{i=1}^k t_i}{t_i}$$令sum_i=\sum_{i=1}^i t_i$$则上式=\sum_{i=k+1}^i\frac{sum_i-sum_k}{t_i}$$=\sum_{i=k+1}^i(\frac{sum_i}{t_i}-{1\over t_i}\cdot sum_k)$$=\sum_{i=k+1}^i\frac{sum_i}{t_i}-sum_k\cdot \sum_{i=k+1}^i {1\over t_i}$$令pre_i=\sum_{i=1}^i \frac{sum_i}{t_i}，rev_i=\sum_{i=1}^i {1\over t_i}$$则上式=pre_i-pre_k-sum_i\cdot(rev_i-rev_k)$$然后就是sb题了，随便推推套进去就ok了$$时间复杂度O(mn)$ 代码： // // Created by TaoSama on 2016-05-10 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 2e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, m, q[N]; double sum[N], rev[N], pre[N]; double f[55][N]; double up(int p, int k, int j) { return (f[p][j] - pre[j] + rev[j] * sum[j]) - (f[p][k] - pre[k] + rev[k] * sum[k]); } double dw(int k, int j) { return sum[j] - sum[k]; } bool check(int p, int k, int j, int i) { return up(p, k, j) * dw(j, i) &gt;= up(p, j, i) * dw(k, j); } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); clock_t _ = clock(); while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) == 2) { for(int i = 1; i &lt;= n; ++i) { int x; scanf(&quot;%d&quot;, &amp;x); sum[i] = sum[i - 1] + x; rev[i] = rev[i - 1] + 1. / x; pre[i] = pre[i - 1] + sum[i] / x; f[1][i] = pre[i]; } for(int j = 2; j &lt;= m; ++j) { int L = 0, R = 0; q[R++] = 0; for(int i = 1; i &lt;= n; ++i) { while(L + 1 &lt; R &amp;&amp; up(j - 1, q[L], q[L + 1]) &lt;= rev[i] * dw(q[L], q[L + 1])) ++L; int k = q[L]; f[j][i] = f[j - 1][k] + pre[i] - pre[k] - sum[k] * (rev[i] - rev[k]); while(L + 1 &lt; R &amp;&amp; check(j - 1, q[R - 2], q[R - 1], i)) --R; q[R++] = i; } } printf(&quot;%.12f\n&quot;, f[m][n]); } #ifdef LOCAL printf(&quot;\nTime cost: %.2fs\n&quot;, 1.0 * (clock() - _) / CLOCKS_PER_SEC); #endif return 0; }]]></content>
      <categories>
        <category>动态规划</category>
        <category>斜率优化</category>
      </categories>
      <tags>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 2829 Lawrence（斜率优化dp）]]></title>
    <url>%2F2016%2F05%2F11%2FHDU%202829%20Lawrence%EF%BC%88%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96dp%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N\le 1000个点，点权c_i \le 100，划分成0\le M&lt;N个连续段$$每段的权值w(x, y)=\sum_{i=x}^{y-1}\sum_{j=i+1}^y c_i\cdot c_j$$求一个划分使得段权值和最小，输出这个权值和$ 分析： $f[j][i]:=前i个点划分成j段的最小权值和$$f[j][i]=min\{ f[j-1][k]+w(k+1, i) \}，然后斜率优化你懂的$$s_i=\sum_{i=1}^n c_i，s2_i=\sum_{i=1}^n c_i^2$$w(i, j)=\left((s_j-s_{i-1})^2-(s2_j-s2_{i-1}) \right)/2$$slope(k, j)\Rightarrow $$f_j+\left((s_i-s_{j})^2-(s2_i-s2_{j}) \right)/2&lt;f_k+\left((s_i-s_{k})^2-(s2_i-s2_{k}) \right)/2$$slope(k, j)=\frac{(2f_j+s_j^2+s2_j)-(2f_k+s_k^2+s2_k)}{2(s_j-s_k)}&lt;s_i$$然后就做完了，时间复杂度O(n^2)$ 代码： // // Created by TaoSama on 2016-05-10 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e3 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; typedef long long LL; int n, m, q[N]; LL f[2][N]; // f[j][i]:= j段到i的最小值 LL s[N], s2[N]; //sum, square sum //f[j][i] = min { 2f[k] + [ (s[i] - s[k])^2 - (s2[i] - s2[k]) ] / 2 } //slope(k, j):= { (2f[j]+s[j]*s[j]+s2[j])-(2f[k]+s[k]*s[k]+s2[k]) } / // { 2(s[j] - s[k]) } &lt;= s[i] LL up(int p, int k, int j) { return (2 * f[p][j] + s[j] * s[j] + s2[j]) - (2 * f[p][k] + s[k] * s[k] + s2[k]); } LL dw(int k, int j) { return 2 * (s[j] - s[k]); } bool check(int p, int k, int j, int i) { return up(p, k, j) * dw(j, i) &gt;= up(p, j, i) * dw(k, j); } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); clock_t _ = clock(); while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) == 2 &amp;&amp; (n || m)) { for(int i = 1; i &lt;= n; ++i) { scanf(&quot;%I64d&quot;, s + i); s2[i] = s2[i - 1] + s[i] * s[i]; s[i] += s[i - 1]; // printf(&quot;s[%d] = %I64d, s2[%d] = %I64d\n&quot;, i, s[i], i, s2[i]); } int p = 0; for(int i = 0; i &lt;= n; ++i) { f[p][i] = (s[i] * s[i] - s2[i]) / 2; // printf(&quot;f[0][%d] = %I64d\n&quot;, i, f[p][i]); } for(int j = 1; j &lt;= m; ++j) { int L = 0, R = 0; q[R++] = 0; for(int i = 1; i &lt;= n; ++i) { while(L + 1 &lt; R &amp;&amp; up(p, q[L], q[L + 1]) &lt;= s[i] * dw(q[L], q[L + 1])) ++L; int k = q[L]; f[!p][i] = f[p][k] + ((s[i] - s[k]) * (s[i] - s[k]) - (s2[i] - s2[k])) / 2; while(L + 1 &lt; R &amp;&amp; check(p, q[R - 2], q[R - 1], i)) --R; q[R++] = i; } p = !p; } printf(&quot;%I64d\n&quot;, f[p][n]); } #ifdef LOCAL printf(&quot;\nTime cost: %.2fs\n&quot;, 1.0 * (clock() - _) / CLOCKS_PER_SEC); #endif return 0; }]]></content>
      <categories>
        <category>动态规划</category>
        <category>斜率优化</category>
      </categories>
      <tags>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斜率优化dp小结]]></title>
    <url>%2F2016%2F05%2F11%2F%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96dp%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Ⅰ. 斜率优化认知 这东西英文名叫$Convex Hull Trick (CHT)$ 主要优化形如$f_i = min\{ f_j + cost(j+1, i) \}的这种dp$ 由于等号右边的式子并不能$O(1)$计算，所以我们需要一些技巧来优化 Ⅱ. 斜率优化 $懒得写引子了，就直接推推推吧$ $对于当前状态i，有2个决策j和k，不妨假设k &lt; j &lt; i，如果决策j优于k，则有：$$$f_j + cost(j+1, i)&lt;f_k + cost(k+1, i)$$ $如果以上这个式子可以化简到：$$$ \frac{Y(j)-Y(k)}{X(j)-X(k)}&lt;F(i) $$ $记这个式子为slope(k, j)=\frac{Y(j)-Y(k)}{X(j)-X(k)}&lt;F(i)，即j优于k$ $便可以使用优化，这个式子很斜率，故称这个优化方法为斜率优化$ $我们发现以上并没有什么卵用，先说一个结论$ $结论：如果slope(k, j)\ge slope(j, i)，k &lt; j &lt; i，那么j决策是不优的可以删除$ $证明：$ $如果slope(j, i) &lt; F(i)，那么i优于j，j可以删除$ $如果slope(j, i)\ge F(i)，虽然j优于i，但是slope(k, j)\ge F(i)，k比j优，j还是可以删除 \blacksquare$ $然后就可以用这个结论来维护一个单调队列来搞了$ Ⅲ. 题目讲解HDU 3507 Print Article分析:$f_i:=打印前i个字符的最小代价$$f_i = min\{ f_j + (sum_i - sum_{j})^2 + M \}，sum_i=\sum_{i=1}^n c_i$$假设k&lt;j&lt;i，假设j优于k，可得：$$$ f_j + (sum_i - sum_{j})^2 + M &lt; f_k + (sum_i - sum_{k})^2 + M $$$$ f_j +sum_i^2-2\cdot sum_i \cdot sum_j + sum_j^2 &lt; f_k +sum_i^2-2\cdot sum_i \cdot sum_k + sum_k^2 $$$$ (f_j + sum_j^2)-(f_k+sum_k^2) &lt; 2\cdot sum_i\cdot (sum_j-sum_k) $$$$ \frac{(f_j + sum_j^2)-(f_k+sum_k^2)}{sum_j-sum_k} &lt; sum_i $$$即j优于k的条件是：slope(k, j)=\frac{(f_j + sum_j^2)-(f_k+sum_k^2)}{sum_j-sum_k} &lt; sum_i $ $维护单调队列，开区间[L, R)：$ $先删除队头不优的元素，即slope(q[L], q[L+1])\le sum_i$ $此时q[L+1]不差于q[L]，所以q[L]可以删除$ $用最优的j=q[L]更新f_i$ $再用f_i去删除队尾的不优元素，即slope(q[R-2], q[R-1])\ge slope(q[R-1], i)$ $时间复杂度O(n)$ 参考代码： // // Created by TaoSama on 2016-05-10 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 5e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, m; int s[N], q[N]; int f[N]; int up(int k, int j) { return (f[j] + s[j] * s[j]) - (f[k] + s[k] * s[k]); } int dw(int k, int j) { return 2 * (s[j] - s[k]); } bool check(int k, int j, int i) { return up(k, j) * dw(j, i) &gt;= up(j, i) * dw(k, j); } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); clock_t _ = clock(); while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) == 2) { for(int i = 1; i &lt;= n; ++i) { scanf(&quot;%d&quot;, s + i); s[i] += s[i - 1]; } int L = 0, R = 0; q[R++] = f[0] = 0; for(int i = 1; i &lt;= n; ++i) { while(L + 1 &lt; R &amp;&amp; up(q[L], q[L + 1]) &lt;= s[i] * dw(q[L], q[L + 1])) ++L; int j = q[L]; f[i] = f[j] + m + (s[i] - s[j]) * (s[i] - s[j]); while(L + 1 &lt; R &amp;&amp; check(q[R - 2], q[R - 1], i)) --R; q[R++] = i; } printf(&quot;%d\n&quot;, f[n]); } #ifdef LOCAL printf(&quot;\nTime cost: %.2fs\n&quot;, 1.0 * (clock() - _) / CLOCKS_PER_SEC); #endif return 0; }]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5375 Gray code（线性dp）]]></title>
    <url>%2F2016%2F05%2F09%2FHDU%205375%20Gray%20code%EF%BC%88%E7%BA%BF%E6%80%A7dp%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N\le 2\times 10^5长度的二进制数，由0、1、?组成，?代表01都可$$每位有个权值，w_i\le 1000$$如果将这个二进制数转化成格雷码，1获得这个权值，0不获得$$求怎样确定这个二进制数才能获得最大权值，输出这个权值$ 分析： $百度得到公式：G_i=B_i\oplus B_{i+1}，i\in [0, n-1]，B_n=0，这个是从低位到高位的$$有了这个公式直接dp就可以了$$f[i][2]:=从高位到低位，前i位二进制位，且第i位为0/1的最大权值$$转移显然就f[i][b]=max(f[i-1][b], f[i-1][b\oplus 1]+w[i])$$ans=max(f[n][0], f[n][1])$$时间复杂度O(n)$ 代码： // // Created by TaoSama on 2016-05-09 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 2e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n; char s[N]; int f[N][2]; //binary from high bit to low bit int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); clock_t _ = clock(); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%s&quot;, s + 1); n = strlen(s + 1); memset(f, 0xc0, sizeof f); f[0][0] = 0; for(int i = 1; i &lt;= n; ++i) { int w; scanf(&quot;%d&quot;, &amp;w); if(s[i] == &#39;0&#39;) f[i][0] = max(f[i - 1][0], f[i - 1][1] + w); else if(s[i] == &#39;1&#39;) f[i][1] = max(f[i - 1][1], f[i - 1][0] + w); else { f[i][0] = max(f[i - 1][0], f[i - 1][1] + w); f[i][1] = max(f[i - 1][1], f[i - 1][0] + w); } } int ans = max(f[n][0], f[n][1]); static int kase = 0; printf(&quot;Case #%d: %d\n&quot;, ++kase, ans); } #ifdef LOCAL printf(&quot;\nTime cost: %.2fs\n&quot;, 1.0 * (clock() - _) / CLOCKS_PER_SEC); #endif return 0; }]]></content>
      <categories>
        <category>动态规划</category>
        <category>线性dp</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5372 Segment Game（BIT）]]></title>
    <url>%2F2016%2F05%2F09%2FHDU%205372%20Segment%20Game%EF%BC%88BIT%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N\le 2\times 10^5次操作$$0 l:如果是第i次添加操作，那么加入一条长度为i的线段，即[l, l+i]$$1 i:删除第i次添加操作添加的线段$$输出每个添加操作的线段所完全包含的线段个数$ 分析： $破题卡nlog^2n的cdq分治做法。。$$然后赛上就卡死了，事实上每次添加的线段长度都更长这个条件很苛刻的$$画个图发现就五种情况，那么答案就显然易见了$$并且发现①②可以合并成左端点在A外的情况$$③④可以合并成右端点在B外的情况$$ans(⑤) = 总线段数-这两种情况的和$$2个BIT分别维护下左右端点的数量即可$$我自己脑补了题意。。特么的题意是删除第i次添加操作的，，这个添加二字$$好吧，时间复杂度O(nlogn)$ 代码： // // Created by TaoSama on 2016-05-09 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 2e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; struct BIT { int n, b[N]; void init(int _n) { n = _n; memset(b, 0, sizeof b); } void add(int i, int v) { for(; i &lt;= n; i += i &amp; -i) b[i] += v; } int sum(int i) { int ret = 0; for(; i; i -= i &amp; -i) ret += b[i]; return ret; } } bit[2]; int n, op[N], x[N], y[N]; int wh[N]; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); clock_t _ = clock(); while(scanf(&quot;%d&quot;, &amp;n) == 1) { vector&lt;int&gt; xs[2]; int addStp = 0; for(int i = 1; i &lt;= n; ++i) { scanf(&quot;%d%d&quot;, op + i, x + i); if(op[i] == 1) continue; wh[++addStp] = i; y[i] = x[i] + addStp; xs[0].push_back(x[i]); xs[1].push_back(y[i]); } for(int i = 0; i &lt; 2; ++i) { sort(xs[i].begin(), xs[i].end()); xs[i].resize(unique(xs[i].begin(), xs[i].end()) - xs[i].begin()); bit[i].init(xs[i].size()); } static int kase = 0; printf(&quot;Case #%d:\n&quot;, ++kase); for(int i = 1; i &lt;= n; ++i) { if(op[i] == 1) { //delete int t = wh[x[i]]; int l = lower_bound(xs[0].begin(), xs[0].end(), x[t]) - xs[0].begin() + 1; int r = lower_bound(xs[1].begin(), xs[1].end(), y[t]) - xs[1].begin() + 1; bit[0].add(l, -1); bit[1].add(r, -1); } else { int l = lower_bound(xs[0].begin(), xs[0].end(), x[i]) - xs[0].begin() + 1; int r = lower_bound(xs[1].begin(), xs[1].end(), y[i]) - xs[1].begin() + 1; int all = i - 1; int out = bit[0].sum(l - 1) + all - bit[1].sum(r); printf(&quot;%d\n&quot;, all - out); bit[0].add(l, 1); bit[1].add(r, 1); } } } #ifdef LOCAL printf(&quot;\nTime cost: %.2fs\n&quot;, 1.0 * (clock() - _) / CLOCKS_PER_SEC); #endif return 0; } $当然这题如果没有这个严格的条件限制，cdq分治就可以做更一般的情况了$$就转化成了右端点排序的离线sb题了$$时间复杂度是O(nlog^2n)$ $代码由于和之前那样没注意到那个题意的毒，就不贴了$]]></content>
      <categories>
        <category>数据结构</category>
        <category>树状数组</category>
      </categories>
      <tags>
        <tag>BIT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CQUOJ 21465 部落Mod（并查集、删点 | 启发式合并）]]></title>
    <url>%2F2016%2F05%2F09%2FCQUOJ%2021465%20%E9%83%A8%E8%90%BDMod%EF%BC%88%E5%B9%B6%E6%9F%A5%E9%9B%86%E3%80%81%E5%88%A0%E7%82%B9%20%20%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N\le 10^5个点，M\le 10^6个操作$$U a b:合并a，b$$D a:移除a所在的集合关系$$S a:询问a所在的集合大小$$F a b:询问a和b是否在同一集合$ 分析： $暴力的做法就直接不路径压缩，只按秩合并保证树高，同时用set维护每棵子树的元素$$对于D操作，直接暴力遍历根节点的set重建，看起来复杂度很高$$实际均摊分析一下，暴力重建操作与树大小有关，树的大小与操作次数有关$$相当于把重建操作均摊到每一次建立操作上了$$按秩启发式合并加上set的复杂度，使得每次复杂度是log^2 n的$$总时间复杂度为O(mlog^2n)$ 代码： // // Created by TaoSama on 2016-05-07 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, m; struct DSU { int n, p[N]; set&lt;int&gt; s[N]; void init(int _n) { n = _n; for(int i = 1; i &lt;= n; ++i) resume(i); } void resume(int i) { p[i] = i; s[i].clear(); s[i].insert(i); } int find(int x) { return p[x] == x ? x : find(p[x]); } void del(int x) { x = find(x); for(auto u : s[x]) { if(u == x) continue; resume(u); } resume(x); } void unite(int x, int y) { x = find(x), y = find(y); if(x == y) return; if(s[x].size() &gt; s[y].size()) swap(x, y); p[x] = y; for(auto u : s[x]) s[y].insert(u); } int size(int x) { x = find(x); return s[x].size(); } bool same(int x, int y) { x = find(x), y = find(y); return x == y; } } dsu; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); clock_t _ = clock(); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); dsu.init(n); while(m--) { char op[2]; int x, y; scanf(&quot;%s%d&quot;, op, &amp;x); if(*op == &#39;U&#39;) { scanf(&quot;%d&quot;, &amp;y); dsu.unite(x, y); } else if(*op == &#39;D&#39;) dsu.del(x); else if(*op == &#39;S&#39;) printf(&quot;%d\n&quot;, dsu.size(x)); else { scanf(&quot;%d&quot;, &amp;y); puts(dsu.same(x, y) ? &quot;Yes&quot; : &quot;No&quot;); } } } #ifdef LOCAL printf(&quot;\nTime cost: %.2fs\n&quot;, 1.0 * (clock() - _) / CLOCKS_PER_SEC); #endif return 0; } $事实上有更加优美的做法，$并查集删点$事实对于D操作，可以直接把这棵子树连到其它地方去，比如用0当作废弃点$$对于重新合并的时候，直接rehash这个节点的id，这样之前的“废弃树”结构没变，这个点也新建了$$非常完美的姿势做法，就是空间复杂度等于操作复杂度了，由于rehash这个原因$$时间复杂度O(m\alpha(n))，空间复杂度O(m)$ 代码： // // Created by TaoSama on 2016-05-07 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 2e6 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, m; struct DSU { int n, tim, id[N], p[N], sz[N]; void init(int _n) { n = _n; tim = 0; for(int i = 0; i &lt;= n; ++i) resume(i); } int resume(int i) { id[i] = tim; p[tim] = tim; sz[tim] = 1; return tim++; } int find(int x) { return p[x] = p[x] == x ? x : find(p[x]); } int findResume(int x) { int y = id[x]; int fa = find(y); if(fa == 0) return resume(x); return fa; } void unite(int x, int y) { x = findResume(x), y = findResume(y); if(x == y) return; p[x] = y; sz[y] += sz[x]; } void del(int x) { x = findResume(x); p[x] = 0; } int size(int x) { return sz[findResume(x)]; } bool same(int x, int y) { return findResume(x) == findResume(y); } } dsu; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); clock_t _ = clock(); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); dsu.init(n); while(m--) { char op[2]; int x, y; scanf(&quot;%s%d&quot;, op, &amp;x); if(*op == &#39;U&#39;) { scanf(&quot;%d&quot;, &amp;y); dsu.unite(x, y); } else if(*op == &#39;D&#39;) dsu.del(x); else if(*op == &#39;S&#39;) printf(&quot;%d\n&quot;, dsu.size(x)); else { scanf(&quot;%d&quot;, &amp;y); puts(dsu.same(x, y) ? &quot;Yes&quot; : &quot;No&quot;); } } } #ifdef LOCAL printf(&quot;\nTime cost: %.2fs\n&quot;, 1.0 * (clock() - _) / CLOCKS_PER_SEC); #endif return 0; }]]></content>
      <categories>
        <category>数据结构</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CQUOJ 21463 Angela Sequence（dp）]]></title>
    <url>%2F2016%2F05%2F09%2FCQUOJ%2021463%20Angela%20Sequence%EF%BC%88dp%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N\le 10^5个序列，A_i\le 10^5，定义任意2个相邻数都不互质的序列为Angela序列$$求最长Angela子序列的长度$ 分析： $10^5就存素因子辣，素因子不会太多，2\times 3\times 5\times 7\times 11\times 13\times 15&gt;10^5，所以也就6个$$状态就f[i][prime]，前i个数，选取第i个数以prime素因子结尾的最大长度$$然后转移就分解这个数，然后f[i][prime]= max\{f[i-1][prime]+1\}$$再把自己max一下，f[i][prime] = max\{f[i][prime]\}$$ans = max\{f[i][prime]\}$$由于转移之和之前的有关系，所以就滚动数组优化下空间$$复杂度就O(n\times 分解复杂度)$$我也搞不清用素数试除的分解复杂度是多少，应该比O(\sqrt{n})好吧$ 代码： // // Created by TaoSama on 2016-05-08 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n; vector&lt;int&gt; prime; int f[N]; void gao() { bool vis[N] = {}; for(int i = 2; i &lt; N; ++i) { if(vis[i]) continue; prime.push_back(i); for(int j = i + i; j &lt; N; j += i) vis[j] = true; } } //2*3*5*7*11*13 6 primes vector&lt;int&gt; factorize(int x) { vector&lt;int&gt; factor; for(int p : prime) { if(x % p == 0) { factor.push_back(p); while(x % p == 0) x /= p; } if(x == 1) break; } return factor; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); clock_t _ = clock(); gao(); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%d&quot;, &amp;n); int ans = 0; memset(f, 0, sizeof f); for(int i = 1; i &lt;= n; ++i) { int x; scanf(&quot;%d&quot;, &amp;x); vector&lt;int&gt; factor = factorize(x); int cur = 0; for(int fac : factor) { f[fac] = max(f[fac], f[fac] + 1); cur = max(cur, f[fac]); } for(int fac : factor) f[fac] = max(f[fac], cur); ans = max(ans, cur); } printf(&quot;%d\n&quot;, ans); } #ifdef LOCAL printf(&quot;\nTime cost: %.2fs\n&quot;, 1.0 * (clock() - _) / CLOCKS_PER_SEC); #endif return 0; }]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BNUOJ 51639 Simple Database（大模拟）]]></title>
    <url>%2F2016%2F05%2F09%2FBNUOJ%2051639%20Simple%20Database%EF%BC%88%E5%A4%A7%E6%A8%A1%E6%8B%9F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $模拟sql语句的执行过程，具体见题面$，点击 分析： $创建表，删除表，插入表都没啥说的$$就是删除的条件可以省略，以及SET WHERE后面是有多个条件的$$然后没啥照着模拟就好了，咋样好写咋来$$弱智的我表示加上调试语句写了9.4k$$时间复杂度自己估算能跑得过就好了，反正vector我当时算了是没问题的$ 代码： // // Created by TaoSama on 2016-04-23 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; #include &lt;sstream&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; void RE() { printf(&quot;%d\n&quot;, *((int*)0)); } struct Table { string name; vector&lt;string&gt; key; vector&lt;vector&lt;string&gt; &gt; content; Table() {} Table(string name, vector&lt;string&gt; key): name(name), key(key) {} void add(vector&lt;string&gt; row) { if(key.size() != row.size()) { cout &lt;&lt; &quot;add illegal row\n&quot;; RE(); } content.push_back(row); } void del(vector&lt;pair&lt;string, string&gt; &gt;&amp; conditions) { vector&lt;vector&lt;string&gt; &gt;::iterator iter = content.begin(); for(; iter != content.end();) { //row bool ok = true; for(int j = 0; j &lt; iter-&gt;size(); ++j) { //col for(int k = 0; k &lt; conditions.size(); ++k) { //conditions if(key[j] == conditions[k].first) { if((*iter)[j] != conditions[k].second) { ok = false; break; } } } if(!ok) break; } if(ok) iter = content.erase(iter); else ++iter; } } void update(vector&lt;pair&lt;string, string&gt; &gt;&amp; sets, vector&lt;pair&lt;string, string&gt; &gt;&amp; conditions) { for(int i = 0; i &lt; content.size(); ++i) { //row bool ok = true; for(int j = 0; j &lt; content[i].size(); ++j) { //col for(int k = 0; k &lt; conditions.size(); ++k) { if(key[j] == conditions[k].first) { if(content[i][j] != conditions[k].second) { ok = false; break; } } } if(!ok) break; } if(!ok) continue; //update for(int j = 0; j &lt; content[i].size(); ++j) { for(int k = 0; k &lt; sets.size(); ++k) { if(key[j] == sets[k].first) content[i][j] = sets[k].second; } } } } vector&lt;int&gt; select(vector&lt;pair&lt;string, string&gt; &gt;&amp; conditions) { vector&lt;int&gt; choose; for(int i = 0; i &lt; content.size(); ++i) { //row bool ok = true; for(int j = 0; j &lt; content[i].size(); ++j) { //col for(int k = 0; k &lt; conditions.size(); ++k) { if(key[j] == conditions[k].first) { if(content[i][j] != conditions[k].second) { ok = false; break; } } } if(!ok) break; } if(ok) choose.push_back(i); } return choose; } }; vector&lt;Table&gt; db; #ifdef LOCAL void see1(vector&lt;string&gt;&amp; v) { for(auto s : v) cout &lt;&lt; s &lt;&lt; &#39; &#39;; cout &lt;&lt; endl; } void seedb() { cout &lt;&lt; endl &lt;&lt; string(20, &#39;*&#39;) &lt;&lt; endl; for(auto table : db) { cout &lt;&lt; &quot;name: &quot; &lt;&lt; table.name &lt;&lt; endl; for(auto key : table.key) cout &lt;&lt; key &lt;&lt; &#39; &#39;; cout &lt;&lt; endl; for(auto vs : table.content) { for(auto s : vs) { cout &lt;&lt; s &lt;&lt; &#39; &#39;; } cout &lt;&lt; endl; } } cout &lt;&lt; string(20, &#39;*&#39;) &lt;&lt; endl &lt;&lt; endl; } void seeCondition(vector&lt;pair&lt;string, string&gt; &gt;&amp; conditions) { for(auto p : conditions) cout &lt;&lt; p.first &lt;&lt; &quot;=&quot; &lt;&lt; p.second &lt;&lt; endl; cout &lt;&lt; endl; } #endif // LOCAL int findTable(string&amp; name) { for(int i = 0; i &lt; db.size(); ++i) { Table&amp; table = db[i]; if(name == table.name) return i; } return -1; } bool isSymbol(char c) { if(isalnum(c) || c == &#39;_&#39;) return false; return true; } bool strip(string&amp; s) { while(s.size() &amp;&amp; isSymbol(s[0])) s.erase(0, 1); while(s.size() &amp;&amp; isSymbol(s[s.size() - 1])) s.erase(s.size() - 1, 1); } void split(string&amp; s, vector&lt;string&gt;&amp; vs) { stringstream ss(s); string col; while(ss &gt;&gt; col) { strip(col); vs.push_back(col); } } void create(string&amp; s) { vector&lt;string&gt; vs; split(s, vs); // see1(vs); if(~findTable(vs[0])) {cout &lt;&lt; &quot;error\n&quot;; return;} db.push_back(Table(vs[0], vector&lt;string&gt;(vs.begin() + 1, vs.end()))); } void drop(string&amp; s) { int wh = findTable(s); if(wh == -1) {cout &lt;&lt; &quot;error\n&quot;; return;} db.erase(db.begin() + wh); } void insert(string&amp; s) { vector&lt;string&gt; vs; split(s, vs); // see1(vs); int wh = findTable(vs[0]); if(wh == -1) {cout &lt;&lt; &quot;error\n&quot;; return;} db[wh].add(vector&lt;string&gt;(vs.begin() + 1, vs.end())); } void split(string&amp; s, string&amp; name, vector&lt;pair&lt;string, string&gt; &gt;&amp; sets, vector&lt;pair&lt;string, string&gt; &gt;&amp; conditions) { int white = s.find(&#39; &#39;); name = s.substr(0, white); s = s.substr(white + 1); size_t SET = s.find(&quot;SET&quot;); size_t WHERE = s.find(&quot;WHERE&quot;); if(SET != string::npos) { SET += 3; string setString = s.substr(SET, WHERE - SET); stringstream ss(setString); string key, value; while(ss &gt;&gt; key &gt;&gt; value &gt;&gt; value) { strip(key); strip(value); sets.push_back(make_pair(key, value)); } } if(WHERE != string::npos) { WHERE += 5; string conditionString = s.substr(WHERE); stringstream ss(conditionString); string key, value; while(ss &gt;&gt; key &gt;&gt; value &gt;&gt; value) { strip(key); strip(value); conditions.push_back(make_pair(key, value)); } } } bool checkKey(int wh, vector&lt;pair&lt;string, string&gt; &gt;&amp; sets, vector&lt;pair&lt;string, string&gt; &gt;&amp; conditions) { Table&amp; table = db[wh]; for(int i = 0; i &lt; sets.size(); ++i) { bool have = false; for(int j = 0; j &lt; table.key.size(); ++j) { if(sets[i].first == table.key[j]) { have = true; break; } } if(!have) return false; } for(int i = 0; i &lt; conditions.size(); ++i) { bool have = false; for(int j = 0; j &lt; table.key.size(); ++j) { if(conditions[i].first == table.key[j]) { have = true; break; } } if(!have) return false; } return true; } void del(string&amp; s) { string name; vector&lt;pair&lt;string, string&gt; &gt; sets, conditions; split(s, name, sets, conditions); int wh = findTable(name); if(wh == -1) {cout &lt;&lt; &quot;error\n&quot;; return;} // seeCondition(sets); seeCondition(conditions); if(!conditions.size()) db[wh].content.clear(); else { if(!checkKey(wh, sets, conditions)) {cout &lt;&lt; &quot;error\n&quot;; return;} db[wh].del(conditions); } } void update(string&amp; s) { string name; vector&lt;pair&lt;string, string&gt; &gt; sets, conditions; split(s, name, sets, conditions); int wh = findTable(name); if(wh == -1) {cout &lt;&lt; &quot;error\n&quot;; return;} if(!checkKey(wh, sets, conditions)) {cout &lt;&lt; &quot;error\n&quot;; return;} // seeCondition(sets); seeCondition(conditions); db[wh].update(sets, conditions); } void select(string&amp; s) { string name; vector&lt;pair&lt;string, string&gt; &gt; sets, conditions; split(s, name, sets, conditions); int wh = findTable(name); if(wh == -1) {cout &lt;&lt; &quot;error\n&quot;; return;} if(!checkKey(wh, sets, conditions)) {cout &lt;&lt; &quot;error\n&quot;; return;} // puts(&quot;select&quot;); // seeCondition(conditions); Table&amp; table = db[wh]; vector&lt;int&gt; choose = table.select(conditions); for(int i = 0; i &lt; table.key.size(); ++i) { if(i) cout &lt;&lt; &#39; &#39;; cout &lt;&lt; table.key[i]; } cout &lt;&lt; &#39;\n&#39;; for(int i = 0; i &lt; choose.size(); ++i) { vector&lt;string&gt;&amp; v = table.content[choose[i]]; for(int j = 0; j &lt; v.size(); ++j) { if(j) cout &lt;&lt; &#39; &#39;; cout &lt;&lt; v[j]; } cout &lt;&lt; &#39;\n&#39;; } } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif int t; cin &gt;&gt; t; while(t--) { int q; cin &gt;&gt; q; cin.get(); static int kase = 0; cout &lt;&lt; &quot;Case #&quot; &lt;&lt; ++kase &lt;&lt; &quot;:\n&quot;; db.clear(); while(q--) { string s; getline(cin, s); int white = s.find(&#39; &#39;); string cmd = s.substr(0, white); string lft = s.substr(white + 1); if(cmd == &quot;CREATE&quot;) create(lft); else if(cmd == &quot;DROP&quot;) drop(lft); else if(cmd == &quot;INSERT&quot;) insert(lft); else if(cmd == &quot;DELETE&quot;) del(lft); else if(cmd == &quot;UPDATE&quot;) update(lft); else select(lft); // cout &lt;&lt; q &lt;&lt; endl; seedb(); } } return 0; }]]></content>
      <categories>
        <category>暴力</category>
        <category>大模拟</category>
      </categories>
      <tags>
        <tag>大模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BNUOJ 51638 Air Hockey（三分搜索、二分搜索）]]></title>
    <url>%2F2016%2F05%2F09%2FBNUOJ%2051638%20Air%20Hockey%EF%BC%88%E4%B8%89%E5%88%86%E6%90%9C%E7%B4%A2%E3%80%81%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $平面上给定2个球的初始位置，运动向量，以及半径$$求2个球是否相撞，若撞，输出碰撞的时间，否则输出最近距离$ 分析： $先三分求两圆圆心的最近距离，如果两圆圆心最近距离不大于两圆半径之和，则可以碰撞$$再二分求出碰撞时间即可，否则直接输出两圆圆心最近距离减去两圆半径之和$ 代码： // // Created by TaoSama on 2016-04-23 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; const double EPS = 1e-8; int sgn(double x) { return x &lt; -EPS ? -1 : x &gt; EPS; } struct Point { double x, y; void read() { scanf(&quot;%lf%lf&quot;, &amp;x, &amp;y); } Point operator+(const Point&amp; p) { return {x + p.x, y + p.y}; } Point operator-(const Point&amp; p) { return {x - p.x, y - p.y}; } Point operator*(const double k) { return {k * x, k * y}; } double length() { return hypot(x, y); } } x, vx, y, vy; int rx, ry; double get(double m) { Point p = x + vx * m, q = y + vy * m; return (p - q).length(); } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { x.read(); scanf(&quot;%d&quot;, &amp;rx); vx.read(); y.read(); scanf(&quot;%d&quot;, &amp;ry); vy.read(); double l = 0, r = 1e9; for(int i = 1; i &lt;= 100; ++i) { double ll = (2 * l + r) / 3; double rr = (l + 2 * r) / 3; if(get(ll) &lt; get(rr)) r = rr; else l = ll; } double dis = get(l) - rx - ry, t = l; if(sgn(dis) &lt;= 0) { //hit double l = 0, r = t; for(int i = 1; i &lt;= 100; ++i) { double m = (l + r) / 2; if(get(m) &lt; rx + ry) r = m; else l = m; } printf(&quot;%.12f\n&quot;, l); } else printf(&quot;%.12f\n&quot;, dis); } return 0; }]]></content>
      <categories>
        <category>暴力</category>
        <category>搜索</category>
        <category>二/三分搜索</category>
      </categories>
      <tags>
        <tag>三分搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BNUOJ 51645 ACM Battle（搜索、最小点覆盖）]]></title>
    <url>%2F2016%2F05%2F09%2FBNUOJ%2051645%20ACM%20Battle%EF%BC%88%E6%90%9C%E7%B4%A2%E3%80%81%E6%9C%80%E5%B0%8F%E7%82%B9%E8%A6%86%E7%9B%96%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $1 \leq N \leq 1000, 1 \leq M \leq 2000，N个点M条边的无向图$$求这个图的最小点覆盖集的大小，如果大于10输出GG$ 分析： $由于最小点覆盖集的大小不超过10，所以可以直接裸搜10层$$裸搜的话，每条边分别尝试它的2个端点，维护一下覆盖的边的状态就好了$$当然暴力选边以及更新覆盖边的状态是不兹磁的$$我们可以维护一下，每个点盖了哪些边，这个用bitset来O(nm)预处理就好了$$然后就可以搜辣，不能每次遍历所有的边，这样复杂度带上bitest就O(2^{10}\times \frac{m^2}{64})了$$实际上由于选择都是一样的，我们可以用cur优化，每次选择第一个未被盖的边就可以$$然后加上最优性剪枝，就跑得飞快辣$$时间复杂度是O(nm+2^{10}\times \frac{m}{64})$ 代码： // // Created by TaoSama on 2016-05-08 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; #include &lt;bitset&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 2e3 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, m; struct Edge { int u, v; } edge[N]; bitset&lt;2000&gt; sta[1000]; void dfs(int dep, int&amp; ans, bitset&lt;2000&gt; b) { if(dep &gt;= ans || dep &gt; 10) return; if(b.count() == m) {ans = dep; return;} for(int i = 0; i &lt; m; ++i) { if(b[i] == 1) continue; int u = edge[i].u, v = edge[i].v; dfs(dep + 1, ans, b | sta[u]); dfs(dep + 1, ans, b | sta[v]); break; } } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); clock_t _ = clock(); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 0; i &lt; m; ++i) { int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); edge[i] = (Edge) {u, v}; } for(int i = 0; i &lt; n; ++i) { sta[i].reset(); for(int j = 0; j &lt; m; ++j) if(edge[j].u == i || edge[j].v == i) sta[i][j] = 1; } int ans = INF; dfs(0, ans, 0); if(ans == INF) puts(&quot;GG&quot;); else printf(&quot;%d\n&quot;, ans); } #ifdef LOCAL printf(&quot;\nTime cost: %.2fs\n&quot;, 1.0 * (clock() - _) / CLOCKS_PER_SEC); #endif return 0; }]]></content>
      <categories>
        <category>暴力</category>
        <category>搜索</category>
        <category>dfs/bfs</category>
      </categories>
      <tags>
        <tag>最小点覆盖</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BNUOJ 50395 Vertex Cover（搜索、最小点覆盖）]]></title>
    <url>%2F2016%2F05%2F09%2FBNUOJ%2050395%20Vertex%20Cover%EF%BC%88%E6%90%9C%E7%B4%A2%E3%80%81%E6%9C%80%E5%B0%8F%E7%82%B9%E8%A6%86%E7%9B%96%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $2 \leq N \leq 500, 1 \leq M \leq \frac{n(n - 1)}{2}，N个点M条边的无向图$$对于每条边(u, v)总有min(u, v)\le30，求这个图的最小点覆盖集的大小$ 分析： $裸搜的话，每条边分别尝试它的2个端点，具体搜到多少完全不知道，复杂度是爆炸的$$但是这个题有一个很好的性质，min(u, v)\le30，这样最小点覆盖集不会超过30$$所以直接尝试去搜这30个点，尝试选或者不选（不选的话那么它连的所有点就都要选了）$$不然这条边就没有点来覆盖了，这里要预处理一下这30个点所连的边$$用bitset来预处理就好了，其实就是类似邻接表存一下图$$搜的过程用bitset来保存选取的点覆盖集当作状态$$看起来复杂度是2^{30}，加上最优性剪枝，以及bitset优化，实际上跑得飞快$$时间复杂度O(跑得过)$ 代码： // // Created by TaoSama on 2016-05-09 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; #include &lt;bitset&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, m; bitset&lt;500&gt; g[30]; void dfs(int u, int&amp; ans, bitset&lt;500&gt; vs) { int cnt = vs.count(); if(cnt &gt;= ans) return; if(u == min(n, 30)) {ans = cnt; return;} if(vs[u]) dfs(u + 1, ans, vs); else { vs[u] = 1; dfs(u + 1, ans, vs); //涂 vs[u] = 0; dfs(u + 1, ans, vs | g[u]); //不涂它，连的点就得涂 } } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); clock_t _ = clock(); while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) == 2) { for(int i = 0; i &lt; 30; ++i) g[i].reset(); for(int i = 1; i &lt;= m; ++i) { int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); --u; --v; if(u &gt; v) swap(u, v); g[u][v] = 1; if(v &lt; u) g[v][u] = 1; } int ans = INF; dfs(0, ans, 0); printf(&quot;%d\n&quot;, ans); } #ifdef LOCAL printf(&quot;\nTime cost: %.2fs\n&quot;, 1.0 * (clock() - _) / CLOCKS_PER_SEC); #endif return 0; }]]></content>
      <categories>
        <category>暴力</category>
        <category>搜索</category>
        <category>dfs/bfs</category>
      </categories>
      <tags>
        <tag>最小点覆盖</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4122 Alice's mooncake shop（贪心、RMQ）]]></title>
    <url>%2F2016%2F05%2F02%2FHDU%204122%20Alice's%20mooncake%20shop%EF%BC%88%E8%B4%AA%E5%BF%83%E3%80%81RMQ%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $给定N\le 2500个订单，升序排列，保证合法$$现在有个店开M\le 10^5小时，每小时做月饼的价格都不一样，不考虑做月饼的时间$$每个月饼的保质期是t\le 10^5小时，每小时的花费为s\le 200$$订单可以现做现卖，问如何制作才能满足所有订单，并使得总花费最小$$求这个花费$ 分析： $首先先解析日期都成小时$$对于i小时的订单，显然应该取[i-t+1, i]的最小的那个花费$$为了方便处理，假设都在最后一天买，显然某一天的花费应该a_i+(m-i)\times s$$之后取min\{cost[i-t+1, i]\}，再减去多算的(m-i)\times s$$然后就做完了$$时间复杂度O(nlogm+m)$$妈蛋，我样处理日期要考虑重复的情况，赛上T到死了。。。while与if的一字之差$ 代码： // // Created by TaoSama on 2016-05-02 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; #include &lt;tuple&gt; #include &lt;cassert&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 2e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, m; int t, s; struct Order { int y, m, d, h; int id; void read() { scanf(&quot;%d%d%d%d&quot;, &amp;d, &amp;y, &amp;h, &amp;r); } void see() { printf(&quot;(%d, %d, %d, %d)\n&quot;, y, m, d, h); } int r; } o[2505]; void RE() { printf(&quot;%d\n&quot;, *((int*)0)); } typedef long long LL; LL a[N]; struct SparseTable { int n; LL dp[20][N]; void init(int _n, LL* a) { n = _n; for(int i = 1; i &lt;= n; ++i) dp[0][i] = a[i]; for(int i = 1; (1 &lt;&lt; i) &lt;= n; ++i) for(int j = 1; j + (1 &lt;&lt; i) - 1 &lt;= n; ++j) dp[i][j] = min(dp[i - 1][j], dp[i - 1][j + (1 &lt;&lt; i - 1)]); } LL RMQ(int l, int r) { int k = 31 - __builtin_clz(r - l + 1); return min(dp[k][l], dp[k][r - (1 &lt;&lt; k) + 1]); } } st; char mm[][10] = {&quot;&quot;, &quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;}; int mdays[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; bool isLeap(int y) { return y % 4 == 0 &amp;&amp; y % 100 || y % 400 == 0; } void go(int&amp; y, int&amp; m, int&amp; d, int&amp; h) { ++h; if(h &gt;= 24) h = 0, ++d; int cur = mdays[m]; if(m == 2 &amp;&amp; isLeap(y)) ++cur; if(d &gt; cur) d -= cur, ++m; if(m &gt; 12) m -= 12, ++y; } int getTime(int m, int day, int year, int h) { int res = 0; for(int i = 2000; i &lt; year; i++) { if(isLeap(i))res += 366 * 24; else res += 365 * 24; } for(int i = 1; i &lt; m; i++) { res += mdays[i] * 24; if(isLeap(year) &amp;&amp; i == 2)res += 24; } for(int i = 1; i &lt; day; i++)res += 24; res += h + 1; return res; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) == 2 &amp;&amp; (n || m)) { for(int i = 1; i &lt;= n; ++i) { char mon[10]; scanf(&quot;%s&quot;, mon); o[i].read(); for(int j = 1; j &lt;= 12; ++j) { if(!strcmp(mm[j], mon)) { o[i].m = j; break; } } } scanf(&quot;%d%d&quot;, &amp;t, &amp;s); int Y = 2000, M = 1, D = 1, H = 0; for(int j = 1, i = 1; ; ++j) { // o[i].see(); while(make_tuple(Y, M, D, H) == make_tuple(o[i].y, o[i].m, o[i].d, o[i].h)) { o[i].id = j; // printf(&quot;%d = %d\n&quot;, i, j); ++i; } if(i == n + 1) break; go(Y, M, D, H); } for(int i = 1; i &lt;= m; ++i) { scanf(&quot;%I64d&quot;, a + i); a[i] += 1LL * (m - i) * s; } st.init(m, a); LL ans = 0; for(int i = 1; i &lt;= n; ++i) { int d = o[i].id; LL cur = st.RMQ(max(1, d - t + 1), d); cur -= 1LL * (m - d) * s; ans += cur * o[i].r; } printf(&quot;%I64d\n&quot;, ans); } return 0; }]]></content>
      <categories>
        <category>思维</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>RMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见错误小结]]></title>
    <url>%2F2016%2F05%2F02%2F%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[$1. 递归时隐藏的修改了全局变量例如点分治重心$ $\to 每次复制一遍$$2. 测试数据时未将空间开到题目要求, 隐藏的空间倍数关系例如无向图2倍$ $\to RE$$3. 除数是个减法式子$ $整数\to RE 浮点数\to WA \to 特判$$4. 离线并查集的重复操作$ $\to 只有第一次才需要unite$$5. 回溯暴搜的复杂度是阶乘级或者指数级$ $\to 看到正常数据的题再爆搜就可以去死了$$6. 乘法取模, a \times b$ $\to a \% MOD \times (b\%MOD)\%MOD $$7. two pointers的时候，相等时移动指针$ $\to 小心重复数据，死循环死你啊$$8. 利用欧拉定理降幂的时候x^n\% MOD，特判x\% MOD == 0$ $\to 此时答案是0啊$]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>小结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4125 Moles（nlogn建立二叉搜索树、kmp）]]></title>
    <url>%2F2016%2F05%2F02%2FHDU%204125%20Moles%EF%BC%88nlogn%E5%BB%BA%E7%AB%8B%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E3%80%81kmp%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N\le 6\times 10^5，给定1\sim N的序列，按照这个顺序建立一颗二叉搜索树$$奇数是1，偶数是0，先序遍历这颗二叉搜索树生成1个01的欧拉序列$$查找T串可重叠的出现了几次，|T|\le 7000$ 分析： $不学是要还的。。$$这个数据范围只能nlogn建立BST了，set动态维护一下插入的节点$$每次查找比当前x大的的最小点r，以及比x小的最大点l$$分别尝试r的左儿子，以及l的右儿子能不能插入就可以了$$然后先序遍历一遍，C++开栈一发，跑个kmp就ok了$$时间复杂度O(nlogn)$ 代码： // // Created by TaoSama on 2016-05-03 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 6e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, m; int rt, ls[N], rs[N]; char s[N &lt;&lt; 1], t[7010]; void dfs(int rt) { s[n++] = (rt &amp; 1) + &#39;0&#39;; if(ls[rt]) { dfs(ls[rt]); s[n++] = (rt &amp; 1) + &#39;0&#39;; } if(rs[rt]) { dfs(rs[rt]); s[n++] = (rt &amp; 1) + &#39;0&#39;; } } int kmp() { m = strlen(t); vector&lt;int&gt; nxt(m + 1); nxt[0] = -1; for(int i = 0, j = -1; i &lt; m;) { if(j == -1 || t[i] == t[j]) nxt[++i] = ++j; else j = nxt[j]; } int ret = 0; for(int i = 0, j = 0; i &lt; n;) { if(j == -1 || s[i] == t[j]) ++i, ++j; else j = nxt[j]; if(j == m) { ++ret; j = nxt[j]; } } return ret; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); int T; scanf(&quot;%d&quot;, &amp;T); while(T--) { scanf(&quot;%d&quot;, &amp;n); memset(ls, 0, sizeof ls); memset(rs, 0, sizeof rs); set&lt;int&gt; st; for(int i = 1; i &lt;= n; ++i) { int x; scanf(&quot;%d&quot;, &amp;x); if(!st.size()) rt = x; else { auto it = st.lower_bound(x); if(it == st.end()) rs[*--it] = x; else { if(!ls[*it]) ls[*it] = x; else rs[*--it] = x; } } st.insert(x); } scanf(&quot;%s&quot;, t); n = 0; dfs(rt); s[n] = 0; static int kase = 0; printf(&quot;Case #%d: %d\n&quot;, ++kase, kmp()); } return 0; }]]></content>
      <categories>
        <category>数据结构</category>
        <category>二叉搜索树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HDU 5661 Claris and XOR（xor贪心）]]></title>
    <url>%2F2016%2F05%2F01%2FHDU%205661%20Claris%20and%20XOR%EF%BC%88xor%E8%B4%AA%E5%BF%83%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $给定a,b,c,d,1\leq a,b,c,d\leq10^{18}$$现要求找到x\oplus y，x\in [a, b]，y\in[c, d]的最大值$ 分析： $显然从高位到低位开始贪心，要最大肯定优先要求不同$$也就是先测试01和10这两种情况，再测试00和11这两种情况，同时判断是不是符合区间范围$$假设i这位已经放置好了，显然最小值后面全是0，最大值即全是1$$考虑合法比较麻烦，反向思考非法情况，最小值比右边界大，或最大值比左边界小$$时间复杂度O(b)，b=log_2 10^{18}$ 代码： // // Created by TaoSama on 2016-04-25 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; typedef long long LL; LL a, b, c, d; bool ok(LL x, LL y, int i) { LL lft = (1LL &lt;&lt; i) - 1; LL xr = x + lft, yr = y + lft; if(x &gt; b || xr &lt; a) return false; if(y &gt; d || yr &lt; c) return false; return true; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%I64d%I64d%I64d%I64d&quot;, &amp;a, &amp;b, &amp;c, &amp;d); LL x = 0, y = 0; for(int i = 62; ~i; --i) { LL delta = 1LL &lt;&lt; i; if(ok(x + delta, y, i)) x += delta; else if(ok(x, y + delta, i)) y += delta; else if(ok(x + delta, y + delta, i)) { x += delta; y += delta; } } printf(&quot;%I64d\n&quot;, x ^ y); } return 0; }]]></content>
      <categories>
        <category>技巧</category>
        <category>xor</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5014 Number Sequence（xor贪心）]]></title>
    <url>%2F2016%2F05%2F01%2FHDU%205014%20Number%20Sequence%EF%BC%88xor%E8%B4%AA%E5%BF%83%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $给定n+1个数，a_i\in [0, n]，并且a_i\neq a_j$$现要求构造n+1个b_i，构造方式同a_i，并且使得\sum a_i\oplus b_i最大$$输出这个sum，以及n+1个对应的b_i$ 分析： $手玩一下发现，如果n+1个数是奇数，那么0是多余的，剩余的可以两两配对$$如果n+1是偶数直接配对即可$$配对方式通过手玩可以发现，从大的开始，贪心补全所有的0就可以了$$时间复杂度O(n)$ 代码： // // Created by TaoSama on 2016-04-25 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, a[N], mp[N]; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); while(scanf(&quot;%d&quot;, &amp;n) == 1) { for(int i = 0; i &lt;= n; ++i) scanf(&quot;%d&quot;, a + i); memset(mp, -1, sizeof mp); if(~n &amp; 1) mp[0] = 0; long long ans = 0; for(int i = n; ~i; --i) { if(mp[i] == -1) { int b = 32 - __builtin_clz(i); int all = (1 &lt;&lt; b) - 1; mp[i] = all ^ i; mp[all ^ i] = i; } ans += i ^ mp[i]; } printf(&quot;%I64d\n&quot;, ans); for(int i = 0; i &lt;= n; ++i) printf(&quot;%d%c&quot;, mp[a[i]], &quot; \n&quot;[i == n]); } return 0; }]]></content>
      <categories>
        <category>技巧</category>
        <category>xor</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4757 Tree（可持久化trie）]]></title>
    <url>%2F2016%2F05%2F01%2FHDU%204757%20Tree%EF%BC%88%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96trie%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N\le 10^5个点的树，点权A_i &lt; 2^{16}，M\le 10^5次询问$$每次查询u\to v路径上点权与k异或的最大值$ 分析： $由于要取出路径那就只能可持久化trie了$$每一颗trie都是前缀和，显然根据lca的那个思想，u\to v路径，就是$$判断u这棵trie以及v这颗trie，以及lca(u, v)这颗trie的cnt域$$即cnt[u]+cnt[v]-2*cnt[lca(u, v)]是否为正$$但是这样别忘记特判lca这点的点权。。$$其他的就是按照普通的做法贪心的去找这个最大值就好了$ 代码： // // Created by TaoSama on 2016-04-22 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; struct Trie { static const int M = 17 * 1e5 + 10, S = 2; struct Node { int nxt[S], cnt; } dat[M]; int sz, root[N]; void init() { sz = root[0] = 0; memset(&amp;dat[0], 0, sizeof dat[0]); } void insert(int&amp; rt, int fa, int x) { int u; u = rt = ++sz; dat[u] = dat[fa]; for(int i = 15; ~i; --i) { int c = x &gt;&gt; i &amp; 1; int v = ++sz; dat[v] = dat[dat[u].nxt[c]]; //copy ++dat[v].cnt; dat[u].nxt[c] = v; //link u = v; } } int query(int u, int v, int z, int x) { //lca没算 int ret = 0; for(int i = 15; ~i; --i) { int c = x &gt;&gt; i &amp; 1; int have = dat[dat[u].nxt[c ^ 1]].cnt + dat[dat[v].nxt[c ^ 1]].cnt; have -= 2 * dat[dat[z].nxt[c ^ 1]].cnt; if(have) { ret |= 1 &lt;&lt; i; c ^= 1; } u = dat[u].nxt[c]; v = dat[v].nxt[c]; z = dat[z].nxt[c]; } return ret; } } trie; int n, q; struct Edge { int v, nxt; } edge[N &lt;&lt; 1]; int head[N], cnt; void addEdge(int u, int v) { edge[cnt] = {v, head[u]}; head[u] = cnt++; edge[cnt] = {u, head[v]}; head[v] = cnt++; } int val[N]; int dep[N], p[17][N]; void dfs(int u, int fa) { trie.insert(trie.root[u], trie.root[fa], val[u]); p[0][u] = fa; for(int i = 1; i &lt; 17; ++i) p[i][u] = p[i - 1][p[i - 1][u]]; for(int i = head[u]; ~i; i = edge[i].nxt) { int v = edge[i].v; if(v == fa) continue; dep[v] = dep[u] + 1; dfs(v, u); } } int lca(int u, int v) { if(dep[u] &gt; dep[v]) swap(u, v); for(int i = 0; i &lt; 17; ++i) if(dep[v] - dep[u] &gt;&gt; i &amp; 1) v = p[i][v]; if(u == v) return u; for(int i = 16; ~i; --i) if(p[i][u] != p[i][v]) u = p[i][u], v = p[i][v]; return p[0][u]; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); while(scanf(&quot;%d%d&quot;, &amp;n, &amp;q) == 2) { for(int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, val + i); cnt = 0; memset(head, -1, sizeof head); for(int i = 1; i &lt; n; ++i) { int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); addEdge(u, v); } trie.init(); dfs(1, 0); // for(int i = 0; i &lt; 5; ++i) // for(int u = 1; u &lt;= n; ++u) // printf(&quot;p[%d][%d] = %d\n&quot;, i, u, p[i][u]); while(q--) { int u, v, w; scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w); int z = lca(u, v), ans = w ^ val[z]; ans = max(ans, trie.query(trie.root[u], trie.root[v], trie.root[z], w)); printf(&quot;%d\n&quot;, ans); } } return 0; }]]></content>
      <categories>
        <category>技巧</category>
        <category>xor</category>
      </categories>
      <tags>
        <tag>可持久trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 12 E. Beautiful Subarrays（xor trie）]]></title>
    <url>%2F2016%2F05%2F01%2FEducational%20Codeforces%20Round%2012%20E.%20Beautiful%20Subarrays%EF%BC%88xor%20trie%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N\le 10^6个点的数，xor(l, r)=A_l\oplus A_{l+1}\oplus\cdots\oplus A_r$$求xor(l, r)\ge k的(l, r)对数$ 分析： $xor trie贪心$$我们发现这个是个连续异或和，经典的技巧$$设prefix[i]:=A_1\oplus A_2\oplus\cdots\oplus A_i$$那么显然我们可以得到xor(l, r)=prefix[r]\oplus prefix[l-1]$$所以就枚举每个r，不断的把prefix[i]从高位到低位插入到trie里$$然后贪心的去找大于k的，因为插入的时候把这个prefix[i]的所有节点的cnt都增加了$$最后再把=k的加上就可以不重不漏的算完了$$时间复杂度O(nb)$ 代码： // // Created by TaoSama on 2016-04-21 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; struct Trie { static const int M = 32 * 1e6 + 10, S = 2; int root, sz; int nxt[M][S], cnt[M]; int newNode() { cnt[sz] = 0; memset(nxt[sz], -1, sizeof nxt[sz]); return sz++; } void init() { sz = 0; root = newNode(); } void insert(int x) { int u = root; for(int i = 31; ~i; --i) { int c = x &gt;&gt; i &amp; 1, &amp;v = nxt[u][c]; if(v == -1) v = newNode(); ++cnt[v]; u = v; } } int query(int x, int k) { int u = root, ret = 0; for(int i = 31; ~i; --i) { int c = x &gt;&gt; i &amp; 1; if(k &gt;&gt; i &amp; 1) u = nxt[u][c ^ 1]; else { ret += cnt[nxt[u][c ^ 1]]; //&gt; u = nxt[u][c]; } if(u == -1) return ret; } return ret + cnt[u]; //= } } trie; int n, k; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); while(scanf(&quot;%d%d&quot;, &amp;n, &amp;k) == 2) { trie.init(); trie.insert(0); int sum = 0; long long ans = 0; for(int i = 1; i &lt;= n; ++i) { int x; scanf(&quot;%d&quot;, &amp;x); sum ^= x; ans += trie.query(sum, k); trie.insert(sum); } printf(&quot;%I64d\n&quot;, ans); } return 0; }]]></content>
      <categories>
        <category>技巧</category>
        <category>xor</category>
      </categories>
      <tags>
        <tag>xor trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 3764 The xor-longest Path（xor trie）]]></title>
    <url>%2F2016%2F05%2F01%2FPOJ%203764%20The%20xor-longest%20Path%EF%BC%88xor%20trie%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N\le 10^5个点的树，A_i &lt; 2^{31}$$路径异或和：=路径上所有边权的异或和，求最大的路径异或和$ 分析： $xor trie配合简单dp思想$$我们发现这个是个连续异或和，经典的技巧$$设prefix[i]:=A_1\oplus A_2\oplus\cdots\oplus A_i$$那么显然我们可以得到xor(l, r)=prefix[r]\oplus prefix[l-1]$$同理树上也是一样的，把树搜一遍，也就是相当于求f[i]:=以i这个点结尾的路径的最大异或和$$最终答案ans = max\{f[i]\}$$时间复杂度O(nb)$ 代码： // // Created by TaoSama on 2016-04-22 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; struct Trie { static const int M = 32 * 1e5 + 10, S = 2; int root, sz; int nxt[M][S]; int newNode() { memset(nxt[sz], -1, sizeof nxt[sz]); return sz++; } void init() { sz = 0; root = newNode(); } void insert(int x) { int u = root; for(int i = 31; ~i; --i) { int c = x &gt;&gt; i &amp; 1, &amp;v = nxt[u][c]; if(v == -1) v = newNode(); u = v; } } int query(int x) { int u = root, ret = 0; for(int i = 31; ~i; --i) { int c = x &gt;&gt; i &amp; 1; if(~nxt[u][c ^ 1]) { ret |= 1 &lt;&lt; i; u = nxt[u][c ^ 1]; } else u = nxt[u][c]; } return ret; } } trie; struct Edge { int v, nxt, c; } edge[N &lt;&lt; 1]; int head[N], cnt; void addEdge(int u, int v, int c) { edge[cnt] = {v, head[u], c}; head[u] = cnt++; edge[cnt] = {u, head[v], c}; head[v] = cnt++; } void dfs(int u, int f, int sum, int&amp; ans) { for(int i = head[u]; ~i; i = edge[i].nxt) { int v = edge[i].v; if(v == f) continue; ans = max(ans, trie.query(sum ^ edge[i].c)); trie.insert(sum ^ edge[i].c); dfs(v, u, sum ^ edge[i].c, ans); } } int n; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); while(scanf(&quot;%d&quot;, &amp;n) == 1) { cnt = 0; memset(head, -1, sizeof head); for(int i = 1; i &lt; n; ++i) { int u, v, c; scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;c); addEdge(u, v, c); } int ans = 0; trie.init(); trie.insert(0); dfs(0, -1, 0, ans); printf(&quot;%d\n&quot;, ans); } return 0; }]]></content>
      <categories>
        <category>技巧</category>
        <category>xor</category>
      </categories>
      <tags>
        <tag>xor trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ 4260 Codechef REBXOR（xor trie）]]></title>
    <url>%2F2016%2F05%2F01%2FBZOJ%204260%20Codechef%20REBXOR%EF%BC%88xor%20trie%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $2\le N\le 4\times 10^5个数，A_i\le 10^9$$求(A_{l_1}\oplus A_{l_1+1}\oplus\cdots\oplus A_{r_1}) + (A_{l_2}\oplus A_{l_2+1}\oplus\cdots\oplus A_{r_2})$$且1\le l_1\le r_1 &lt; l_2 \le r_2，的最大值$ 分析： $xor trie配合简单dp思想$$我们发现这个是个连续异或和，经典的技巧$$设prefix[i]:=A_1\oplus A_2\oplus\cdots\oplus A_i$$那么显然我们可以得到xor(l, r)=prefix[r]\oplus prefix[l-1]$$所以一个显然的想法就是枚举4个点，但是可以通过预处理来降低复杂度$$维护prefixMax[i]:=以i结尾的区间的最大连续异或和，这个可以用过trie来得到$$把这个再前缀max一下，就可以得到\le i的区间的最大连续异或和了$$再倒着搞一遍就可以解决了$$为了方便可以多插入1个0$$时间复杂度O(nb)$ 代码： // // Created by TaoSama on 2016-04-21 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 4e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; struct Trie { static const int M = 32 * 4e5 + 10, S = 2; int root, sz; int nxt[M][S]; int newNode() { memset(nxt[sz], -1, sizeof nxt[sz]); return sz++; } void init() { sz = 0; root = newNode(); } void insert(int x) { int u = root; for(int i = 31; ~i; --i) { int c = x &gt;&gt; i &amp; 1, &amp;v = nxt[u][c]; if(v == -1) v = newNode(); u = v; } } int query(int x) { int u = root, ret = 0; for(int i = 31; ~i; --i) { int c = x &gt;&gt; i &amp; 1; if(~nxt[u][c ^ 1]) { ret |= 1 &lt;&lt; i; u = nxt[u][c ^ 1]; } else u = nxt[u][c]; } return ret; } } trie; int n, a[N], sum[N], pre[N]; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); scanf(&quot;%d&quot;, &amp;n); sum[0] = sum[n + 1] = 0; for(int i = 1; i &lt;= n; ++i) { scanf(&quot;%d&quot;, a + i); sum[i] = sum[i - 1] ^ a[i]; } trie.init(); trie.insert(sum[0]); for(int i = 1; i &lt;= n; ++i) { pre[i] = max(pre[i - 1], trie.query(sum[i])); trie.insert(sum[i]); } int ans = 0; trie.init(); trie.insert(sum[n + 1]); for(int i = n; i &gt; 1; --i) { sum[i] = sum[i + 1] ^ a[i]; ans = max(ans, pre[i - 1] + trie.query(sum[i])); trie.insert(sum[i]); } printf(&quot;%d\n&quot;, ans); return 0; }]]></content>
      <categories>
        <category>技巧</category>
        <category>xor</category>
      </categories>
      <tags>
        <tag>xor trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5536 Chip Factory（xor trie）]]></title>
    <url>%2F2016%2F05%2F01%2FHDU%205536%20Chip%20Factory%EF%BC%88xor%20trie%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $3\le N\le 10^3个数，求\max_{i,j,k} (s_i+s_j) \oplus s_k的最大值，i\ne j\ne k$ 分析： $xor trie简单技巧$$将所有数插入01 trie中，n^2枚举s_i+s_j，由于要不同先把它俩删了$$然后再去贪心的找s_k，不要忘记恢复就好$$时间复杂度O(n^2b)，b=log_2(max\{A_i\})$ 代码： // // Created by TaoSama on 2016-04-21 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, a[N]; struct Trie { static const int M = 32 * 1e3 + 10, S = 2; int root, sz; int nxt[M][S], have[M]; int newNode() { have[sz] = 0; memset(nxt[sz], -1, sizeof nxt[sz]); return sz++; } void init() { sz = 0; root = newNode(); } void update(int x, int d) { int u = root; for(int i = 31; ~i; --i) { int c = x &gt;&gt; i &amp; 1, &amp;v = nxt[u][c]; if(v == -1) v = newNode(); have[v] += d; u = v; } } int query(int x) { int u = root, ret = 0; for(int i = 31; ~i; --i) { int c = x &gt;&gt; i &amp; 1; if(have[nxt[u][c ^ 1]]) { ret |= 1 &lt;&lt; i; u = nxt[u][c ^ 1]; } else u = nxt[u][c]; } return ret; } } trie; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%d&quot;, &amp;n); trie.init(); for(int i = 1; i &lt;= n; ++i) { scanf(&quot;%d&quot;, a + i); trie.update(a[i], 1); } int ans = 0; for(int i = 1; i &lt;= n; ++i) { trie.update(a[i], -1); for(int j = i + 1; j &lt;= n; ++j) { trie.update(a[j], -1); ans = max(ans, trie.query(a[i] + a[j])); trie.update(a[j], 1); } trie.update(a[i], 1); } printf(&quot;%d\n&quot;, ans); } return 0; }]]></content>
      <categories>
        <category>技巧</category>
        <category>xor</category>
      </categories>
      <tags>
        <tag>xor trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4825 Xor Sum（xor trie）]]></title>
    <url>%2F2016%2F05%2F01%2FHDU%204825%20Xor%20Sum%EF%BC%88xor%20trie%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N\le 10^5个数，M\le 10^5次询问$$每次询问给出一个整数K，从数列A_i中找出一个数S使得K\oplus S值最大$ 分析： $xor trie基础题$$将所有数插入01 trie中，每次询问就在trie上贪心的找$$由于要最大，那么就从高位到低位插入，这样查找的时候也从高位到低位$$由于xor的性质，0\oplus1=1，显然优先找不同的，这样贪心的找就可以了$$时间复杂度为O(nb)，b=log_2(max\{A_i\})$ 代码： // // Created by TaoSama on 2016-04-21 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, q; struct Trie { static const int M = 32 * 1e5 + 10, S = 2; int root, sz; int nxt[M][S], val[M]; int newNode() { val[sz] = 0; memset(nxt[sz], -1, sizeof nxt[sz]); return sz++; } void init() { sz = 0; root = newNode(); } void insert(int x) { int u = root; for(int i = 31; ~i; --i) { int c = x &gt;&gt; i &amp; 1, &amp;v = nxt[u][c]; if(v == -1) v = newNode(); u = v; } val[u] = x; } int query(int x) { int u = root; for(int i = 31; ~i; --i) { int c = x &gt;&gt; i &amp; 1; if(~nxt[u][c ^ 1]) u = nxt[u][c ^ 1]; else u = nxt[u][c]; } return val[u]; } } trie; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%d%d&quot;, &amp;n, &amp;q); trie.init(); for(int i = 1; i &lt;= n; ++i) { int x; scanf(&quot;%d&quot;, &amp;x); trie.insert(x); } static int kase = 0; printf(&quot;Case #%d:\n&quot;, ++kase); while(q--) { int x; scanf(&quot;%d&quot;, &amp;x); printf(&quot;%d\n&quot;, trie.query(x)); } } return 0; }]]></content>
      <categories>
        <category>技巧</category>
        <category>xor</category>
      </categories>
      <tags>
        <tag>xor trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 349 (Div. 2) D. World Tour（最短路）]]></title>
    <url>%2F2016%2F04%2F30%2FCodeforces%20Round%20349%20(Div.%202)%20D.%20World%20Tour%EF%BC%88%E6%9C%80%E7%9F%AD%E8%B7%AF%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N\le 3000，M\le 5000，N个点M条边的权为1的有向图$$求四个不同的点，使得a\rightarrow b \rightarrow c \rightarrow d都走最短路的路程和最长，路径中经过的点不作要求$ 分析： $直接跑N次bfs搞出全源最短路d[i][j]$$然后用pair顺图i\rightarrow j存一次按距离排个序，逆图j\rightarrow i也搞一个$$分别是o[i][j]和r[i][j]$$枚举b和c，先找a，再d，注意要不同$$由于这个条件，我们干脆再找一次，这次先找d再找a$$注意不可达的。$$更新答案即可，复杂度加上排序大概是O(n^2logn+nm)$ 代码： // // Created by TaoSama on 2016-04-30 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 3e3 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, m; vector&lt;int&gt; G[N]; typedef pair&lt;int, int&gt; P; int d[N][N]; P o[N][N], r[N][N]; //original i-&gt;j, reversing i&lt;-j void bfs(int s, int* d) { queue&lt;int&gt; q; q.push(s); for(int i = 1; i &lt;= n; ++i) d[i] = -1; d[s] = 0; while(q.size()) { int u = q.front(); q.pop(); for(int v : G[u]) { if(d[v] == -1) { d[v] = d[u] + 1; q.push(v); } } } } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); while(m--) { int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); G[u].push_back(v); } for(int i = 1; i &lt;= n; ++i) bfs(i, d[i]); for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= n; ++j) o[i][j] = {d[i][j], j}, r[i][j] = {d[j][i], j}; for(int i = 1; i &lt;= n; ++i) sort(o[i] + 1, o[i] + 1 + n); for(int i = 1; i &lt;= n; ++i) sort(r[i] + 1, r[i] + 1 + n); int sum = 0; vector&lt;int&gt; ans; //不可达的是最小的 for(int b = 1; b &lt;= n; ++b) { for(int c = 1; c &lt;= n; ++c) { if(b == c || d[b][c] == -1) continue; int x, y, i; //x first i = n; if(~r[b][i].second) while(r[b][i].second == b || r[b][i].second == c) --i; x = r[b][i].second; i = n; if(~o[c][i].second) while(o[c][i].second == b || o[c][i].second == c || o[c][i].second == x) --i; y = o[c][i].second; if(~d[x][b] &amp;&amp; ~d[c][y]) { int tmp = d[x][b] + d[b][c] + d[c][y]; if(tmp &gt; sum) sum = tmp, ans = {x, b, c, y}; } //y first i = n; if(~o[c][i].second) while(o[c][i].second == b || o[c][i].second == c) --i; y = o[c][i].second; i = n; if(~r[b][i].second) while(r[b][i].second == b || r[b][i].second == c || r[b][i].second == y) --i; x = r[b][i].second; if(~d[x][b] &amp;&amp; ~d[c][y]) { int tmp = d[x][b] + d[b][c] + d[c][y]; if(tmp &gt; sum) sum = tmp, ans = {x, b, c, y}; } } } for(int x : ans) printf(&quot;%d &quot;, x); puts(&quot;&quot;); return 0; }]]></content>
      <categories>
        <category>图论</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 349 (Div. 2) C. Reberland Linguistics（dp）]]></title>
    <url>%2F2016%2F04%2F30%2FCodeforces%20Round%20349%20(Div.%202)%20C.%20Reberland%20Linguistics%EF%BC%88dp%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $给定5\le |L|\le 10^4长度的字符串，现划分这个字符串$$使得第一个子串长度\ge 5，后面的所有子串长度为2或3，并且相邻的2个子串不能相同$$字典序输出所有划分方案中的长度为2或3的子串$ 分析： $- - 当然是dp啦，f[i][0]:=前i个字符，划分长度2的合法子串，s[i-1,i]$$同理，f[i][1]:=前i个字符，划分长度3的合法子串，s[i-2,i-1,i]$$这个dp是顺着的，我们发现没法保证中途的合法性，不能存储这些子串$$但是倒着dp就可以了，就都是合法的了，就可以边搞边存了$ 代码： // // Created by TaoSama on 2016-04-30 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; string s; int f[N][2]; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); while(cin &gt;&gt; s) { memset(f, 0, sizeof f); s = &#39; &#39; + s; int sz = s.size() - 1; set&lt;string&gt; ss; for(int i = sz, j = 1; i; --i, ++j) { if(j &lt; 2 || i &lt;= 5) continue; if(j == 2) { ss.insert(s.substr(i, 2)); f[i][0] = 1; } else if(j == 3) { ss.insert(s.substr(i, 3)); f[i][1] = 1; } else { if(f[i + 2][0]) { string b = s.substr(i + 2, 2); string c = s.substr(i, 2); if(b != c) { ss.insert(c); f[i][0] = 1; } } if(f[i + 2][1]) { string c = s.substr(i, 2); ss.insert(c); f[i][0] = 1; } if(f[i + 3][0]) { string c = s.substr(i, 3); ss.insert(c); f[i][1] = 1; } if(f[i + 3][1]) { string b = s.substr(i + 3, 3); string c = s.substr(i, 3); if(b != c) { ss.insert(c); f[i][1] = 1; } } } } cout &lt;&lt; ss.size() &lt;&lt; &#39;\n&#39;; for(auto s : ss) cout &lt;&lt; s &lt;&lt; &#39;\n&#39;; } return 0; }]]></content>
      <categories>
        <category>动态规划</category>
        <category>线性dp</category>
      </categories>
      <tags>
        <tag>线性dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 3585 maximum shortest distance（二分、最大团）]]></title>
    <url>%2F2016%2F04%2F29%2FHDU%203585%20maximum%20shortest%20distance%EF%BC%88%E4%BA%8C%E5%88%86%E3%80%81%E6%9C%80%E5%A4%A7%E5%9B%A2%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $给定N\le 50个点的坐标，从中选出2\le k\le n个点，使得两两最近的距离最远$$求这个距离$ 分析： $看到最大化最小值就知道二分了$$二分这个最小值，凡是大于的都连边，然后判断最大团是不是\ge k$$100次T了，50次就过了$ 代码： // // Created by TaoSama on 2016-04-29 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 60 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; // 1. 最大团点的数量 = 补图中最大独立集点的数量 // 2. 图的染色问题中，最少需要的颜色的数量 = 最大团点的数量 struct MaxClique { static const int V = 60; bool g[V][V]; int n, ans, max[V], adj[V][V]; int path[V], clique[V]; //for record //max[i]:= [i, n]&#39;s maximum clique //adj[dep][i]:= available vertices void init(int _n) { n = _n; } bool dfs(int cur, int dep) { if(cur == 0) { if(dep &gt; ans) { ans = dep; swap(clique, path); return 1; } return 0; } for(int i = 0; i &lt; cur; ++i) { if(dep + cur - i &lt;= ans) return 0; //dep + left &lt;= ans int u = adj[dep][i], nxt = 0; if(dep + max[u] &lt;= ans) return 0; //same as above path[dep] = u; for(int j = i + 1; j &lt; cur; ++j) { int v = adj[dep][j]; if(g[u][v]) adj[dep + 1][nxt++] = v; } if(dfs(nxt, dep + 1)) return 1; } return 0; } int maxClique() { ans = 0; memset(max, 0, sizeof max); for(int i = n - 1; ~i; --i) { int cur = 0; for(int j = i + 1; j &lt; n; ++j) if(g[i][j]) adj[1][cur++] = j; path[0] = i; dfs(cur, 1); max[i] = ans; } return ans; } } solver; int n, k; int x[N], y[N]; double d[N][N]; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); while(scanf(&quot;%d%d&quot;, &amp;n, &amp;k) == 2) { solver.init(n); for(int i = 0; i &lt; n; ++i) scanf(&quot;%d%d&quot;, x + i, y + i); for(int i = 0; i &lt; n; ++i) for(int j = i + 1; j &lt; n; ++j) d[i][j] = d[j][i] = hypot(x[i] - x[j], y[i] - y[j]); double l = 0, r = 2e4; for(int i = 1; i &lt;= 50; ++i) { double m = (l + r) / 2; for(int u = 0; u &lt; n; ++u) for(int v = u + 1; v &lt; n; ++v) solver.g[u][v] = solver.g[v][u] = d[u][v] &gt;= m; if(solver.maxClique() &gt;= k) l = m; else r = m; } printf(&quot;%.2f\n&quot;, l); } return 0; }]]></content>
      <categories>
        <category>图论</category>
        <category>最大团</category>
      </categories>
      <tags>
        <tag>最大团</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 12 D. Simple Subset（最大团）]]></title>
    <url>%2F2016%2F04%2F29%2FEducational%20Codeforces%20Round%2012%20D.%20Simple%20Subset%EF%BC%88%E6%9C%80%E5%A4%A7%E5%9B%A2%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $给定N\le 10^3个数，从中选出一些数，使得这些数任意两两之和是素数$$求最多选出的数的个数，以及方案$ 分析： $讲道理这题可以贪心，素数=奇数+偶数，所以不考虑1这个数的话答案最多是2$$- - 最大团直接裸搞也可以，迷之复杂度1000个点都O(跑得过)$ 代码： // // Created by TaoSama on 2016-04-29 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 2e6 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; struct MaxClique { static const int V = 1e3 + 10; bool g[V][V]; int n, ans, max[V], adj[V][V]; int path[V], clique[V]; //for record //max[i]:= [i, n]&#39;s maximum clique //adj[dep][i]:= available vertices void init(int _n) { n = _n; } bool dfs(int cur, int dep) { if(cur == 0) { if(dep &gt; ans) { ans = dep; swap(clique, path); return 1; } return 0; } for(int i = 0; i &lt; cur; ++i) { if(dep + cur - i &lt;= ans) return 0; //dep + left &lt;= ans int u = adj[dep][i], nxt = 0; if(dep + max[u] &lt;= ans) return 0; //same as above path[dep] = u; for(int j = i + 1; j &lt; cur; ++j) { int v = adj[dep][j]; if(g[u][v]) adj[dep + 1][nxt++] = v; } if(dfs(nxt, dep + 1)) return 1; } return 0; } int maxClique() { ans = 0; memset(max, 0, sizeof max); for(int i = n - 1; ~i; --i) { int cur = 0; for(int j = i + 1; j &lt; n; ++j) if(g[i][j]) adj[1][cur++] = j; path[0] = i; dfs(cur, 1); max[i] = ans; } return ans; } } solver; int n; bool notPrime[N]; void gao() { for(int i = 2; i * i &lt; N; ++i) { if(notPrime[i]) continue; for(int j = i * i; j &lt; N; j += i) notPrime[j] = true; } } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); gao(); while(scanf(&quot;%d&quot;, &amp;n) == 1) { vector&lt;int&gt; a(n); for(int i = 0; i &lt; n; ++i) scanf(&quot;%d&quot;, &amp;a[i]); solver.init(n); for(int i = 0; i &lt; n; ++i) for(int j = i + 1; j &lt; n; ++j) solver.g[i][j] = solver.g[j][i] = !notPrime[a[i] + a[j]]; int ans = solver.maxClique(); printf(&quot;%d\n&quot;, ans); for(int i = 0; i &lt; ans; ++i) printf(&quot;%d%c&quot;, a[solver.clique[i]], &quot; \n&quot;[i == ans - 1]); } return 0; }]]></content>
      <categories>
        <category>图论</category>
        <category>最大团</category>
      </categories>
      <tags>
        <tag>最大团</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSU 1720 How to Get 2^n（trie上贪心、高精度）]]></title>
    <url>%2F2016%2F04%2F29%2FCSU%201720%20How%20to%20Get%202%5En%EF%BC%88trie%E4%B8%8A%E8%B4%AA%E5%BF%83%E3%80%81%E9%AB%98%E7%B2%BE%E5%BA%A6%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $给定N\le 10^5个数，1\le A_i\le 10^{30}(2^{100}&gt;10^{30})$$求A_i+A_j=2^x的(i, j)对数$ 分析： $先把大整数转换成二进制，然后从低位到高位插到trie里$$对于每个数A_i，先找到1个A_j，使得A_i+A_j为最小的那个2^x，从trie上找到A_j$$对于之后比它大的2^y，A_j’的取值是A_j从x这个二进制位起都是1，trie累加之后的即可$$感觉不是很好写，时间复杂度O(nb)，b=100$ 代码： // // Created by TaoSama on 2016-04-24 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; #include &lt;bitset&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; const int B = 101; int n; struct Type { int n; bitset&lt;B&gt; b; Type() { n = 0; b.reset(); } }; Type a[N]; void toBinary(Type&amp; a, char* b) { a = Type(); int n = strlen(b); for(int i = 0; i &lt; n; ++i) b[i] -= &#39;0&#39;; reverse(b, b + n); int cnt = 0; --n; while(~n) { //use b[0], u fucking zz a.b[a.n++] = b[0] &amp; 1; //mod int mod = 0; for(int i = n; ~i; --i) { //divide mod = mod * 10 + b[i]; b[i] = mod &gt;&gt; 1; mod &amp;= 1; } if(!b[n]) --n; } } Type subtract(Type&amp; a, Type&amp; b) { Type ret; bool lent = false; for(int i = 0; i &lt; B; ++i) { int x = a.b[i]; if(lent) { x -= 1; if(x &lt; 0) x += 2; else lent = false; } x -= b.b[i]; if(x &lt; 0) { x += 2; lent = true; } ret.b[i] = x; } return ret; } char b[50]; int getBitLength(Type&amp; b) { int bits = 0; for(int j = B; j; --j) { if(b.b[j - 1]) { bits = j; break; } } return bits; } struct Trie { static const int M = B * 1e5 + 10, S = 2; int nxt[M][S], val[M]; int root, sz; int newNode() { val[sz] = 0; memset(nxt[sz], 0, sizeof nxt[sz]); return sz++; } void init() { sz = 0; newNode(); root = newNode(); } void update(Type&amp; b, int d) { int u = root; for(int i = 0; i &lt; b.n; ++i) { int c = b.b[i], &amp;v = nxt[u][c]; if(!v) v = newNode(); u = v; } val[u] += d; } int query(Type&amp; b, int bits) { int u = root; int ret = 0, n = getBitLength(b); for(int i = 0; i &lt; bits; ++i) { int c = b.b[i]; u = nxt[u][c]; if(i == n - 1) ret += val[u]; } for(int i = bits; i &lt; B; ++i) { u = nxt[u][1]; ret += val[u]; } return ret; } } trie; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); int T; scanf(&quot;%d&quot;, &amp;T); while(T--) { scanf(&quot;%d&quot;, &amp;n); trie.init(); for(int i = 1; i &lt;= n; ++i) { scanf(&quot;%s&quot;, b); toBinary(a[i], b); trie.update(a[i], 1); } long long ans = 0; for(int i = 1; i &lt;= n; ++i) { trie.update(a[i], -1); int bits = a[i].n; Type b; b.b[bits] = 1; Type c = subtract(b, a[i]); ans += trie.query(c, bits); trie.update(a[i], 1); } printf(&quot;%lld\n&quot;, ans &gt;&gt; 1); } return 0; }]]></content>
      <categories>
        <category>技巧</category>
        <category>xor</category>
      </categories>
      <tags>
        <tag>trie上贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSU 1728 线形逐步共聚合反应（三分、dp）]]></title>
    <url>%2F2016%2F04%2F29%2FCSU%201728%20%E7%BA%BF%E5%BD%A2%E9%80%90%E6%AD%A5%E5%85%B1%E8%81%9A%E5%90%88%E5%8F%8D%E5%BA%94%EF%BC%88%E4%B8%89%E5%88%86%E3%80%81dp%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $给定N\le 2\times 10^5个数，现要使|\sum_{i=l}^r (A_i - x)|的最大值最小$ 分析： $令s(l, r)=\sum_{i=l}^r (A_i - x)$$max\{|s(l, r)|\}$$=max\{max\left(s(l, r), -s(l, r)\right)\}$$=max\{max\{s(l, r)\}, max\{-s(l, r)\}\}$$=max\{A, B\}$$我们发现A和B分别是最大和最小连续子段和$$A随x单调减，B随x单调增，则原函数是单峰的，我们可以用过三分来求这个最小值$$时间复杂度为O(nlogC)$ 代码： // // Created by TaoSama on 2016-04-28 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 2e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n; double a[N]; //minimize the maximum substring sum double check(double x) { double minv, maxv, sum1, sum2; minv = maxv = sum1 = sum2 = 0; for(int i = 1; i &lt;= n; ++i) { sum1 += a[i] - x; sum2 += a[i] - x; minv = min(minv, sum1); maxv = max(maxv, sum2); if(sum1 &gt; 0) sum1 = 0; if(sum2 &lt; 0) sum2 = 0; } return max(maxv, -minv); } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; ++i) scanf(&quot;%lf&quot;, a + i); double l = 0, r = 1e4; for(int i = 1; i &lt;= 100; ++i) { double ll = (2 * l + r) / 3; double rr = (l + 2 * r) / 3; if(check(ll) &lt; check(rr)) r = rr; else l = ll; } printf(&quot;%.12f\n&quot;, l); } return 0; }]]></content>
      <categories>
        <category>暴力</category>
        <category>搜索</category>
        <category>二/三分搜索</category>
      </categories>
      <tags>
        <tag>三分搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSU 1724 相等距离的和（线段树）]]></title>
    <url>%2F2016%2F04%2F29%2FCSU%201724%20%E7%9B%B8%E7%AD%89%E8%B7%9D%E7%A6%BB%E7%9A%84%E5%92%8C%EF%BC%88%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $给定1个空的升序集合A，集合元素下标从1开始，给出1个距离L，有三种操作：$$add x:向集合中加入一个元素，数据保证这个元素不在集合中$$del x:从集合中删除一个元素，数据保证这个元素存在集合中$$sum x:输出A_x+A_{x+L}+A_{x+2L}+……(0&lt; x\le L)的值$ 分析： $线段树，把下标搞成从0开始的简单一点$$每个节点维护cnt:=元素个数，sum[i]:=下标\%L=i的值的和$$向上合并时先拷贝左儿子的sum，右儿子的sum根据左儿子元素个数计算新余数累加到当然节点$$然后对于sum操作的答案就是sum[1][x-1]$ 代码： // // Created by TaoSama on 2016-04-28 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; typedef long long LL; int n, L; int cnt[N &lt;&lt; 2]; LL sum[N &lt;&lt; 2][5]; vector&lt;int&gt; xs; void build(int l, int r, int rt) { cnt[rt] = 0; for(int i = 0; i &lt; L; ++i) sum[rt][i] = 0; if(l == r) return; int m = l + r &gt;&gt; 1; build(l, m, rt &lt;&lt; 1); build(m + 1, r, rt &lt;&lt; 1 | 1); } void up(int rt) { int ls = rt &lt;&lt; 1, rs = ls | 1; cnt[rt] = cnt[ls] + cnt[rs]; int offset = cnt[ls]; for(int i = 0; i &lt; L; ++i) sum[rt][i] = sum[ls][i]; for(int i = 0; i &lt; L; ++i) sum[rt][(i + offset) % L] += sum[rs][i]; } void update(int o, int v, int l, int r, int rt) { if(l == r) { cnt[rt] = v; sum[rt][0] = v * xs[l - 1]; return; } int m = l + r &gt;&gt; 1; if(o &lt;= m) update(o, v, l, m, rt &lt;&lt; 1); else update(o, v, m + 1, r, rt &lt;&lt; 1 | 1); up(rt); } int op[N], a[N]; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); while(scanf(&quot;%d%d&quot;, &amp;n, &amp;L) == 2) { xs.clear(); for(int i = 1; i &lt;= n; ++i) { char cmd[10]; scanf(&quot;%s%d&quot;, cmd, a + i); if(*cmd == &#39;s&#39;) op[i] = 2; else { xs.push_back(a[i]); op[i] = *cmd == &#39;a&#39;; } } sort(xs.begin(), xs.end()); xs.resize(unique(xs.begin(), xs.end()) - xs.begin()); build(1, xs.size(), 1); static int kase = 0; printf(&quot;Case %d:\n&quot;, ++kase); for(int i = 1; i &lt;= n; ++i) { if(op[i] != 2) { int o = lower_bound(xs.begin(), xs.end(), a[i]) - xs.begin() + 1; update(o, op[i], 1, xs.size(), 1); } else printf(&quot;%lld\n&quot;, sum[1][a[i] - 1]); } } return 0; }]]></content>
      <categories>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5297 Y sequence (容斥、迭代)]]></title>
    <url>%2F2016%2F04%2F28%2FHDU%205297%20Y%20sequence%20(%E5%AE%B9%E6%96%A5%E3%80%81%E8%BF%AD%E4%BB%A3)%2F</url>
    <content type="text"><![CDATA[题意： $Y序列：不包含形如a^b(2\le b\le r, 2\le r\le 62)的数，并且Y(1)=2$$求给定r下的Y(n)，N\le 2\times 10^{18}$ 分析： $这个题类似于之前做过的容斥题$HDU 2204 Eddy’s爱好$这种题的关键是如何不重不漏的计数，显然4^2会在2^4重复计数，所以我们就记最小的那个$$接下来的关键就是容斥了，只容斥幂的素因子就好了，打好62内的素数表，注意选定的素因子不能超过r$$2\times 3\times 5\times 7&gt;62，所以容斥的素因子个数不会超过3，复杂度不是很高$$但是容斥的时候是可以的，但是不能超过62，因为4^{31}=2^{62}&gt;10^{18}$$还要指数不能是1啊，然后统计n以后有多少a^e的数，直接把n开e次方就好了$$据说会炸精度，上long double能存18位比较好$$二分确实会T，我试过了，然后只要迭代就可以了，每次就加缺少的个数。。学到了$$然后就是O(跑得过)了$ 代码： // // Created by TaoSama on 2016-04-27 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; typedef long long LL; LL n, r; vector&lt;int&gt; prime = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61 }; void dfs(int p, int e, int cnt, LL n, LL&amp; sum) { if(e &gt; 62) return; //4^31 -&gt; 2^62 if(p == prime.size()) { if(e == 1) return; LL cur = pow((long double)(n + 0.5), 1.0 / e) - 1; if(cnt &amp; 1) sum += cur; else sum -= cur; return; } dfs(p + 1, e, cnt, n, sum); if(prime[p] &lt;= r) dfs(p + 1, e * prime[p], cnt + 1, n, sum); } LL calc(LL n) { LL sum = 0; dfs(0, 1, 0, n, sum); return n - sum - 1; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%I64d%I64d&quot;, &amp;n, &amp;r); LL ans = n, cnt = calc(n); while(cnt &lt; n) { ans += n - cnt; cnt = calc(ans); } printf(&quot;%I64d\n&quot;, ans); } return 0; }]]></content>
      <categories>
        <category>数学</category>
        <category>容斥</category>
      </categories>
      <tags>
        <tag>容斥</tag>
        <tag>迭代</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5299 Circles Game (圆的扫描线、树上sg)]]></title>
    <url>%2F2016%2F04%2F27%2FHDU%205299%20Circles%20Game%20(%E5%9C%86%E7%9A%84%E6%89%AB%E6%8F%8F%E7%BA%BF%E3%80%81%E6%A0%91%E4%B8%8Asg)%2F</url>
    <content type="text"><![CDATA[题意： $平面上有N\le 5\times 10^4个两两不交的圆，现在有两个人轮流选取圆$$每选到一个圆就要把这个圆及其内部的所有圆都删去，最后不能操作的人输$$问谁有必胜策略$ 分析： $由于圆两两不交，如果根据圆的包含关系建个图（即每个圆向最近包含它的圆连边），可以得到一个森林$$问题转化为树上的SG博弈，时间复杂度O(nlogn)$ (以下转载自http://csgrandeur.com/hdu3511-prison-break-guan-yu-yuan-de-sao-miao-xian/ $建图需要用到圆的扫描线，具体看下图：$ $首先和传统扫描线的方法一样先把每个圆左右侧x坐标排个序作为事件，然后开始扫描$$圆就麻烦在没有像矩形那样可以离散化的规则上下界，便无法用预处理好的离散编号来构建线段树$$但是我们可以注意到对于扫描线扫描的过程中从上到下穿过各个圆的顺序是不会变的$$所以可以利用二叉树，把扫描线经过的(边)有序地插入（这里用set就很方便高效了）$$对于圆来说，这个边就是与上半圆交点纵坐标和与下半圆交点纵坐标$$即使扫描线位置的变化，插入时用来比较的代表(边)的纵坐标会变化$$但是扫描线穿过圆的顺序是不会变的，所以新的(边)依然会插入到正确的位置，其他(边)的相对位置不会改变$$这样set二叉树的结构不会变，就可以修改比较函数里的全局变量$$一共有4种情况，见代码吧$ 代码： // // Created by TaoSama on 2016-04-27 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; const double EPS = 1e-8; int sgn(double x) { return x &lt; -EPS ? -1 : x &gt; EPS; } double timeLine; struct Circle { double x, y, r; void read() { scanf(&quot;%lf%lf%lf&quot;, &amp;x, &amp;y, &amp;r); } double getY(int up) { return y + up * (sqrt(r * r - (x - timeLine) * (x - timeLine))); } } c[N]; typedef pair&lt;double, int&gt; Event; //x Event e[N &lt;&lt; 1]; struct Node { int id, d; bool operator&lt;(const Node&amp; r) const { double y1 = c[id].getY(d), y2 = c[r.id].getY(r.d); //y return sgn(y1 - y2) ? y1 &lt; y2 : d &lt; r.d; } }; int n, dep[N], p[N]; vector&lt;int&gt; G[N]; int dfs(int u) { int sg = 0; for(int v : G[u]) sg ^= dfs(v) + 1; return sg; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%d&quot;, &amp;n); for(int i = 0; i &lt;= n; ++i) G[i].clear(); for(int i = 1; i &lt;= n; ++i) { c[i].read(); e[2 * i - 1] = {c[i].x - c[i].r, i}; e[2 * i] = {c[i].x + c[i].r, -i}; } sort(e + 1, e + 2 * n + 1); set&lt;Node&gt; s; memset(dep, 0, sizeof dep); for(int i = 1; i &lt;= 2 * n; ++i) { timeLine = e[i].first; int id = e[i].second; if(id &lt; 0) { s.erase({ -id, 1}); s.erase({ -id, -1}); continue; } auto up = s.lower_bound({id, 1}), dw = up; if(up == s.end() || dw == s.begin()) { //无包含 p[id] = 0; dep[id] = 1; G[0].push_back(id); } else if((--dw)-&gt;id == up-&gt;id) { //直接被包含 p[id] = dw-&gt;id; dep[id] = dep[dw-&gt;id] + 1; G[dw-&gt;id].push_back(id); } else { if(dep[dw-&gt;id] == dep[up-&gt;id]) { //三圆是兄弟 p[id] = p[dw-&gt;id]; dep[id] = dep[dw-&gt;id]; G[p[dw-&gt;id]].push_back(id); } else { //两圆是兄弟，另一圆（深度小的）包两圆 if(dep[dw-&gt;id] &gt; dep[up-&gt;id]) swap(up, dw); p[id] = dw-&gt;id; dep[id] = dep[dw-&gt;id] + 1; G[dw-&gt;id].push_back(id); } } s.insert({id, 1}); s.insert({id, -1}); } // for(int i = 1; i &lt;= n; ++i) printf(&quot;%d-&gt;%d\n&quot;, p[i], i); puts(dfs(0) ? &quot;Alice&quot; : &quot;Bob&quot;); } return 0; }]]></content>
      <categories>
        <category>计算几何</category>
        <category>扫描线</category>
      </categories>
      <tags>
        <tag>扫描线</tag>
        <tag>树上sg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5296 Annoying problem（LCA）]]></title>
    <url>%2F2016%2F04%2F26%2FHDU%205296%20Annoying%20problem%EF%BC%88LCA%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N，Q\le 10^5，给定N个点的一棵树，边权C_i \le 100$$Q次操作一个集合，输出每次操作后使得集合中点两两连通的最小边权和：$$1 u:如果u不在集合中，则加入u$$2 u:如果u不在集合中，则删除u$ 分析： $手玩一下可以发现，其实就是加入点或者删除点到最近的一条链的边权和$$然后如何找呢，详细看这个博客吧，讲得很清楚：$传送门$根据dfs序来确定选择的链，如果集合中的dfs序比当前点u都大或者小，就取dfs最大点和最小点$$反之，就选大于它的dfs序的第一个点和小于它的最大的那个点$$点到链的最短距离：$ 代码： // // Created by TaoSama on 2016-04-26 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, q; struct Edge { int v, c; }; vector&lt;Edge&gt; G[N]; const int LOG = 17; int dfn[N], dfsNum; int dep[N], dis[N], p[LOG][N]; void dfs(int u, int fa) { dfn[u] = ++dfsNum; p[0][u] = fa; for(int i = 1; i &lt; LOG; ++i) p[i][u] = p[i - 1][p[i - 1][u]]; for(Edge&amp; e : G[u]) { int v = e.v, c = e.c; if(v == fa) continue; dep[v] = dep[u] + 1; dis[v] = dis[u] + c; dfs(v, u); } } int lca(int u, int v) { if(dep[u] &gt; dep[v]) swap(u, v); for(int i = 0; i &lt; LOG; ++i) if(dep[v] - dep[u] &gt;&gt; i &amp; 1) v = p[i][v]; if(u == v) return u; for(int i = LOG - 1; ~i; --i) if(p[i][u] != p[i][v]) u = p[i][u], v = p[i][v]; return p[0][u]; } //dis(u, x, y) = (dis(u, x) + dis(u, y) - dis(x, y)) / 2 //dis(u)+dis(x)-2dis(lca(u,x)) + dis(u)+dis(y)-2dis(lca(u,y)) //-dis(x)-dis(y)+2*dis(lca(x,y)) //vertex to chain int get(int u, int x, int y) { return dis[u] - dis[lca(u, x)] - dis[lca(u, y)] + dis[lca(x, y)]; } int gao(int u, set&lt;pair&lt;int, int&gt; &gt;&amp; s) { if(!s.size()) return 0; int x, y; auto iter = s.lower_bound({dfn[u], u}); if(iter == s.end() || iter == s.begin()) { x = s.begin()-&gt;second; y = s.rbegin()-&gt;second; } else { x = iter-&gt;second; --iter; y = iter-&gt;second; } return get(u, x, y); } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%d%d&quot;, &amp;n, &amp;q); for(int i = 1; i &lt;= n; ++i) G[i].clear(); for(int i = 1; i &lt; n; ++i) { int u, v, c; scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;c); G[u].push_back({v, c}); G[v].push_back({u, c}); } dfsNum = 0; dfs(1, 0); static int kase = 0; printf(&quot;Case #%d:\n&quot;, ++kase); set&lt;pair&lt;int, int&gt; &gt; s; int ans = 0; while(q--) { int op, u; scanf(&quot;%d%d&quot;, &amp;op, &amp;u); if(op == 1) { if(!s.count({dfn[u], u})) { ans += gao(u, s); s.insert({dfn[u], u}); } } else { if(s.count({dfn[u], u})) { s.erase({dfn[u], u}); ans -= gao(u, s); } } printf(&quot;%d\n&quot;, ans); } } return 0; }]]></content>
      <categories>
        <category>图论</category>
        <category>LCA</category>
      </categories>
      <tags>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZOJ 3946 Highway Project（最短路、MST）]]></title>
    <url>%2F2016%2F04%2F25%2FZOJ%203946%20Highway%20Project%EF%BC%88%E6%9C%80%E7%9F%AD%E8%B7%AF%E3%80%81MST%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N，M\le 10^5，N个点M条边的无向图，每条边有(D, C)属性，分别是通过时间和修建花费$$现要保证0点到所有点最短路的情况下，花费最少$$求最短路和以及花费$ 分析： $dijkstra的时候同时更新下到每个点的花费就好了$$其实就是prim的感觉，对算法要仔细理解辣$ 代码： // // Created by TaoSama on 2016-04-23 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;functional&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, m; struct Edge { int v, d, c; }; vector&lt;Edge&gt; G[N]; typedef long long LL; typedef pair&lt;LL, int&gt; P; LL f[N], g[N]; bool done[N]; pair&lt;LL, LL&gt; dijkstra() { priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt; &gt; q; q.push({0, 0}); memset(f, 0x3f, sizeof f); memset(g, 0x3f, sizeof g); memset(done, 0, sizeof done); f[0] = g[0] = 0; while(q.size()) { int u = q.top().second; q.pop(); if(done[u]) continue; done[u] = true; for(Edge&amp; e : G[u]) { int v = e.v, d = e.d, c = e.c; if(f[v] &gt; f[u] + d || f[v] == f[u] + d &amp;&amp; g[v] &gt; c) { f[v] = f[u] + d; g[v] = c; q.push({f[v], v}); } } } pair&lt;LL, LL&gt; ret = {0, 0}; for(int i = 0; i &lt; n; ++i) { ret.first += f[i]; ret.second += g[i]; } return ret; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 0; i &lt; n; ++i) G[i].clear(); for(int i = 1; i &lt;= m; ++i) { int u, v, d, c; scanf(&quot;%d%d%d%d&quot;, &amp;u, &amp;v, &amp;d, &amp;c); G[u].push_back({v, d, c}); G[v].push_back({u, d, c}); } auto ans = dijkstra(); printf(&quot;%lld %lld\n&quot;, ans.first, ans.second); } return 0; }]]></content>
      <categories>
        <category>图论</category>
        <category>最短路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ZOJ 3944 People Counting（暴力）]]></title>
    <url>%2F2016%2F04%2F25%2FZOJ%203944%20People%20Counting%EF%BC%88%E6%9A%B4%E5%8A%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N\times M的矩阵，N，M\le 100，现给定人的形状，人可能被部分遮挡$$问图里有几个人$ 分析： $以头为标志点来存个位置数组，然后碰到身体部分就统一到头$$一定是对他的身体部分进行标记$$（有可能身体是别人的。。怪自己写代码不鲁棒。。强行有trick）$ 代码： // // Created by TaoSama on 2016-04-23 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, m; char s[300][300]; const int OFF = 100; const char* peo = &quot;O/|\\()&quot;; int d[][2] = {0, 0, 1, -1, 1, 0, 1, 1, 2, -1, 2, 1}; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { memset(s, 0, sizeof s); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = OFF; i &lt; n + OFF; ++i) scanf(&quot;%s&quot;, s[i] + OFF); int ans = 0; for(int i = OFF; i &lt; n + OFF; ++i) { for(int j = OFF; j &lt; m + OFF; ++j) { if(s[i][j] == &#39;.&#39;) continue; ++ans; int idx = strchr(peo, s[i][j]) - peo; int x = i - d[idx][0], y = j - d[idx][1]; // printf(&quot;%d:= %d %d %d %d\n&quot;, idx, i - OFF, j - OFF, x - OFF, y - OFF); for(int k = 0; k &lt; 6; ++k) { int nx = x + d[k][0], ny = y + d[k][1]; if(s[nx][ny] == peo[k]) s[nx][ny] = &#39;.&#39;; } } } printf(&quot;%d\n&quot;, ans); } return 0; }]]></content>
      <categories>
        <category>暴力</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ZOJ 3939 The Lucky Week（打表）]]></title>
    <url>%2F2016%2F04%2F25%2FZOJ%203939%20The%20Lucky%20Week%EF%BC%88%E6%89%93%E8%A1%A8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $Lucky Week:某个星期一是这月的1、11、21号的话$$给定第1个Lucky Week的星期一，问第N\le 10^9的日期$ 分析： $写个函数来打表咯，发现400就是周期了，然后就很简单了$ 代码： // // Created by TaoSama on 2016-04-23 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int Y, M, D, n; bool isLeap(int y) { return y % 4 == 0 &amp;&amp; y % 100 || y % 400 == 0; } int mon[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; bool go(int&amp; y, int&amp; m, int&amp; d) { d += 7; int curMonth = m == 2 &amp;&amp; isLeap(y) ? mon[2] + 1 : mon[m]; if(d &gt; curMonth) ++m, d -= curMonth; if(m &gt; 12) ++y, m -= 12; return d == 1 || d == 11 || d == 21; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); Y = 2016, M = 4, D = 11; int y = 2016, m = 4, d = 11; int cnt = 1; while(true) { //2058 bool have = go(y, m, d); cnt += have; if(make_tuple(y, m, d) &gt;= make_tuple(Y + 400, M, D)) { cnt -= have; break; } } // printf(&quot;!!%d %d %d\n&quot;, y, m, d); // prln(cnt); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%d%d%d%d&quot;, &amp;Y, &amp;M, &amp;D, &amp;n); --n; Y += 400 * (n / 2058); n %= 2058; for(int i = 1; i &lt;= n;) if(go(Y, M, D)) ++i; printf(&quot;%d %d %d\n&quot;, Y, M, D); } return 0; }]]></content>
      <categories>
        <category>暴力</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ZOJ 3938 Defuse the Bomb（模拟）]]></title>
    <url>%2F2016%2F04%2F25%2FZOJ%203938%20Defuse%20the%20Bomb%EF%BC%88%E6%A8%A1%E6%8B%9F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $模拟Defuse the Bomb这个游戏的说明书啦$ 分析： $写个函数来判断是位置还是值咯，代码量少，而且不会写错$ 代码： // // Created by TaoSama on 2016-04-23 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; // void update(vector&lt;pair&lt;int, int&gt; &gt;&amp; ans, int* a, bool position, int value) { if(position) ans.push_back({value, a[value]}); else { for(int i = 1; i &lt;= 4; ++i) if(a[i] == value) ans.push_back({i, a[i]}); } } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { vector&lt;pair&lt;int, int&gt; &gt; ans; ans.push_back({0, 0}); //garbage value for(int i = 1; i &lt;= 5; ++i) { int d, a[5]; scanf(&quot;%d&quot;, &amp;d); for(int j = 1; j &lt;= 4; ++j) scanf(&quot;%d&quot;, a + j); if(i == 1) { if(d == 1) update(ans, a, 1, 2); else update(ans, a, 1, d); } else if(i == 2) { if(d == 1) update(ans, a, 0, 4); else if(d == 2 || d == 4) update(ans, a, 1, ans[1].first); else ans.push_back({1, a[1]}); } else if(i == 3) { if(d == 1) update(ans, a, 0, ans[2].second); else if(d == 2) update(ans, a, 0, ans[1].second); else if(d == 3) update(ans, a, 1, 3); else update(ans, a, 0, 4); } else if(i == 4) { if(d == 1) update(ans, a, 1, ans[1].first); else if(d == 2) update(ans, a, 1, 1); else update(ans, a, 1, ans[2].first); } else { if(d == 1) update(ans, a, 0, ans[1].second); else if(d == 2) update(ans, a, 0, ans[2].second); else if(d == 3) update(ans, a, 0, ans[4].second); else update(ans, a, 0, ans[3].second); } } for(int i = 1; i &lt;= 5; ++i) printf(&quot;%d %d\n&quot;, ans[i].first, ans[i].second); } return 0; }]]></content>
      <categories>
        <category>暴力</category>
        <category>小模拟</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[北京林业大学“计蒜客”杯程序设计竞赛]]></title>
    <url>%2F2016%2F04%2F25%2F%E5%8C%97%E4%BA%AC%E6%9E%97%E4%B8%9A%E5%A4%A7%E5%AD%A6%E2%80%9C%E8%AE%A1%E8%92%9C%E5%AE%A2%E2%80%9D%E6%9D%AF%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[zz选手只做了7个题$A、B、C、D、E、G、H$ A.喝酒题意： $N瓶酒，3个盖子或者4个空瓶可以换1瓶酒，问能喝几瓶$ 分析： $直接模拟一下，别忘记换的酒也有盖子和瓶子$ 代码： // // Created by TaoSama on 2016-04-24 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%d&quot;, &amp;n); int ans = n, a = n, b = n; while(a &gt;= 3 || b &gt;= 4) { int delta = a / 3 + b / 4; a = a % 3 + delta; b = b % 4 + delta; ans += delta; } printf(&quot;%d\n&quot;, ans); } return 0; } B.大钉骑马走江湖题意： $N*M的图，马走日，问到终点要几步$ 分析： $打个方向表和蹩马腿的表，然后直接bfs就好$ 代码： // // Created by TaoSama on 2016-04-24 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, m; char s[105][105]; int f[105][105]; int sx, sy, tx, ty; int d[][2] = {{1, 2}, {1, -2}, { -1, 2}, { -1, -2}, {2, 1}, {2, -1}, { -2, 1}, { -2, -1}}; int no[][2] = {0, 1, 0, -1, 0, 1, 0, -1, 1, 0, 1, 0, -1, 0, -1, 0}; int bfs() { queue&lt;int&gt; q; q.push(sx * m + sy); memset(f, -1, sizeof f); f[sx][sy] = 0; while(q.size()) { int u = q.front(); q.pop(); int x = u / m, y = u % m; for(int i = 0; i &lt; 8; ++i) { int nx = x + d[i][0], ny = y + d[i][1]; int kx = x + no[i][0], ky = y + no[i][1]; if(nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= m) continue; if(kx &lt; 0 || kx &gt;= n || ky &lt; 0 || ky &gt;= m) continue; if(s[nx][ny] == &#39;#&#39; || s[kx][ky] == &#39;#&#39;) continue; if(f[nx][ny] == -1) { f[nx][ny] = f[x][y] + 1; q.push(nx * m + ny); } } } return f[tx][ty]; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) == 2) { for(int i = 0; i &lt; n; ++i) { scanf(&quot;%s&quot;, s[i]); for(int j = 0; j &lt; m; ++j) { if(s[i][j] == &#39;s&#39;) sx = i, sy = j; if(s[i][j] == &#39;e&#39;) tx = i, ty = j; } } printf(&quot;%d\n&quot;, bfs()); } return 0; } C. Candy题意： $N\le10^5个人，每个人有个权，现开始发糖，至少1个$$要求权比旁边2个人大的，必须糖比他多$$问最少需要发多少糖$ 分析： $暴力，先给每个人发一个，然后正着补一遍，倒着补一遍就好了$ 代码： // // Created by TaoSama on 2016-04-24 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, a[N]; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); while(scanf(&quot;%d&quot;, &amp;n) == 1) { vector&lt;int&gt; v(n + 1, 1); for(int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, a + i); for(int i = 1; i &lt;= n; ++i) { if(i &gt; 1 &amp;&amp; a[i] &gt; a[i - 1]) v[i] = max(v[i], v[i - 1] + 1); if(i &lt; n &amp;&amp; a[i] &gt; a[i + 1]) v[i] = max(v[i], v[i + 1] + 1); } for(int i = n; i; --i) { if(i &gt; 1 &amp;&amp; a[i] &gt; a[i - 1]) v[i] = max(v[i], v[i - 1] + 1); if(i &lt; n &amp;&amp; a[i] &gt; a[i + 1]) v[i] = max(v[i], v[i + 1] + 1); } // for(int x : v) printf(&quot;%d &quot;, x); puts(&quot;&quot;); int ans = accumulate(v.begin() + 1, v.end(), 0); printf(&quot;%d\n&quot;, ans); } return 0; } D. A letter from Chensg题意： $求N个串的字典序最小的最长公共子串$$我很喜欢这封love letter啊$ 分析： $数据非常小，直接从长到短的暴力就好了，正解当然是sa啦$ 代码： // // Created by TaoSama on 2015-10-30 // Copyright (c) 2015 TaoSama. All rights reserved. // //#pragma comment(linker, &quot;/STACK:1024000000,1024000000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n; string s[15]; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); int t; cin &gt;&gt; t; while(t--) { cin &gt;&gt; n; for(int i = 1; i &lt;= n; ++i) cin &gt;&gt; s[i]; string ans; for(int sz = 60; sz &gt;= 3; --sz) { for(int st = 0; st + sz - 1 &lt; 60; ++st) { bool ok = true; string cur = s[1].substr(st, sz); for(int i = 2; i &lt;= n; ++i) { if(s[i].find(cur) == string::npos) { ok = false; break; } } if(!ok) continue; if(!ans.size() || cur &lt; ans) ans = cur; } if(ans.size()) break; } if(ans.size()) cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;; else cout &lt;&lt; &quot;No significant commonalities\n&quot;; } return 0; } E. delightful world题意： $猜1个01串，先现给出N\le 35次猜想，以及对应的猜对的个数\le 5$$问符合要求的串有几个$ 分析： $meet in middle辣，二进制枚举前半部分，然后哈希这个串的匹配情况成数字，因为猜对个数小嘛$$然后从另一半计数就好了$ 代码： // // Created by TaoSama on 2016-04-24 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; typedef long long LL; int n, m; char s[15][40]; int a[15]; LL ten[20]; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); ten[0] = 1; for(int i = 1; i &lt; 20; ++i) ten[i] = ten[i - 1] * 10; while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) == 2) { for(int i = 0; i &lt; m; ++i) scanf(&quot;%s%d&quot;, s[i], a + i); map&lt;LL, int&gt; mp; int half = n &gt;&gt; 1, lft = n - half; for(int i = 0; i &lt; 1 &lt;&lt; half; ++i) { bool ok = true; LL sum = 0; for(int j = 0; j &lt; m; ++j) { int cnt = 0; for(int k = 0; k &lt; half; ++k) if(s[j][k] - &#39;0&#39; == (i &gt;&gt; k &amp; 1)) ++cnt; if(cnt &lt;= a[j]) sum += cnt * ten[j]; else { ok = false; break; } } if(ok) ++mp[sum]; } LL ans = 0; for(int i = 0; i &lt; 1 &lt;&lt; lft; ++i) { bool ok = true; LL sum = 0; for(int j = 0; j &lt; m; ++j) { int cnt = 0; for(int k = 0; k &lt; lft; ++k) if(s[j][half + k] - &#39;0&#39; == (i &gt;&gt; k &amp; 1)) ++cnt; if(cnt &lt;= a[j]) sum += (a[j] - cnt) * ten[j]; else { ok = false; break; } } if(ok) ans += mp[sum]; } printf(&quot;%lld\n&quot;, ans); } return 0; } G. 易彰彪的一张表题意： $N个长度为M的字符串，如果他们首尾相连，问T串是否是合并串的子串$ 分析： $数据很小，直接合并到一起string::find$ 代码： // // Created by TaoSama on 2016-04-24 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, m; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); while(cin &gt;&gt; n &gt;&gt; m) { string s, t; for(int i = 1; i &lt;= n; ++i) { cin &gt;&gt; t; s += t; } for(int i = 0; i &lt; s.size(); ++i) s[i] = tolower(s[i]); cin &gt;&gt; t; for(int i = 0; i &lt; t.size(); ++i) t[i] = tolower(t[i]); if(s.find(t) != string::npos) cout &lt;&lt; &quot;YES\n&quot;; else cout &lt;&lt; &quot;NO\n&quot;; } return 0; } H. Ivan 的等待焦虑症发作了题意： $10个电梯上下楼，会在一些层停留，问到达规定层的时间（不算这层的停留时间）$ 分析： $数据很小直接一层一层走的模拟就好了，一开始写lower_bound没看数据写了半天。$ 代码： // // Created by TaoSama on 2016-04-24 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, p, wh[5]; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); while(scanf(&quot;%d%d&quot;, &amp;n, &amp;p) == 2) { for(int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, wh + i); bool s[5][50] = {}; for(int i = 1; i &lt;= n; ++i) { int cnt; scanf(&quot;%d&quot;, &amp;cnt); while(cnt--) { int x; scanf(&quot;%d&quot;, &amp;x); s[i][x] = 1; } } vector&lt;int&gt; ans(n + 1); for(int i = 1; i &lt;= n; ++i) { if(wh[i] == p) ans[i] = 0; else if(wh[i] &gt; p) { ans[i] = 5; for(int j = wh[i] - 1; j &gt; p; --j) { ans[i] += 5; if(s[i][j]) ans[i] += 15; } } else { ans[i] = 5; for(int j = wh[i] + 1; j &lt; p; ++j) { ans[i] += 5; if(s[i][j]) ans[i] += 15; } } } for(int i = 1; i &lt;= n; ++i) printf(&quot;%d%c&quot;, ans[i], &quot; \n&quot;[i == n]); } return 0; }]]></content>
      <categories>
        <category>套题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HDU 5289 Assignment（two pointers）]]></title>
    <url>%2F2016%2F04%2F12%2FHDU%205289%20Assignment%EF%BC%88two%20pointers%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N\le 10^5的序列，A_i\le 10^9$$求连续区间中任意2个数差值不超过k的区间个数$ 分析： $two pointers经典题辣，还是这种写法$$对于每个左端点，找到最右的右端点统计贡献数即可$$时间复杂度O(n)$ 代码： // // Created by TaoSama on 2016-04-12 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, a[N], k; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%d%d&quot;, &amp;n, &amp;k); for(int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, a + i); multiset&lt;int&gt; s; long long ans = 0; for(int l = 1, r = 1; l &lt;= n; ++l) { while(r &lt;= n) { if(s.size()) { if(a[r] - *s.begin() &gt;= k || *s.rbegin() - a[r] &gt;= k) break; } s.insert(a[r++]); } ans += r - l; s.erase(s.find(a[l])); } printf(&quot;%I64d\n&quot;, ans); } return 0; }]]></content>
      <categories>
        <category>技巧</category>
        <category>two pointers</category>
      </categories>
      <tags>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5288 OO’s Sequence（贡献）]]></title>
    <url>%2F2016%2F04%2F12%2FHDU%205288%20OO%E2%80%99s%20Sequence%EF%BC%88%E8%B4%A1%E7%8C%AE%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N\le 10^5的序列，A_i\le 10^4$$f(l, r):=区间中除自己以外都不是自己的约数的a_i的个数$$求\sum_{i=1}^{n}\sum_{j=i}^{n}f(i,j) mod (10^{9}+7)$ 分析： $对于a_i，对于它的任意约数x，假设离它最近的约数的位置是pre_{x}和nxt_x$$那么a_i能贡献的区间，显然左端点的选择是(pre_x, i]，右端点的选择是[i, nxt_i)$$那么对答案的贡献是(i-pre_x)\cdot(nxt_x-i)$$时间复杂度是O(n\sqrt{n})，约数级别是O(\sqrt{n})的$ 代码： // // Created by TaoSama on 2016-04-12 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, a[N]; int pre[N]; vector&lt;int&gt; divisors[N]; void gao() { for(int i = 1; i &lt;= 1e4; ++i) for(int j = i; j &lt;= 1e4; j += i) divisors[j].push_back(i); } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); gao(); while(scanf(&quot;%d&quot;, &amp;n) == 1) { for(int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, a + i); map&lt;int, int&gt; last; for(int i = 1; i &lt;= n; ++i) { pre[i] = 0; for(int d : divisors[a[i]]) pre[i] = max(pre[i], last[d]); last[a[i]] = i; } last.clear(); int ans = 0; for(int i = n; i; --i) { int nxt = n + 1; for(int d : divisors[a[i]]) if(last[d]) nxt = min(nxt, last[d]); ans += 1LL * (i - pre[i]) * (nxt - i) % MOD; if(ans &gt;= MOD) ans -= MOD; last[a[i]] = i; } printf(&quot;%d\n&quot;, ans); } return 0; }]]></content>
      <categories>
        <category>数学</category>
        <category>贡献</category>
      </categories>
      <tags>
        <tag>贡献</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Facebook Hacker Cup 2016 Round 1 C. Yachtzee（期望）]]></title>
    <url>%2F2016%2F04%2F12%2FFacebook%20Hacker%20Cup%202016%20Round%201%20C.%20Yachtzee%EF%BC%88%E6%9C%9F%E6%9C%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $给定初始金钱[A, B]均匀分布，A, B\le 10^9$$现在购买一个东西，分成N\le 10^5部分，每部分价值为C_i\le 10^9$$会不停的按顺序购买N个部分直到不能购买为止$$问剩余钱数的期望$ 分析： $根据期望的线性可加性，我们可以求[0, B]的期望减去[0, A]的期望$$然后对于[0, x]的期望，对C_i求个前缀和，对于每个区间[C_{i-1}, C_i]$$L_i=C_i-C_{i-1}，如果完全覆盖那么它的贡献是L_i\cdot\frac{L_i}{2}$$周期cycle = x/C_n，剩下的left=x\%C_n，计算方式相同$$那么总贡献E=cycle\cdot L_i\cdot\frac{L_i}{2}+E_{left}，期望E’=\frac{E_B-E_A}{B-A}$ 代码： // // Created by TaoSama on 2016-01-17 // Copyright (c) 2015 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:1024000000,1024000000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, A, B; typedef long long LL; LL a[N]; LL calc(int x) { LL ret = 0; LL cycle = x / a[n], left = x % a[n]; for(int i = 1; i &lt;= n; ++i) ret += (a[i] - a[i - 1]) * (a[i] - a[i - 1]); ret *= cycle; int k = lower_bound(a + 1, a + n + 1, left) - a; for(int i = 1; i &lt;= k; ++i) ret += (min(a[i], left) - a[i - 1]) * (min(a[i], left) - a[i - 1]); return ret; } int main() { #ifdef LOCAL freopen(&quot;yachtzee.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;yachtzee_out.txt&quot;, &quot;w&quot;, stdout); #endif ios_base::sync_with_stdio(0); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;A, &amp;B); for(int i = 1; i &lt;= n; ++i) { scanf(&quot;%lld&quot;, a + i); a[i] += a[i - 1]; } double ans = 1.0 * (calc(B) - calc(A)) / 2 / (B - A); static int kase = 0; printf(&quot;Case #%d: %.9f\n&quot;, ++kase, ans); } return 0; }]]></content>
      <categories>
        <category>数学</category>
        <category>概率/期望</category>
      </categories>
      <tags>
        <tag>期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5157 Harry and magic string（回文树）]]></title>
    <url>%2F2016%2F04%2F11%2FHDU%205157%20Harry%20and%20magic%20string%EF%BC%88%E5%9B%9E%E6%96%87%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N\le 10^5的字符串S，设T_1、T_2为S的2个回文子串，并且T_1和T_2不相交$$求(T_1, T_2)的对数有多少$ 分析： $回文树预处理$$pre[i]:=以i字符结尾的回文串的个数，suf[i]:=以i字符开头的回文串的个数$$对中一个求前缀和，比如是suf[i]，然后答案ans=\sum_{i=1}^{n-1}pre[i]\times sum[i+1]$ 代码： // // Created by TaoSama on 2016-04-09 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; struct PalindromicTree { static const int M = 1e5 + 10, S = 26; int n, sz, last; int nxt[M][S], fail[M], len[M], s[M]; int cnt[M], dif[M]; int newNode(int l) { len[sz] = l; cnt[sz] = dif[sz] = 0; memset(nxt[sz], 0, sizeof nxt[sz]); return sz++; } void init() { sz = last = 0; newNode(0); newNode(-1); s[n = 0] = -1; // 无关字符减少特判 fail[0] = 1; } int getFail(int u) { while(s[n - len[u] - 1] != s[n]) u = fail[u]; return u; } int add(int c) { s[++n] = c; int u = getFail(last); // 找到这个回文串的匹配位置 int&amp; v = nxt[u][c]; if(!v) { int cur = newNode(len[u] + 2); fail[cur] = nxt[getFail(fail[u])][c]; v = cur; cnt[v] = cnt[fail[v]] + 1; } ++dif[v]; last = v; return cnt[v]; } void count() { //父亲累加儿子，如果 fail[v]=u ，则 u 一定是 v 的子回文串 for(int i = sz - 1; ~i; --i) dif[fail[i]] += dif[i]; } } pt; char s[N]; long long suf[N]; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); while(scanf(&quot;%s&quot;, s + 1) == 1) { int n = strlen(s + 1); pt.init(); suf[n + 1] = 0; for(int i = n; i; --i) { int cnt = pt.add(s[i] - &#39;a&#39;); suf[i] = suf[i + 1] + cnt; } pt.init(); long long ans = 0; for(int i = 1; i &lt;= n; ++i) ans += pt.add(s[i] - &#39;a&#39;) * suf[i + 1]; printf(&quot;%I64d\n&quot;, ans); } return 0; }]]></content>
      <categories>
        <category>字符串</category>
        <category>Manacher/回文树</category>
      </categories>
      <tags>
        <tag>回文树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5658 CA Loves Palindromic（Manacher | 回文树）]]></title>
    <url>%2F2016%2F04%2F11%2FHDU%205658%20CA%20Loves%20Palindromic%EF%BC%88Manacher%20%20%E5%9B%9E%E6%96%87%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N\le 10^3的字符串，Q\le 10^5次询问$$每次询问[l, r]区间本质不同的回文子串有几个，即不完全相同的回文子串$ 分析： $Manacher做法，就离线询问，然后判断回文，哈希判重$$回文树就更暴力了，直接预处理ans[l][r]$$回文树的学习直接上鸟神博客$，Palindromic Tree——回文树【处理一类回文串问题的强力工具】 Manacher代码： // // Created by TaoSama on 2016-04-08 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e3 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; struct BIT { int n, b[N]; void init(int _n) { n = _n; memset(b, 0, sizeof b); } void add(int i, int v) { for(; i; i -= i &amp; -i) b[i] += v; } int sum(int i) { int ret = 0; for(; i &lt;= n; i += i &amp; -i) ret += b[i]; return ret; } } bit; struct Manacher { char s[N &lt;&lt; 1]; int n, p[N &lt;&lt; 1]; void init(char* a) { s[0] = &#39;@&#39;; s[1] = &#39;#&#39;; n = 2; for(int i = 1; a[i]; ++i) s[n++] = a[i], s[n++] = &#39;#&#39;; s[n] = 0; } int gao() { int mx = 0, id, ret = 0; for(int i = 1; i &lt; n; ++i) { p[i] = mx &gt; i ? min(mx - i, p[2 * id - i]) : 1; while(s[i - p[i]] == s[i + p[i]]) ++p[i]; if(mx &lt; i + p[i]) mx = i + p[i], id = i; ret = max(ret, p[i] - 1); } return ret; } bool ok(int l, int r) { l &lt;&lt;= 1; r &lt;&lt;= 1; int k = l + r &gt;&gt; 1; return k + p[k] - 1 &gt;= r; } } manacher; typedef unsigned long long ULL; const ULL seed[2] = {MOD, MOD + 2}; struct Hash { typedef pair&lt;ULL, ULL&gt; Type; ULL power[2][N], h[2][N]; void init(char* a) { for(int i = 0; i &lt; 2; ++i) { power[i][0] = 1; h[i][0] = 0; for(int j = 1; a[j]; ++j) { power[i][j] = power[i][j - 1] * seed[i]; h[i][j] = h[i][j - 1] * seed[i] + a[j]; } } } Type get(int l, int r) { // [l, r] Type ret; ret.first = h[0][r] - h[0][l - 1] * power[0][r - l + 1]; ret.second = h[1][r] - h[1][l - 1] * power[1][r - l + 1]; return ret; } } hsh; int n, q; const int Q = 1e5 + 10; int ans[Q]; char a[N]; vector&lt;pair&lt;int, int&gt; &gt; qs[N]; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%s&quot;, a + 1); n = strlen(a + 1); hsh.init(a); manacher.init(a); manacher.gao(); scanf(&quot;%d&quot;, &amp;q); for(int i = 1; i &lt;= n; ++i) qs[i].clear(); for(int i = 1; i &lt;= q; ++i) { int l, r; scanf(&quot;%d%d&quot;, &amp;l, &amp;r); qs[r].push_back({l, i}); } bit.init(n); map&lt;Hash::Type, int&gt; mp; for(int i = 1; i &lt;= n; ++i) { for(int j = 1; j &lt;= i; ++j) { if(!manacher.ok(j, i)) continue; //not palindromic Hash::Type h = hsh.get(j, i); if(mp.count(h)) bit.add(mp[h], -1); bit.add(j, 1); mp[h] = j; } for(auto&amp; q : qs[i]) ans[q.second] = bit.sum(q.first); } for(int i = 1; i &lt;= q; ++i) printf(&quot;%d\n&quot;, ans[i]); } return 0; } 回文树代码： // // Created by TaoSama on 2016-04-08 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e3 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; // last:= 指向添加一个字符后形成的最长回文串的节点 // s[i]:= 第 i 次添加的字符 n:= s 数组时针 // fail[i]:= i 失配后跳转到的 i 表示的最长回文串的最长真后缀回文串的节点 // cnt[i]:= 以 i 表示的最长回文串的右端点为右端点的回文串个数 // dif[i]:= i 表示的本质不同的回文串个数 （需要重新统计） struct PalindromicTree { static const int M = 1e3 + 10, S = 26; int n, sz, last; int nxt[M][S], fail[M], len[M], s[M]; int cnt[M], dif[M]; int newNode(int l) { len[sz] = l; cnt[sz] = dif[sz] = 0; memset(nxt[sz], 0, sizeof nxt[sz]); return sz++; } void init() { sz = last = 0; newNode(0); newNode(-1); s[n = 0] = -1; // 无关字符减少特判 fail[0] = 1; } int getFail(int u) { while(s[n - len[u] - 1] != s[n]) u = fail[u]; return u; } void add(int c) { s[++n] = c; int u = getFail(last); // 找到这个回文串的匹配位置 int&amp; v = nxt[u][c]; if(!v) { int cur = newNode(len[u] + 2); fail[cur] = nxt[getFail(fail[u])][c]; v = cur; cnt[v] = cnt[fail[v]] + 1; } ++dif[v]; last = v; } void count() { //父亲累加儿子，如果 fail[v]=u ，则 u 一定是 v 的子回文串 for(int i = sz - 1; ~i; --i) dif[fail[i]] += dif[i]; } } pt; int n, q; char a[N]; int ans[N][N]; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%s&quot;, a + 1); n = strlen(a + 1); for(int i = 1; i &lt;= n; ++i) { pt.init(); for(int j = i; j &lt;= n; ++j) { pt.add(a[j] - &#39;a&#39;); ans[i][j] = pt.sz - 2; } } scanf(&quot;%d&quot;, &amp;q); while(q--) { int l, r; scanf(&quot;%d%d&quot;, &amp;l, &amp;r); printf(&quot;%d\n&quot;, ans[l][r]); } } return 0; }]]></content>
      <categories>
        <category>字符串</category>
        <category>Manacher/回文树</category>
      </categories>
      <tags>
        <tag>回文树</tag>
        <tag>Manacher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SOJ 4484 静态规划（dp）]]></title>
    <url>%2F2016%2F04%2F11%2FSOJ%204484%20%E9%9D%99%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88dp%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N\le 10^5个沙堆，|A_i|\le10^9，可以任意加减每个沙堆的高度$$现要使得修改后的沙堆高度A_i’\le A_{i+1}’，i\in [1, N)$$求最小修改的高度和$ 分析： $如果后一个元素比前一个小，那么最少改变的情况就是让他和前一个元素相等$$如果比前一个元素大或者相等，则不需做出改变$$仔细想想就可以发现其实最后的序列就是由原始数组的元素组成的$$那么我们先对原始数组排个序$$f[i][j]=1\sim i，且第i个元素更改为排序后的第j个元素的最小修改高度和$$然后暴力转移是O(n^3)，前缀和优化一下就O(n^2)了，再滚动数组一波$ 代码： // // Created by TaoSama on 2016-04-10 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 3e3 + 10, INF = 0x3f3f3f3f, MOD = 19970303; int n, a[N], s[N]; long long f[2][N]; void add(int&amp; x, int y) { if((x += y) &gt;= MOD) x -= MOD; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); while(scanf(&quot;%d&quot;, &amp;n) == 1) { for(int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, a + i), s[i] = a[i]; sort(s + 1, s + 1 + n); int p = 0; memset(f[p], 0, sizeof f[p]); for(int i = 1; i &lt;= n; ++i) { memset(f[!p], 0, sizeof f[!p]); for(int j = 1; j &lt;= n; ++j) f[!p][j] = f[p][j] + abs(a[i] - s[j]); for(int j = 2; j &lt;= n; ++j) f[!p][j] = min(f[!p][j], f[!p][j - 1]); p = !p; } printf(&quot;%lld\n&quot;, f[p][n] % MOD); } return 0; }]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4647 Another Graph Game（贪心、边权映射到点权）]]></title>
    <url>%2F2016%2F04%2F11%2FHDU%204647%20Another%20Graph%20Game%EF%BC%88%E8%B4%AA%E5%BF%83%E3%80%81%E8%BE%B9%E6%9D%83%E6%98%A0%E5%B0%84%E5%88%B0%E7%82%B9%E6%9D%83%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N，M\le 10^5，N个点M条边，点权W_i、边权C_i \le 10^9 $$2个人玩游戏轮流选点得到权值，选过的不能再选$$规定如果一条边的2个端点都被同一个人选到，那么它获得边权$$假设2个人采取最优策略，输出先手得分-后手得分$ 分析： $考虑没有边的情况，那么显然2个人从大到小选$$有边，那么就把边权均分到2个点上，如果同1个人选到刚好就加起来了，不同人就抵消了$$符合题意，避免小数，把权加倍即可$$时间复杂度O(nlogn)$ 代码： // // Created by TaoSama on 2016-03-11 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:1024000000,1024000000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, m; long long a[N]; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) == 2) { for(int i = 1; i &lt;= n; ++i) scanf(&quot;%I64d&quot;, a + i), a[i] &lt;&lt;= 1; for(int i = 1; i &lt;= m; ++i) { int u, v, w; scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w); a[u] += w; a[v] += w; } sort(a + 1, a + 1 + n); long long ans = 0; for(int i = n; i; --i) if(i &amp; 1) ans -= a[i]; else ans += a[i]; printf(&quot;%I64d\n&quot;, ans &gt;&gt; 1); } return 0; }]]></content>
      <categories>
        <category>思维</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SOJ 4482 忽悠大神（MST、点权映射到边权）]]></title>
    <url>%2F2016%2F04%2F11%2FSOJ%204482%20%E5%BF%BD%E6%82%A0%E5%A4%A7%E7%A5%9E%EF%BC%88MST%E3%80%81%E7%82%B9%E6%9D%83%E6%98%A0%E5%B0%84%E5%88%B0%E8%BE%B9%E6%9D%83%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N，M\le 10^5，N个点M条边无向图，点权W_i，边权C_i\le 1000$$现要保证图联通的情况下删除最多的边$$在此基础上，使得从某一起点出发，经过所有的点回到原点的权和最小$$输出这个权和$ 分析： $我们发现因为要来回，所以边权其实是\times 2的，选了边其实2个端点必定会走$$所以其实可以把点权映射到点上，即对于(u, v)新的边权为w_u+w_v+2\times c_{uv}$$然后求一遍MST就好了，当然起点要再算一次，选择最小权的那个起点就好了$$时间复杂度O(n+mlogm)$ 代码： // // Created by TaoSama on 2016-04-09 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, m; struct Edge { int u, v, c; bool operator&lt;(const Edge&amp; e) const { return c &lt; e.c; } } edge[N]; struct DSU { int n, p[N]; void init(int _n) { n = _n; for(int i = 1; i &lt;= n; ++i) p[i] = i; } int find(int x) { return p[x] = p[x] == x ? x : find(p[x]); } bool unite(int x, int y) { x = find(x), y = find(y); if(x == y) return false; p[x] = y; return true; } } dsu; int w[N]; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) == 2) { int ans = INF; for(int i = 1; i &lt;= n; ++i) { scanf(&quot;%d&quot;, w + i); ans = min(ans, w[i]); } for(int i = 1; i &lt;= m; ++i) { int u, v, c; scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;c); edge[i] = (Edge) {u, v, 2 * c + w[u] + w[v]}; } sort(edge + 1, edge + 1 + m); dsu.init(n); int cnt = 0; for(int i = 1; i &lt;= m; ++i) { int u = edge[i].u, v = edge[i].v; if(dsu.unite(u, v)) { ans += edge[i].c; if(++cnt == n - 1) break; } } printf(&quot;%d\n&quot;, ans); } return 0; }]]></content>
      <categories>
        <category>图论</category>
        <category>最小生成树</category>
      </categories>
      <tags>
        <tag>MST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SOJ 4481 学院杯辩论赛（概率dp）]]></title>
    <url>%2F2016%2F04%2F11%2FSOJ%204481%20%E5%AD%A6%E9%99%A2%E6%9D%AF%E8%BE%A9%E8%AE%BA%E8%B5%9B%EF%BC%88%E6%A6%82%E7%8E%87dp%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N\le 7，给定2^N个队伍进行N轮比赛$$每轮比赛将所遇剩余队伍编号排序，第一小的队伍和第二小的比，第三小的和第四小的比，以此类推$$N轮比赛后剩余一支队伍，问哪只队伍获胜概率最大，输出编号$ 分析： $概率dp，f[i][j]:=队伍j活到第i轮比赛的概率$$我们发现转移其实类似于线段树，自底向上转移，从第0轮开始$$对于上一个区间，显然它的左儿子的队友都是右儿子，反之同理$$时间复杂度O(n\times 2^n)$ 代码： // // Created by TaoSama on 2016-04-09 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n; double a[1 &lt;&lt; 7][1 &lt;&lt; 7], f[7][1 &lt;&lt; 7]; void dfs(int n, int l, int r) { // [l, r] if(l == r) { f[n][l] = 1; return; } int m = l + r &gt;&gt; 1; dfs(n - 1, l, m); dfs(n - 1, m + 1, r); for(int i = l; i &lt;= r; ++i) f[n][i] = 0; for(int i = l; i &lt;= m; ++i) for(int j = m + 1; j &lt;= r; ++j) f[n][i] += f[n - 1][i] * f[n - 1][j] * a[i][j]; for(int i = m + 1; i &lt;= r; ++i) for(int j = l; j &lt;= m; ++j) f[n][i] += f[n - 1][i] * f[n - 1][j] * a[i][j]; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); while(scanf(&quot;%d&quot;, &amp;n) == 1) { for(int i = 0; i &lt; 1 &lt;&lt; n; ++i) for(int j = 0; j &lt; 1 &lt;&lt; n; ++j) scanf(&quot;%lf&quot;, a[i] + j); dfs(n, 0, (1 &lt;&lt; n) - 1); pair&lt;double, int&gt; ans = make_pair(-1, -INF); for(int i = 0; i &lt; 1 &lt;&lt; n; ++i) ans = max(ans, make_pair(f[n][i], -i)); printf(&quot;%d\n&quot;, -ans.second + 1); } return 0; }]]></content>
      <categories>
        <category>动态规划</category>
        <category>概率/期望dp</category>
      </categories>
      <tags>
        <tag>概率dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SOJ 4479 Easy Problem III（区间贪心）]]></title>
    <url>%2F2016%2F04%2F11%2FSOJ%204479%20Easy%20Problem%20III%EF%BC%88%E5%8C%BA%E9%97%B4%E8%B4%AA%E5%BF%83%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $给定一条无限长的直线，给定N\le 10^5条线段[s, t]覆盖这条直线$$问覆盖的长度（重复覆盖只算一次）$ 分析： $经典区间贪心问题，左端点排序，然后维护最右端点就好了$$累加答案的时候，记得判断大小关系。。。$$时间复杂度O(nlogn)$ 代码： // // Created by TaoSama on 2016-04-09 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n; pair&lt;int, int&gt; a[N]; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; ++i) scanf(&quot;%d%d&quot;, &amp;a[i].first, &amp;a[i].second); sort(a + 1, a + 1 + n); int ans = a[1].second - a[1].first, r = a[1].second; for(int i = 2; i &lt;= n; ++i) { if(a[i].first &gt; r) ans += a[i].second - a[i].first; else if(a[i].second &gt; r) ans += a[i].second - r; r = max(r, a[i].second); } printf(&quot;%d\n&quot;, ans); } return 0; }]]></content>
      <categories>
        <category>思维</category>
        <category>贪心</category>
        <category>区间贪心</category>
      </categories>
      <tags>
        <tag>区间贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SOJ 4478 Easy Problem II（栈）]]></title>
    <url>%2F2016%2F04%2F11%2FSOJ%204478%20Easy%20Problem%20II%EF%BC%88%E6%A0%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N\le 10^5，1-N的数按顺序入栈，现给定出栈序列，问是否合法$ 分析： $栈模拟一下就好了$$时间复杂度O(n)$ 代码： // // Created by TaoSama on 2016-04-09 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; #include &lt;stack&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%d&quot;, &amp;n); stack&lt;int&gt; s; int cnt = 0, ok = 1; for(int i = 1; i &lt;= n; ++i) { int x; scanf(&quot;%d&quot;, &amp;x); while(s.empty() || x != s.top()) { if(cnt == n) { ok = false; break; } s.push(++cnt); } s.pop(); } puts(ok ? &quot;Yes&quot; : &quot;No&quot;); } return 0; }]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ZOJ 3933 Team Formation（KM）]]></title>
    <url>%2F2016%2F04%2F10%2FZOJ%203933%20Team%20Formation%EF%BC%88KM%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N\le 500个人，分为X组和Y组，每个人可能是男或者女$$X和Y要匹配，现要每个人都有厌恶的list，不和list上的人匹配$$求最大匹配数，以及满足条件下的女生总和最多的方案，输出任意方案$ 分析： $赤果果的最大权匹配模型，500个点费用流显然是跑不过去的(反正我的不行)$$对于这种求妹子数的也是很经典的模型了$$然后能连的边权是1，如果有妹子就边权增加$ 妹子数*D$，D是个比最大匹配数大的数$$跑出来妹子数就是最大权/D，打印方案即可$$连边的时候X部还是Y部要注意，打印方案的时候也要注意$$时间复杂度O(n^3)$ 代码： // // Created by TaoSama on 2016-04-10 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 500 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int g[N][N], slack[N]; int lx[N], ly[N]; int match[N], n; bool vx[N], vy[N]; bool dfs(int u) { vx[u] = 1; for(int i = 1; i &lt;= n; i++) { if(!vy[i]) { int t = lx[u] + ly[i] - g[u][i]; if(t == 0) { vy[i] = 1; if(match[i] == -1 || dfs(match[i])) { match[i] = u; return 1; } } else slack[i] = min(slack[i], t); } } return 0; } void KM() { memset(match, -1, sizeof(match)); memset(ly, 0, sizeof(ly)); for(int i = 1; i &lt;= n; i++) { lx[i] = -INF; for(int j = 1; j &lt;= n; j++) lx[i] = max(lx[i], g[i][j]); } for(int i = 1; i &lt;= n; i++) { for(int j = 1; j &lt;= n; j++) slack[j] = INF; while(1) { memset(vx, 0, sizeof(vx)); memset(vy, 0, sizeof(vy)); if(dfs(i)) break; int d = INF; for(int j = 1; j &lt;= n; j++) if(!vy[j]) d = min(d, slack[j]); for(int j = 1; j &lt;= n; j++) if(vx[j]) lx[j] -= d; for(int j = 1; j &lt;= n; j++) if(vy[j]) ly[j] += d; } } } const int D = 1e6; bool lft[N], girl[N]; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%d&quot;, &amp;n); char buf[N]; scanf(&quot;%s&quot;, buf + 1); for(int i = 1; i &lt;= n; ++i) lft[i] = buf[i] == &#39;0&#39;; scanf(&quot;%s&quot;, buf + 1); for(int i = 1; i &lt;= n; ++i) girl[i] = buf[i] == &#39;0&#39;; memset(g, 0, sizeof g); for(int i = 1; i &lt;= n; ++i) { if(!lft[i]) continue; for(int j = 1; j &lt;= n; ++j) { if(lft[j]) continue; g[i][j] = (girl[i] + girl[j]) * D + 1; } } for(int i = 1; i &lt;= n; ++i) { int cnt; scanf(&quot;%d&quot;, &amp;cnt); while(cnt--) { int x; scanf(&quot;%d&quot;, &amp;x); if(lft[i] &amp;&amp; !lft[x]) g[i][x] = 0; } } KM(); int matches = 0, ans = 0; vector&lt;pair&lt;int, int&gt; &gt; path; for(int i = 1; i &lt;= n; ++i) { if(match[i] == -1 || !g[match[i]][i]) continue; ++matches; ans += g[match[i]][i]; path.push_back(make_pair(match[i], i)); } printf(&quot;%d %d\n&quot;, matches, ans / D); for(int i = 0; i &lt; path.size(); ++i) printf(&quot;%d %d\n&quot;, path[i].first, path[i].second); } return 0; }]]></content>
      <categories>
        <category>图论</category>
        <category>二分图</category>
      </categories>
      <tags>
        <tag>最大权匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZOJ 3932 Handshakes（逆向思维）]]></title>
    <url>%2F2016%2F04%2F10%2FZOJ%203932%20Handshakes%EF%BC%88%E9%80%86%E5%90%91%E6%80%9D%E7%BB%B4%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $有一间教室，N\le 10^5依次来到这间教室，每个人来的时候要跟里面的所有人握手$$现在给定每个人进来那一次握了多少次手$$求每个人最多握多少次手，输出那个最大值$ 分析： $显然最大的情况就是后面的人全是它的朋友$$如果后面某个人握手了，就当作是前面的人也握了$$所以倒着搞一遍就好了$$时间复杂度O(n)$ 代码： // // Created by TaoSama on 2016-04-10 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, a[N]; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, a + i); int ans = 0, cnt = 0; for(int i = n; i; --i) { ans = max(ans, a[i] + cnt); cnt += a[i] &gt; 0; } printf(&quot;%d\n&quot;, ans); } return 0; }]]></content>
      <categories>
        <category>思维</category>
        <category>逆向思维</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ZOJ 3930 Dice Notation（模拟）]]></title>
    <url>%2F2016%2F04%2F10%2FZOJ%203930%20Dice%20Notation%EF%BC%88%E6%A8%A1%E6%8B%9F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $给定规则让你展开式子，就读3个小圆点就可以了$$1.ndX\Rightarrow(\underbrace{[dX] + \cdots + [dX])}_n，dX\Rightarrow [dX]，+号左右各1个空格$$2.给+-*/的左右各添加1个空格$$3.最后添加，$”$ = [Result]$” 分析： $有个坑，就是数字别解析，ndX的X也别解析$$然后就能过了，赛上用BigInt逗比了，还是太懒，估计是把前导0给我去了$ 代码： // // Created by TaoSama on 2016-04-10 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, idx; char s[N], tmp[N]; char op[] = &quot;+-*/&quot;; bool isoperator(char c) { return c &amp;&amp; strchr(op, c); } void display(int n, char* tmp) { if(n &gt; 1) putchar(&#39;(&#39;); printf(&quot;[d%s]&quot;, tmp); for(int i = 1; i &lt; n; ++i) printf(&quot; + [d%s]&quot;, tmp); if(n &gt; 1) putchar(&#39;)&#39;); } void dfs() { while(s[idx] &amp;&amp; s[idx] != &#39;)&#39;) { if(s[idx] == &#39;(&#39;) { putchar(&#39;(&#39;); ++idx; dfs(); putchar(&#39;)&#39;); ++idx; } if(isdigit(s[idx])) { int l = 0, r = 0; while(isdigit(s[idx])) tmp[l++] = s[idx++]; tmp[l] = 0; if(s[idx] != &#39;d&#39;) { printf(&quot;%s&quot;, tmp); //just digit continue; } l = 0; for(int i = 0; tmp[i]; ++i) l = l * 10 + tmp[i] - &#39;0&#39;; ++idx; //jump d while(isdigit(s[idx])) tmp[r++] = s[idx++]; tmp[r] = 0; display(l, tmp); } if(isoperator(s[idx])) printf(&quot; %c &quot;, s[idx++]); } } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); int t; scanf(&quot;%d &quot;, &amp;t); while(t--) { char buf[2005]; gets(buf); n = 0; for(int i = 0; buf[i]; ++i) { if(isspace(buf[i])) continue; if(buf[i] == &#39;d&#39; &amp;&amp; (!s[n] || s[n] &amp;&amp; !isdigit(s[n]))) s[++n] = &#39;1&#39;; s[++n] = buf[i]; } s[n + 1] = 0; idx = 1; dfs(); printf(&quot; = [Result]\n&quot;); //puts(&quot;&quot;); } return 0; }]]></content>
      <categories>
        <category>暴力</category>
        <category>小模拟</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZOJ 3929 Deque and Balls（数学、BIT）]]></title>
    <url>%2F2016%2F04%2F10%2FZOJ%203929%20Deque%20and%20Balls%EF%BC%88%E6%95%B0%E5%AD%A6%E3%80%81BIT%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N\le 10^5的序列，A_i\le N，将这个序列按顺序装入一个deque$$每次装在deque的首尾概率均等，问所有序列相邻逆序个数的期望$$相邻逆序个数：=\sum_{i=1}^{N-1} A_i &gt; A_{i+1}$ 分析： $首先对于deque我们可以发现，任意1个中轴左右的数的下标都是递增的$$假设a_1为中轴，那么a_2,\cdots,a_n只能按顺序放右或者不放右（即放左）$$那么总的合法序列的个数即为2^{n-1}$$考虑任意一个逆序对答案的贡献：$$WLOG，(a_i, a_j), j &gt; i，显然只能放在放在右边，由前面的性质可知a_i和a_j间是没有数的$$a_i对a_j的贡献，E_{ij}=2^{i-2}\cdot2^{n-j}，a_1已经放了，左边还有i-2个，右边n-j个$$我们用BIT来维护a_i对a_j的贡献，显然只统计a_i&gt;a_j的$$同理，(a_j, a_i), j&gt;i，显然只能放在左边，贡献同理，E_{ij}=2^{i-2}\cdot2^{n-j}$$同理，只统计a_j &lt; a_i的$$注意答案是乘2^i MOD 10^9+7哦，所以约分后还要乘2$ 代码： // // Created by TaoSama on 2016-04-10 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; void add(int&amp; x, int y) { if((x += y) &gt;= MOD) x -= MOD; } struct BIT { int n, dir, b[N]; void init(int _n, int _dir) { n = _n; dir = _dir; memset(b, 0, sizeof b); } void update(int i, int v) { for(; i &amp;&amp; i &lt;= n; i += dir * (i &amp; -i)) add(b[i], v); } int query(int i) { int ret = 0; for(; i &amp;&amp; i &lt;= n; i -= dir * (i &amp; -i)) add(ret, b[i]); return ret; } } small, large; int n, a[N]; int two[N] = {1}; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); for(int i = 1; i &lt; N; ++i) add(two[i], two[i - 1] * 2); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, a + i); small.init(n, 1); large.init(n, -1); int ans = 0; small.update(a[1], 1); //中轴 large.update(a[1], 1); for(int i = 2; i &lt;= n; ++i) { add(ans, 1LL * two[n - i] * large.query(a[i] + 1) % MOD); //放右边 add(ans, 1LL * two[n - i] * small.query(a[i] - 1) % MOD); //放左边 small.update(a[i], two[i - 2]); //except 1 large.update(a[i], two[i - 2]); //except 1 } add(ans, ans); printf(&quot;%d\n&quot;, ans); } return 0; }]]></content>
      <categories>
        <category>数学</category>
        <category>贡献</category>
      </categories>
      <tags>
        <tag>BIT</tag>
        <tag>逆序数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 11 C. Hard Process（two pointers）]]></title>
    <url>%2F2016%2F04%2F10%2FEducational%20Codeforces%20Round%2011%20C.%20Hard%20Process%EF%BC%88two%20pointers%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N\le 3\times 10^5的序列，A_i = 0 或者1$$k\le N次操作将0变成1，求最长的连续1序列长度，并打印方案$ 分析： $two pointers经典题啦，记录下比较好的写法$$时间复杂度O(n)$ 代码： // // Created by TaoSama on 2016-04-08 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 3e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, k, a[N]; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); while(scanf(&quot;%d%d&quot;, &amp;n, &amp;k) == 2) { for(int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, a + i); int cnt = 0; pair&lt;int, int&gt; ans = {0, 0}; //sum, l for(int l = 1, r = 1; l &lt;= n; ++l) { while(r &lt;= n &amp;&amp; cnt + !a[r] &lt;= k) cnt += !a[r++]; ans = max(ans, {r - l, l}); cnt -= !a[l]; } printf(&quot;%d\n&quot;, ans.first); for(int i = ans.second; ans.first--; ++i) a[i] = 1; for(int i = 1; i &lt;= n; ++i) printf(&quot;%d%c&quot;, a[i], &quot; \n&quot;[i == n]); } return 0; }]]></content>
      <categories>
        <category>技巧</category>
        <category>two pointers</category>
      </categories>
      <tags>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 346 (Div. 2) F. Polycarp and Hay（逆向思维、bfs）]]></title>
    <url>%2F2016%2F04%2F07%2FCodeforces%20Round%20346%20(Div.%202)%20F.%20Polycarp%20and%20Hay%EF%BC%88%E9%80%86%E5%90%91%E6%80%9D%E7%BB%B4%E3%80%81bfs%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N，M\le 10^3，N\times M的矩阵，每个格子A_{ij}\le 10^9$$现选出一些数变小使得它们的和为K\le 10^{18}，需满足：$$1.至少有1个数不变$$2.选出的所有数必须相同$$3.选出的数必须连通$$存在输出YES，打印任意解，否则输出NO$ 分析： $枚举不变的数，显然它们都是K的约数，先把它们村下来$$赛上写的从小到大枚举bfs，加了BIT优化，蓝儿并不能改变O((nm)^2)的命运$$但是如果你想想从大到小的话，就可以复用之前bfs到的了$$用并查集维护连通的size，大的一定可以变小嘛，这样复杂度就保证了$$找到答案之后，再重新bfs一次打印解就好了$$不完全一样的东西少复用啊，强迫症要改啊$$时间复杂度O(nm)$ 代码： // // Created by TaoSama on 2016-03-31 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, m; vector&lt;int&gt; G[N], T[N]; int dfn[N], low[N], in[N], id[N], bcc, dfsNum; int stk[N], top; void tarjan(int u, int f) { dfn[u] = low[u] = ++dfsNum; stk[++top] = u; in[u] = true; for(int&amp; v : G[u]) { if(v == f) continue; if(!dfn[v]) { tarjan(v, u); low[u] = min(low[u], low[v]); } else low[u] = min(low[u], dfn[v]); } if(low[u] == dfn[u]) { ++bcc; while(true) { int v = stk[top--]; in[v] = false; id[v] = bcc; if(v == u) break; } } } void init() { bcc = dfsNum = 0; memset(dfn, 0, sizeof dfn); } bool vis[N]; void dfs(int u, bool&amp; ok, vector&lt;int&gt;&amp; sz) { vis[u] = true; ok |= (sz[u] &gt; 1); for(int v : T[u]) { if(vis[v]) continue; dfs(v, ok, sz); } } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= m; ++i) { int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); } init(); for(int i = 1; i &lt;= n; ++i) if(!dfn[i]) tarjan(i, -1); vector&lt;int&gt; sz(N, 0); for(int i = 1; i &lt;= n; ++i) sz[id[i]]++; for(int i = 1; i &lt;= n; ++i) { int u = id[i]; for(int&amp; j : G[i]) { int v = id[j]; T[u].push_back(v); } } int ans = 0; for(int i = 1; i &lt;= bcc; ++i) { if(vis[i]) continue; bool ok = false; dfs(i, ok, sz); ans += !ok; } printf(&quot;%d\n&quot;, ans); return 0; }]]></content>
      <categories>
        <category>思维</category>
        <category>逆向思维</category>
      </categories>
      <tags>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 346 (Div. 2) E. New Reform（边双连通缩点、连通块）]]></title>
    <url>%2F2016%2F04%2F07%2FCodeforces%20Round%20346%20(Div.%202)%20E.%20New%20Reform%EF%BC%88%E8%BE%B9%E5%8F%8C%E8%BF%9E%E9%80%9A%E7%BC%A9%E7%82%B9%E3%80%81%E8%BF%9E%E9%80%9A%E5%9D%97%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N，M\le 10^5，N个点M条边的无向图，现在给每条边定向$$求定向后0入度的点的个数$ 分析： $首先对于环(边双连通分量)来说，无论怎么定向都不会有0入度的点的$$那么对于边双缩点之后的图(森林)，对于每个连通块(树)来说：$$如果含有大于1的环(边双连通分量)，以它为根，所有边都指向远离根的方向$$此时，根不是0入度，所有儿子也不是$$统计不是这样的树的个数就好了$$时间复杂度为O(n+m)$ 代码： // // Created by TaoSama on 2016-03-31 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, m; vector&lt;int&gt; G[N], T[N]; int dfn[N], low[N], in[N], id[N], bcc, dfsNum; int stk[N], top; void tarjan(int u, int f) { dfn[u] = low[u] = ++dfsNum; stk[++top] = u; in[u] = true; for(int&amp; v : G[u]) { if(v == f) continue; if(!dfn[v]) { tarjan(v, u); low[u] = min(low[u], low[v]); } else low[u] = min(low[u], dfn[v]); } if(low[u] == dfn[u]) { ++bcc; while(true) { int v = stk[top--]; in[v] = false; id[v] = bcc; if(v == u) break; } } } void init() { bcc = dfsNum = 0; memset(dfn, 0, sizeof dfn); } bool vis[N]; void dfs(int u, bool&amp; ok, vector&lt;int&gt;&amp; sz) { vis[u] = true; ok |= (sz[u] &gt; 1); for(int v : T[u]) { if(vis[v]) continue; dfs(v, ok, sz); } } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= m; ++i) { int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); } init(); for(int i = 1; i &lt;= n; ++i) if(!dfn[i]) tarjan(i, -1); vector&lt;int&gt; sz(N, 0); for(int i = 1; i &lt;= n; ++i) sz[id[i]]++; for(int i = 1; i &lt;= n; ++i) { int u = id[i]; for(int&amp; j : G[i]) { int v = id[j]; T[u].push_back(v); } } int ans = 0; for(int i = 1; i &lt;= bcc; ++i) { if(vis[i]) continue; bool ok = false; dfs(i, ok, sz); ans += !ok; } printf(&quot;%d\n&quot;, ans); return 0; }]]></content>
      <categories>
        <category>图论</category>
        <category>连通图</category>
      </categories>
      <tags>
        <tag>边双连通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5654 xiaoxin and his watermelon candy（离线思想、BIT）]]></title>
    <url>%2F2016%2F04%2F07%2FHDU%205654%20xiaoxin%20and%20his%20watermelon%20candy%EF%BC%88%E7%A6%BB%E7%BA%BF%E6%80%9D%E6%83%B3%E3%80%81BIT%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N，Q\le 2\times 10^5，N个数的序列，A_i\in[0,10^9]$$定义奇怪的三元组为(i,j,k)，i,j,k连续，且A_i\le A_j\le A_k$$询问区间[l,r]中不同的奇怪三元组的个数$ 分析： $离线sb套路题，询问右端点排序$$从左往右扫描A_i，一旦找到合法的三元组$$BIT维护出现的个数，更新要在三元组的第1个位置$$就把之前的位置-1，现在的位置+1$$现在所有以i为右端点的询问的答案，只要查询sum(L,i)就可以了$$即ans(L,i)=sum(L,i)，这里BIT倒过来用就可以了，向前更新，向后查询$$当然你要主席树强制在线也是兹磁的，反正复杂度一样的$$时间复杂度为O(nlogn)$ 代码： // // Created by TaoSama on 2016-04-07 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 2e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, q, a[N]; struct BIT { int n, b[N]; void init(int _n) { n = _n; memset(b, 0, sizeof b); } void add(int i, int v) { for(; i; i -= i &amp; -i) b[i] += v; } int sum(int i) { int ret = 0; for(; i &lt;= n; i += i &amp; -i) ret += b[i]; return ret; } } bit; int ans[N]; vector&lt;pair&lt;int, int&gt; &gt; qs[N]; typedef tuple&lt;int, int, int&gt; tripe; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, a + i); scanf(&quot;%d&quot;, &amp;q); for(int i = 1; i &lt;= n; ++i) qs[i].clear(); for(int i = 1; i &lt;= q; ++i) { int l, r; scanf(&quot;%d%d&quot;, &amp;l, &amp;r); qs[r].push_back({l, i}); } bit.init(n); int cnt = 0; map&lt;tripe, int&gt; mp; for(int i = 1; i &lt;= n; ++i) { cnt = a[i] &gt;= a[i - 1] ? cnt + 1 : 1; if(cnt &gt; 2) { tripe cur = tripe(a[i - 2], a[i - 1], a[i]); if(mp.count(cur)) bit.add(mp[cur], -1); mp[cur] = i - 2; bit.add(i - 2, 1); } for(auto&amp; q : qs[i]) ans[q.second] = bit.sum(q.first); } for(int i = 1; i &lt;= q; ++i) printf(&quot;%d\n&quot;, ans[i]); } return 0; }]]></content>
      <categories>
        <category>思维</category>
        <category>离线思想</category>
      </categories>
      <tags>
        <tag>BIT</tag>
        <tag>离线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5653 Bomber Man wants to bomb an Array（dp）]]></title>
    <url>%2F2016%2F04%2F07%2FHDU%205653%20Bomber%20Man%20wants%20to%20bomb%20an%20Array%EF%BC%88dp%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N\le 2\times 10^3，N个格子，M\le N个炸弹$$每个炸弹可以向左向右炸任意距离，假设为L，R，那么贡献E_i=L+R+1$$每个格子只能炸1次，总贡献为\Pi_{i=1}^mE_i$$求最大的总贡献$ 分析： $dp，f[i]:=前i个格子被炸掉的最大贡献$$转移就枚举炸弹，枚举左右炸的距离，然后这个看起来的三方的dp是二方的$$f[0]=1，f[r] = max(f[r], f[l-1]*(r-l+1))，log2一下就变成+了$$只看左右端点，都只是枚举了n$$时间复杂度O(n^2)$ 代码： // // Created by TaoSama on 2016-04-07 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 2e3 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, m; int a[N]; double v[N], f[N]; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); int t; scanf(&quot;%d&quot;, &amp;t); for(int i = 1; i &lt;= 2000; ++i) v[i] = log2(i); while(t--) { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); a[0] = 0; a[m + 1] = n + 1; for(int i = 1; i &lt;= m; ++i) scanf(&quot;%d&quot;, a + i), ++a[i]; sort(a + 1, a + 1 + m); memset(f, 0, sizeof f); f[0] = 0; for(int i = 1; i &lt;= m; ++i) for(int l = a[i - 1] + 1; l &lt;= a[i]; ++l) for(int r = a[i]; r &lt;= a[i + 1] - 1; ++r) f[r] = max(f[r], f[l - 1] + v[r - l + 1]); long long ans = 1e6 * f[n]; printf(&quot;%I64d\n&quot;, ans); } return 0; }]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5652 India and China Origins（并查集）]]></title>
    <url>%2F2016%2F04%2F07%2FHDU%205652%20India%20and%20China%20Origins%EF%BC%88%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N，M\le 5\times 10^2，N\times M的矩阵，0表示可通过，1不可通过$$这个矩阵是连通的当且仅当，从第一行的任意一点出发可以到最后一行$$给定Q\le N\times M次修改，将矩阵的0变1$$问最早哪一次修改使得矩阵不连通$ 分析： $显然建立一个超源连到第一行，超汇连到最后一行$$然后直接二分+bfs或者并查集判断连通性就做完了$$其实可以倒着来想，先全部把1加进去，再1个1个删掉$$这里要注意源汇的连通性哦，反正我觉得前者好写$$时间复杂度O((n+m)logm)或者O(n+m)$ 代码： // // Created by TaoSama on 2016-04-07 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 5e2 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; struct DSU { int n, p[N * N], r[N * N]; void init(int _n) { n = _n; for(int i = 0; i &lt; n; ++i) p[i] = i, r[i] = 0; } int find(int x) { return p[x] = p[x] == x ? x : find(p[x]); } void unite(int x, int y) { x = find(x), y = find(y); if(x == y) return; if(r[x] &gt; r[y]) swap(x, y); if(r[x] == r[y]) ++ r[y]; p[x] = y; } bool same(int x, int y) { return find(x) == find(y); } } dsu; int n, m, q; char a[N][N]; pair&lt;int, int&gt; qs[N * N]; inline int ID(int x, int y) { return x * m + y; } void process(int i, int j) { static int d[][2] = { -1, 0, 0, -1, 1, 0, 0, 1}; if(a[i][j] == &#39;1&#39;) return; for(int k = 0; k &lt; 4; ++k) { int x = i + d[k][0], y = j + d[k][1]; if(y &lt; 0 || y &gt;= m) continue; if(x &lt; 0) dsu.unite(ID(i, j), n * m); else if(x &gt;= n) dsu.unite(ID(i, j), n * m + 1); else if(a[x][y] == &#39;0&#39;) dsu.unite(ID(i, j), ID(x, y)); } } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 0; i &lt; n; ++i) scanf(&quot;%s&quot;, a[i]); scanf(&quot;%d&quot;, &amp;q); for(int i = 0; i &lt; q; ++i) { int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); qs[i] = {x, y}; a[x][y] = &#39;1&#39;; } dsu.init(n * m + 2); int s = n * m, t = s + 1; for(int i = 0; i &lt; m; ++i) { if(a[0][i] == &#39;0&#39;) dsu.unite(s, ID(0, i)); if(a[n - 1][i] == &#39;0&#39;) dsu.unite(ID(n - 1, i), t); } for(int i = 0; i &lt; n; ++i) for(int j = 0; j &lt; m; ++j) process(i, j); if(dsu.same(s, t)) {puts(&quot;-1&quot;); continue;} for(int i = q - 1; ~i; --i) { int x = qs[i].first, y = qs[i].second; a[x][y] = &#39;0&#39;; process(x, y); if(dsu.same(s, t)) { printf(&quot;%d\n&quot;, i + 1); break; } } } return 0; }]]></content>
      <categories>
        <category>数据结构</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>离线</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5651 xiaoxin juju needs help（组合数学）]]></title>
    <url>%2F2016%2F04%2F07%2FHDU%205651%20xiaoxin%20juju%20needs%20help%EF%BC%88%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N\le 2\times 10^3的字符串，字符集大小为26$$现在重排它，问有多少个不同的回文串$ 分析： $这个很显然了，num_{字符出现奇数个数}&gt;1肯定GG$$没出现奇数字符直接搞就好了，出现了就取出1个放在中间，剩下的都是偶数个数了$$ans=\frac{ {\frac{n}{2}}!} {c_1 !\cdot c_2!\cdots c_m!}，很简单的组合计数啦$$就是要求个逆元$ 代码： // // Created by TaoSama on 2016-04-07 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e3 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; char s[N]; int f[N], inv[N], finv[N]; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); f[0] = inv[0] = finv[0] = 1; f[1] = inv[1] = finv[1] = 1; for(int i = 2; i &lt;= 1000; ++i) { f[i] = 1LL * i * f[i - 1] % MOD; inv[i] = 1LL * (MOD - MOD / i) * inv[MOD % i] % MOD; finv[i] = 1LL * inv[i] * finv[i - 1] % MOD; } int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%s&quot;, s); int n = strlen(s); vector&lt;int&gt; c(26, 0); for(int i = 0; i &lt; n; ++i) c[s[i] - &#39;a&#39;]++; int odd = 0; for(int i = 0; i &lt; 26; ++i) odd += c[i] &amp; 1; if(odd &gt; 1) {puts(&quot;0&quot;); continue;} int ans = f[n / 2]; for(int i = 0; i &lt; 26; ++i) ans = 1LL * ans * finv[c[i] / 2] % MOD; printf(&quot;%d\n&quot;, ans); } return 0; }]]></content>
      <categories>
        <category>数学</category>
        <category>组合数学</category>
      </categories>
      <tags>
        <tag>逆元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5639 Deletion（最大流）]]></title>
    <url>%2F2016%2F04%2F07%2FHDU%205639%20Deletion%EF%BC%88%E6%9C%80%E5%A4%A7%E6%B5%81%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N，M\le 2\times 10^3，N个点M条边的无向图$$每次选择从图中删掉一些边，要求选出来的边构成的子图的每个连通块最多只有一个环$$问最少需要删几次才能把所有边都删掉$ 分析： $这想法真是炫酷，虽然我做过混合图欧拉回路那个题，早都忘了$$第二种解法也是炫酷$ 代码： // // Created by TaoSama on 2016-04-07 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 4e3 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; const int M = 8e3 + 10; struct Edge { int v, nxt, cap; } edge[M &lt;&lt; 1]; int head[N], cnt; void addDouble(int u, int v, int c1, int c2 = 0) { edge[cnt] = {v, head[u], c1}; head[u] = cnt++; edge[cnt] = {u, head[v], c2}; head[v] = cnt++; } int lev[N], cur[N]; bool bfs(int s, int t) { queue&lt;int&gt; q; memset(lev, 0, sizeof lev); q.push(s); lev[s] = 1; while(q.size() &amp;&amp; !lev[t]) { int u = q.front(); q.pop(); for(int i = head[u]; ~i; i = edge[i].nxt) { int v = edge[i].v; if(edge[i].cap &gt; 0 &amp;&amp; !lev[v]) { lev[v] = lev[u] + 1; q.push(v); } } } return lev[t]; } int dfs(int u, int t, int delta) { if(u == t || !delta) return delta; int ret = 0; for(int i = cur[u]; ~i; i = edge[i].nxt) { int v = edge[i].v; if(edge[i].cap &gt; 0 &amp;&amp; lev[v] == lev[u] + 1) { int d = dfs(v, t, min(delta, edge[i].cap)); cur[u] = i; ret += d; delta -= d; edge[i].cap -= d; edge[i ^ 1].cap += d; if(delta == 0) return ret; } } lev[u] = 0; return ret; } int dinic(int s, int t) { int ret = 0; while(bfs(s, t)) { for(int i = s; i &lt;= t; ++i) cur[i] = head[i]; ret += dfs(s, t, INF); } return ret; } int n, m; int u[M], v[M]; bool check(int x) { cnt = 0; memset(head, -1, sizeof head); int s = 0, t = n + m + 1; for(int i = 1; i &lt;= n; ++i) addDouble(s, i, x); for(int i = 1; i &lt;= m; ++i) { addDouble(u[i], i + n, 1); addDouble(v[i], i + n, 1); addDouble(i + n, t, 1); } return dinic(s, t) == m; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= m; ++i) scanf(&quot;%d%d&quot;, u + i, v + i); int l = 0, r = m; while(l &lt;= r) { int m = l + r &gt;&gt; 1; if(check(m)) r = m - 1; else l = m + 1; } printf(&quot;%d\n&quot;, l); } return 0; }]]></content>
      <categories>
        <category>图论</category>
        <category>网络流</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5638 Toposort（拓扑排序）]]></title>
    <url>%2F2016%2F04%2F07%2FHDU%205638%20Toposort%EF%BC%88%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N\le 10^5个点，M\le 2\times 10^5条边的无向图，现删去K\le M条边$$要使得最小拓扑序最小，求这个拓扑序$ 分析： $参考下普通的用堆维护求字典序最小拓扑序$ $用某种数据结构维护入度小于等于k的所有点$$每次找出编号最小的i，强制删掉它的所有入边，表现为k-=inDegree_i$$可以用线段树维护全局入度，每次线段树上二分找\le k的最小的i$$其实也可以用堆来机智的做，反正每个只会用一次，复杂度是保证了的$$时间复杂度为O(nlogn)$ 代码： // // Created by TaoSama on 2016-04-06 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, m, k; vector&lt;int&gt; G[N]; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k); for(int i = 1; i &lt;= n; ++i) G[i].clear(); vector&lt;int&gt; in(N, 0); for(int i = 1; i &lt;= m; ++i) { int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); G[u].push_back(v); ++in[v]; } vector&lt;bool&gt; used(N, false); priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q; for(int i = 1; i &lt;= n; ++i) if(in[i] &lt;= k) q.push(i); int ans = 0; for(int i = 1; i &lt;= n; ++i) { int u; while(true) { u = q.top(); q.pop(); if(!used[u] &amp;&amp; in[u] &lt;= k) break; } k -= in[u]; used[u] = true; ans += 1LL * i * u % MOD; if(ans &gt;= MOD) ans -= MOD; for(int v : G[u]) if(--in[v] &lt;= k) q.push(v); } printf(&quot;%d\n&quot;, ans); } return 0; }]]></content>
      <categories>
        <category>图论</category>
        <category>拓扑排序</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5637 Transform（bfs）]]></title>
    <url>%2F2016%2F04%2F07%2FHDU%205637%20Transform%EF%BC%88bfs%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N\le 15个整数A_i \le 10^5，对于一个数x，2种操作：$$1.翻转二进制位中的1个位$$2.x\oplus A_i，1次选择1个A_i，\oplus为二进制异或$$Q\le 10^5询问，s\to t的最小操作数$ 分析： $对于第一种操作其实就是x\oplus 2^i，i\in [0,17)$$多次询问其实我们可以bfs预处理，d[x]为到x的最小步数$$然后我们发现ans(s,t)=d[s\oplus t]$ 代码： // // Created by TaoSama on 2016-04-06 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, m, a[16]; int d[1 &lt;&lt; 17]; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, a + i); memset(d, 0x3f, sizeof d); queue&lt;int&gt; q; q.push(0); d[0] = 0; while(q.size()) { int u = q.front(); q.pop(); for(int i = 0; i &lt; 17; ++i) { int v = u ^ (1 &lt;&lt; i); if(d[v] == INF) { d[v] = d[u] + 1; q.push(v); } } for(int i = 1; i &lt;= n; ++i) { int v = u ^ a[i]; if(d[v] == INF) { d[v] = d[u] + 1; q.push(v); } } } int ans = 0; for(int i = 1; i &lt;= m; ++i) { int s, t; scanf(&quot;%d%d&quot;, &amp;s, &amp;t); ans += 1LL * i * d[s ^ t] % MOD; if(ans &gt;= MOD) ans -= MOD; } printf(&quot;%d\n&quot;, ans); } return 0; }]]></content>
      <categories>
        <category>暴力</category>
        <category>搜索</category>
        <category>dfs/bfs</category>
      </categories>
      <tags>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5636 Shortest Path（floyd）]]></title>
    <url>%2F2016%2F04%2F07%2FHDU%205636%20Shortest%20Path%EF%BC%88floyd%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N，M\le 10^5，N个点M条边的形成一条链的无向图$$即只有(i,i+1,1)这样的边，i\in[1,N)$$现在添加3条长度为1的边，Q次询问dis(a,b)$ 分析： $把这6个点floyd一下，然后暴力枚举经过这6个点中的2个点，或者不经过$$时间复杂度为O(6^2\cdot m)$$当然建图跑spfa也可以，求dis[6][N]，枚举经过这6个点中的1个点，或者不经过$$时间复杂度为O(6m)$ 代码： // // Created by TaoSama on 2016-04-06 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, m, a[4], b[4]; int g[7][7]; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); vector&lt;int&gt; v; for(int i = 1; i &lt;= 3; ++i) { scanf(&quot;%d%d&quot;, a + i, b + i); v.push_back(a[i]); v.push_back(b[i]); } sort(v.begin(), v.end()); v.resize(unique(v.begin(), v.end()) - v.begin()); int sz = v.size(); for(int i = 1; i &lt;= sz; ++i) for(int j = 1; j &lt;= sz; ++j) g[i][j] = abs(v[i - 1] - v[j - 1]); for(int i = 1; i &lt;= 3; ++i) { int x = lower_bound(v.begin(), v.end(), a[i]) - v.begin() + 1; int y = lower_bound(v.begin(), v.end(), b[i]) - v.begin() + 1; g[x][y] = min(g[x][y], 1); g[y][x] = min(g[y][x], 1); } for(int k = 1; k &lt;= sz; ++k) for(int i = 1; i &lt;= sz; ++i) for(int j = 1; j &lt;= sz; ++j) g[i][j] = min(g[i][j], g[i][k] + g[k][j]); int ans = 0; for(int i = 1; i &lt;= m; ++i) { int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); int cur = abs(x - y); for(int j = 1; j &lt;= sz; ++j) for(int k = 1; k &lt;= sz; ++k) cur = min(cur, abs(x - v[j - 1]) + g[j][k] + abs(y - v[k - 1])); ans += 1LL * i * cur % MOD; if(ans &gt;= MOD) ans -= MOD; } printf(&quot;%d\n&quot;, ans); } return 0; }]]></content>
      <categories>
        <category>图论</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>floyd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VK Cup 2016 - Round 1 E. Bear and Contribution（贪心）]]></title>
    <url>%2F2016%2F03%2F30%2FVK%20Cup%202016%20-%20Round%201%20E.%20Bear%20and%20Contribution%EF%BC%88%E8%B4%AA%E5%BF%83%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N，K\le 2\times 10^5，给定N个数，现在要使其中至少K个数变得相同$$b，c\le 1000，其中增加5的代价是b，增加1的代价是c$ 分析： $显然的想法是都变成已有某个数比较优$$但是b，c大小没给定，如果b很小，那么我们可以稍微通过+1变大我们这个数，同时其他的数+5$$所以我们发现选择的数应该是a_i+j, j\in[0,5)$$这样我们只要维护5个set，来动态维护k个数就好了$$但是每次我们要O(1)计算出变成当前数的花费，其实只要把之前的数都变成[0,4)$$之后再统一变成当前数就好辣，就可以O(1)计算了，注意负数哦$$时间复杂度O(5nlogn)$ 代码： // // Created by TaoSama on 2016-03-30 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 2e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; typedef long long LL; int n, k, a[N]; LL b, c; int get(int x) {return (x % 5 + 5) % 5;} int count(int x) {return (x - get(x)) / 5;} int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); scanf(&quot;%d%d%I64d%I64d&quot;, &amp;n, &amp;k, &amp;b, &amp;c); for(int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, a + i); b = min(b, 5 * c); sort(a + 1, a + 1 + n); multiset&lt;LL&gt; s[5]; LL ans = 1e18, cost[5] = {}; for(int i = 1; i &lt;= n; ++i) { for(int j = 0; j &lt; 5; ++j) { int wh = get(a[i] + j); int times = count(a[i] + j); LL cur = j * c - times * b; s[wh].insert(cur); cost[wh] += cur; if(s[wh].size() &gt; k) { cost[wh] -= *s[wh].rbegin(); s[wh].erase(s[wh].find(*s[wh].rbegin())); } if(s[wh].size() == k) { LL tmp = cost[wh] + times * b * k; ans = min(ans, tmp); } } } printf(&quot;%I64d\n&quot;, ans); return 0; }]]></content>
      <categories>
        <category>思维</category>
        <category>贪心</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[VK Cup 2016 - Round 1 D. Bear and Polynomials（哈希）]]></title>
    <url>%2F2016%2F03%2F29%2FVK%20Cup%202016%20-%20Round%201%20D.%20Bear%20and%20Polynomials%EF%BC%88%E5%93%88%E5%B8%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N\le 2\times 10^5，给定一个N次多项式，即P(x)=\sum_{i=0}^N a_i\cdot x^i$$已经P(2)\neq 0，现要改变其中一个系数a_i，使得P’(2)=0$$求方法数$ 分析： $由于N非常大，所以直接算是不行的$$我们可以通过对素数取模来哈希这个结果，这个素数一定要比max\{a_i\}大$$取2个素数，之后枚举每个系数，算出答案，比较是否相等即可，同时别忘记负数答案了$$各种取模，注意不要模出负数了$$时间复杂度O(n)$ 代码： // // Created by TaoSama on 2016-03-29 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 2e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, k; int a[N]; typedef long long LL; LL ksm(LL x, LL n, LL MOD) { LL ret = 1; for(; n; n &gt;&gt;= 1) { if(n &amp; 1) ret = ret * x % MOD; x = x * x % MOD; } return ret; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); scanf(&quot;%d%d&quot;, &amp;n, &amp;k); LL sum[2] = {}, mod[2] = {MOD, MOD + 2}; LL power[2] = {1, 1}, base[2] = {2, 2}; for(int i = 0; i &lt;= n; ++i) { scanf(&quot;%d&quot;, a + i); for(int j = 0; j &lt; 2; ++j) { sum[j] = (sum[j] + a[i] * power[j] % mod[j]) % mod[j]; sum[j] = (sum[j] + mod[j]) % mod[j]; power[j] = power[j] * base[j] % mod[j]; } } int ans = 0; for(int i = 0; i &lt; 2; ++i) power[i] = 1, base[i] = ksm(2, mod[i] - 2, mod[i]); for(int i = 0; i &lt;= n; ++i) { LL delta[2]; for(int j = 0; j &lt; 2; ++j) { delta[j] = (a[i] - sum[j] * power[j] % mod[j]) % mod[j]; delta[j] = (delta[j] + mod[j]) % mod[j]; power[j] = power[j] * base[j] % mod[j]; } LL cof = INF; if(delta[0] == delta[1]) cof = delta[0]; if(delta[0] - mod[0] == delta[1] - mod[1]) cof = delta[0] - mod[0]; if(abs(cof) &gt; k || i == n &amp;&amp; cof == 0) continue; ++ans; } printf(&quot;%d\n&quot;, ans); return 0; }]]></content>
      <categories>
        <category>技巧</category>
        <category>哈希</category>
      </categories>
      <tags>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 10 E. Pursuit For Artifacts（边双连通缩点）]]></title>
    <url>%2F2016%2F03%2F28%2FEducational%20Codeforces%20Round%2010%20E.%20Pursuit%20For%20Artifacts%EF%BC%88%E8%BE%B9%E5%8F%8C%E8%BF%9E%E9%80%9A%E7%BC%A9%E7%82%B9%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N，M\le 3\times 10^5，N个点，M条边的无向图，无重边自环$$边权为0或1，问s\to t是否存权\ge 1且每条边经过一次的一条路径$ 分析： $边双缩点成树，树边(桥边)权保留，bcc内总权映射到点上$$ans=dis(s,t)\ge 1$$正确性就是bcc任意2点连通，是个简单环嘛，选有1的那半边走就好啦$ $并且树上2点路径是唯一的，满足题意就做完了$$时间复杂度O(n+m)$ 代码： // // Created by TaoSama on 2016-03-25 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 3e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, m; struct Edge { int v, c; }; vector&lt;Edge&gt; G[N], T[N]; int dfn[N], low[N], in[N], id[N], bcc, dfsNum; int stk[N], top; void tarjan(int u, int f) { dfn[u] = low[u] = ++dfsNum; stk[++top] = u; in[u] = true; for(Edge e : G[u]) { int v = e.v; if(v == f) continue; if(!dfn[v]) { tarjan(v, u); low[u] = min(low[u], low[v]); } else low[u] = min(low[u], dfn[v]); } if(low[u] == dfn[u]) { ++bcc; while(true) { int v = stk[top--]; in[v] = false; id[v] = bcc; if(v == u) break; } } } void init() { bcc = dfsNum = 0; memset(dfn, 0, sizeof dfn); tarjan(1, -1); } int val[N]; bool dfs(int s, int t, int fa, int sum) { if(s == t) return sum + val[t]; for(Edge e : T[s]) { int v = e.v; if(v == fa) continue; if(dfs(v, t, s, sum + e.c + val[v])) return true; } return false; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= m; ++i) { int u, v, c; scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;c); G[u].push_back({v, c}); G[v].push_back({u, c}); } init(); for(int i = 1; i &lt;= n; ++i) { int u = id[i]; for(Edge e : G[i]) { int v = id[e.v]; if(u == v) val[u] += e.c; else T[u].push_back({v, e.c}); } } int s, t; scanf(&quot;%d%d&quot;, &amp;s, &amp;t); puts(dfs(id[s], id[t], -1, val[id[s]]) ? &quot;YES&quot; : &quot;NO&quot;); return 0; }]]></content>
      <categories>
        <category>图论</category>
        <category>连通图</category>
      </categories>
      <tags>
        <tag>边双连通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 10 D. Nested Segments（离线思想、BIT）]]></title>
    <url>%2F2016%2F03%2F28%2FEducational%20Codeforces%20Round%2010%20D.%20Nested%20Segments%EF%BC%88%E7%A6%BB%E7%BA%BF%E6%80%9D%E6%83%B3%E3%80%81BIT%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N \le 2\times 10^5个线段，问第i个线段包含多少个其它线段$ 分析： $经典离线套路题了，询问右端点排序$$从左往右扫描每个数i（相当于固定了右端点）$$然后对于所有[L, i]的询问，查询sum(L, i)就是答案了$$这里其实把BIT倒过来就可以完成了，向前更新，向后查询$$之后把每个询问（线段）的左端点添加进线段树中$$时间复杂度O(nlogn)$ 代码： // // Created by TaoSama on 2016-03-25 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 4e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, ans[N]; pair&lt;int, int&gt; tmp[N]; vector&lt;pair&lt;int, int&gt; &gt; qs[N]; struct BIT { int n, b[N]; void init(int _n) { n = _n; memset(b, 0, sizeof b); } void add(int i, int v) { for(; i; i -= i &amp; -i) b[i] += v; } int sum(int i) { int ret = 0; for(; i &lt;= n; i += i &amp; -i) ret += b[i]; return ret; } } bit; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); scanf(&quot;%d&quot;, &amp;n); vector&lt;int&gt; xs; for(int i = 1; i &lt;= n; ++i) { int l, r; scanf(&quot;%d%d&quot;, &amp;l, &amp;r); xs.push_back(l); xs.push_back(r); tmp[i] = {l, r}; } sort(xs.begin(), xs.end()); xs.resize(unique(xs.begin(), xs.end()) - xs.begin()); for(int i = 1; i &lt;= n; ++i) { int l = tmp[i].first, r = tmp[i].second; l = lower_bound(xs.begin(), xs.end(), l) - xs.begin() + 1; r = lower_bound(xs.begin(), xs.end(), r) - xs.begin() + 1; qs[r].push_back({l, i}); } bit.init(xs.size()); for(int i = 1; i &lt;= xs.size(); ++i) { for(auto&amp; p : qs[i]) { ans[p.second] = bit.sum(p.first); bit.add(p.first, 1); } } for(int i = 1; i &lt;= n; ++i) printf(&quot;%d\n&quot;, ans[i]); return 0; }]]></content>
      <categories>
        <category>思维</category>
        <category>离线思想</category>
      </categories>
      <tags>
        <tag>BIT</tag>
        <tag>离线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 10 C. Foe Pairs（离线思想、贪心）]]></title>
    <url>%2F2016%2F03%2F28%2FEducational%20Codeforces%20Round%2010%20C.%20Foe%20Pairs%EF%BC%88%E7%A6%BB%E7%BA%BF%E6%80%9D%E6%83%B3%E3%80%81%E8%B4%AA%E5%BF%83%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N，M\le 3\times 10^5，N个数，M个非法数对(a_i,b_i)$$求不包含任何非法数对的区间个数$ 分析： $ans=总区间数-非法的$$经典离线套路了$$非法的话，直接把非法数对转化成区间，对这些区间右端点排序$$挨个枚举每个点作为右端点，对于每个点显然它的贡献是最大的那个l([1,l]都可以选做左端点)$$累计贡献，就可以算出答案了$$时间复杂度O(nlogn)$ 代码： // // Created by TaoSama on 2016-03-25 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 3e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, m; int a[N], wh[N]; vector&lt;int&gt; qs[N]; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) == 2) { for(int i = 1; i &lt;= n; ++i) { scanf(&quot;%d&quot;, a + i); wh[a[i]] = i; } for(int i = 1; i &lt;= n; ++i) qs[i].clear(); for(int i = 1; i &lt;= m; ++i) { int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); x = wh[x]; y = wh[y]; if(x &gt; y) swap(x, y); qs[y].push_back(x); } long long ans = 0; int l = 0; for(int i = 1; i &lt;= n; ++i) { for(int x : qs[i]) l = max(l, x); ans += l; } ans = 1LL * n * (n + 1) / 2 - ans; printf(&quot;%I64d\n&quot;, ans); } return 0; }]]></content>
      <categories>
        <category>思维</category>
        <category>离线思想</category>
      </categories>
      <tags>
        <tag>离线</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVA 10968 KuPellaKes（贪心、最短路）]]></title>
    <url>%2F2016%2F03%2F28%2FUVA%2010968%20KuPellaKes%EF%BC%88%E8%B4%AA%E5%BF%83%E3%80%81%E6%9C%80%E7%9F%AD%E8%B7%AF%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N\le 2000个点的图，无重边自环，现要删去一些边$$使得所有的点都是正偶度，保证图最多有2个奇度点$$输出满足要求的要删去的最少的边，不能输出Poor Koorosh$ 分析： $首先奇度点只有0个或2个，因为total degree = 2|E|，是偶度，必有偶数个奇度点$$首先check图是不是合法，有没有孤立节点，或者1度的奇度点(删了就变了0了)$$如果0个奇度点，答案显然是0，不然就是2个奇度点的最短路$$因为删去2个奇度点的一条边，如果路上经过偶度点，显然会删去2条边(1入1出)$$最终肯定是个合法的图，最短路显然是最优答案咯$$但是不能经过2度的偶度点(去掉2度就为0了)$$时间复杂度为O(n+m)$ 代码： // // Created by TaoSama on 2016-03-27 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; #include &lt;cassert&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e3 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, m; vector&lt;int&gt; G[N]; int d[N]; int bfs(int s, int t) { memset(d, -1, sizeof d); queue&lt;int&gt; q; q.push(s); d[s] = 0; while(q.size()) { int u = q.front(); q.pop(); for(int i = 0; i &lt; G[u].size(); ++i) { int v = G[u][i]; if(G[v].size() == 2) continue; if(d[v] == -1) { d[v] = d[u] + 1; q.push(v); } } } return d[t]; } int solve() { for(int i = 1; i &lt;= n; ++i) G[i].clear(); for(int i = 1; i &lt;= m; ++i) { int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); } int s, t; s = t = -1; for(int i = 1; i &lt;= n; ++i) { if(G[i].size() &lt;= 1) return -1; if(G[i].size() &amp; 1) { if(s == -1) s = i; else t = i; } } //deg = 2E, so vertices of odd degree = 2 if(s == -1) return 0; assert(t != -1); return bfs(s, t); } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) == 2 &amp;&amp; (n || m)) { int ans = solve(); if(~ans) printf(&quot;%d\n&quot;, ans); else puts(&quot;Poor Koorosh&quot;); } return 0; }]]></content>
      <categories>
        <category>图论</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5324 Boring Class（LIS、二维分块）]]></title>
    <url>%2F2016%2F03%2F28%2FHDU%205324%20Boring%20Class%EF%BC%88LIS%E3%80%81%E4%BA%8C%E7%BB%B4%E5%88%86%E5%9D%97%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N\le 5\times 10^4，给定2个长度为N的序列，A_i，B_i$$现要选出对于2个序列同样的子序列，假设下标为p_1\le p_2\le \dots\le p_m$$满足A_{p_1}\ge A_{p_2}\dots\ge A_{p_m}, 且B_{p_1}\ge B_{p_2}\dots\ge B_{p_m}$$求最长的这样的子序列，打印下标，多解输出字典序最小解$ 分析： $如果直接按照LIS的dp方程转移是n^2的，考虑优化一下转移$$由于要最小字典序的，所以得倒着搞，因为状态是以i结尾的嘛$$倒着搞的话，对于一个点(up_i, down_i)看成(x,y)来说$$每次转移就是找左上角的点，即x要小，y要大的点$$这个我们可以用二维分块来搞，以\sqrt n的代价来转移$$cdq分治，树套树都可以$$时间复杂度为O(n\sqrt n)或者O(nlog^2n)$ 二维分块代码： // // Created by TaoSama on 2016-03-22 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; const int B = 250; int n; int x[N], y[N]; typedef pair&lt;int, int&gt; P; P pre[B][B]; //x&#39;s prefix max struct Node { int first, second; int id; } X[N], Y[N]; void compress(int *x, int delta) { vector&lt;pair&lt;int, int&gt; &gt; xs; for(int i = 1; i &lt;= n; ++i) xs.push_back({x[i], delta * i}); sort(xs.begin(), xs.end()); for(int i = 1; i &lt;= n; ++i) x[i] = lower_bound(xs.begin(), xs.end(), make_pair(x[i], delta * i)) - xs.begin() + 1; } void getMax(P&amp; x, P y) { if(x.first &lt; y.first) x = y; else if(x.first == y.first &amp;&amp; x.second &gt; y.second) x = y; } void update(int x, int y, int v, int id) { X[y] = {x, v, id}, Y[x] = {y, v, id}; for(int i = 0; i &lt;= y / B; ++i) getMax(pre[x / B][i], {v, id}); } pair&lt;int, int&gt; query(int x, int y) { pair&lt;int, int&gt; ret = {0, 0}; int tx = x / B, ty = y / B; for(int i = tx * B; i &lt; x; ++i) if(Y[i].first &gt; y) getMax(ret, {Y[i].second, Y[i].id}); for(int i = y + 1; i &lt; (ty + 1) * B; ++i) if(X[i].first &lt; x) getMax(ret, {X[i].second, X[i].id}); for(int i = 0; i &lt; tx; ++i) getMax(ret, pre[i][ty + 1]); return ret; } int prevv[N]; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); while(scanf(&quot;%d&quot;, &amp;n) == 1) { for(int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, x + i); for(int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, y + i); compress(x, -1); compress(y, 1); memset(pre, 0, sizeof pre); memset(Y, 0xc0, sizeof Y); memset(X, 0x3f, sizeof X); P ans = {0, 0}; memset(prevv, 0, sizeof prevv); for(int i = n; i &gt;= 1; --i) { P ret = query(x[i], y[i]); prevv[i] = ret.second; update(x[i], y[i], ret.first + 1, i); getMax(ans, {ret.first + 1, i}); } printf(&quot;%d\n&quot;, ans.first); vector&lt;int&gt; path; int u = ans.second; for(int i = 1; i &lt;= ans.first; ++i) { path.push_back(u); u = prevv[u]; } for(int i = 0; i &lt; path.size(); ++i) printf(&quot;%d%c&quot;, path[i], &quot; \n&quot;[i == path.size() - 1]); } return 0; }]]></content>
      <categories>
        <category>动态规划</category>
        <category>最长上升子序列</category>
      </categories>
      <tags>
        <tag>LIS</tag>
        <tag>二维分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5318 The Goddess Of The Moon（dp、矩阵快速幂）]]></title>
    <url>%2F2016%2F03%2F28%2FHDU%205318%20The%20Goddess%20Of%20The%20Moon%EF%BC%88dp%E3%80%81%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N\le 50，M\le 10^9，N个字符串，选出M个拼接到一起$$(i, j)拼接的条件是i的后缀和j的前缀的公共长度\ge 2$$问拼接成不同的字符串的个数，答案对10^9+7取模$ 分析： $N小，并且M是10^9，赤果果的告诉你是矩阵快速幂$$据说字符串要先去重，这是一个trick$$f[i][j]:=长度为i，j结尾的方法数，转移矩阵是trans[i][j]:=(i, j)能否拼接$$ans =\sum_{i=1}^n f[M][i]= f[1][i]\cdot (trans[i][j])^{M-1}$$时间复杂度为O(n^3logm)$ 代码： // // Created by TaoSama on 2016-03-22 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 50 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, m; typedef long long LL; struct Matrix { int row, col; LL mat[N][N]; void init(int r, int c, bool one = false) { row = r; col = c; memset(mat, 0, sizeof mat); if(!one) return; for(int i = 0; i &lt; row; ++i) mat[i][i] = 1; } Matrix operator* (const Matrix&amp; rhs) { Matrix ret; ret.init(row, rhs.col); for(int k = 0; k &lt; col; ++k) { for(int i = 0; i &lt; row; ++i) { if(mat[i][k] == 0) continue; for(int j = 0; j &lt; rhs.col; ++j) { if(rhs.mat[k][j] == 0) continue; ret.mat[i][j] = (ret.mat[i][j] + mat[i][k] * rhs.mat[k][j]) % MOD; } } } return ret; } Matrix operator^ (LL n) { Matrix ret, x = *this; ret.init(row, col, 1); while(n) { if(n &amp; 1) ret = ret * x; x = x * x; n &gt;&gt;= 1; } return ret; } } A, ans; string a[55]; bool check(int x, int y) { for(int i = 2; i &lt;= a[x].size(); ++i) { string suffix = a[x].substr(a[x].size() - i); string prefix = a[y].substr(0, i); if(suffix == prefix) return true; } return false; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); set&lt;string&gt; s; for(int i = 0; i &lt; n; ++i) { char buf[20]; scanf(&quot;%s&quot;, buf); s.insert(buf); } n = 0; for(auto &amp;str : s) a[n++] = str; A.init(n, n); for(int i = 0; i &lt; n; ++i) for(int j = 0; j &lt; n; ++j) A.mat[i][j] = check(i, j); // prln(check(0, 0)); // for(int i = 0; i &lt; n; ++i){ // for(int j = 0; j &lt; n; ++j) // printf(&quot;(%s, %s): %d\n&quot;, a[i].c_str(), a[j].c_str(), A.mat[i][j]); // } ans.init(1, n); for(int i = 0; i &lt; n; ++i) ans.mat[0][i] = 1; ans = ans * (A ^ m - 1); int sum = 0; for(int i = 0; i &lt; n; ++i) if((sum += ans.mat[0][i]) &gt;= MOD) sum -= MOD; printf(&quot;%d\n&quot;, sum); } return 0; }]]></content>
      <categories>
        <category>动态规划</category>
        <category>矩阵优化</category>
      </categories>
      <tags>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5323 Solve this interesting problem（dfs）]]></title>
    <url>%2F2016%2F03%2F28%2FHDU%205323%20Solve%20this%20interesting%20problem%EF%BC%88dfs%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $给定总区间为[0, N]的线段树的一个区间[L, R]，0\le L，R\le10^9，\frac{L}{R-L+1} \leq 2015$$求最小的包含这个[L, R]的线段树的N$ 分析： $由于线段树每向上合并一次，区间大小就加倍，显然当L=0时的最小R就是答案$$设合并次数为x，即\frac{L}{2^x(R-L+1)}=0\le 1，2^x \ge \frac{L}{R-L+1}$$由\frac{L}{R-L+1} \leq 2015近似知：2^x \le 2015\Rightarrow x\le 11$$由于要枚举在左子树、右子树的左儿子和右儿子，枚举量是O(4^{11})$$加上最优性剪枝，显然这个复杂度是可以通过的$$看图可以发现答案在R’\le 2R内$ 代码： // // Created by TaoSama on 2016-03-22 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int L, R; void dfs(int l, int r, int&amp; ans) { if(l &lt; 0 || r &gt;= ans || r &gt; 2 * R) return; if(!l) { ans = min(ans, r); return; } dfs(2 * l - r - 1, r, ans); dfs(2 * l - r - 2, r, ans); dfs(l, -l + 2 * r, ans); dfs(l, -l + 2 * r + 1, ans); } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); while(scanf(&quot;%d%d&quot;, &amp;L, &amp;R) == 2) { int ans = INF; dfs(L, R, ans); if(ans == INF) ans = -1; printf(&quot;%d\n&quot;, ans); } return 0; }]]></content>
      <categories>
        <category>暴力</category>
        <category>搜索</category>
        <category>dfs/bfs</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4651 Partition（五边形数）]]></title>
    <url>%2F2016%2F03%2F28%2FHDU%204651%20Partition%EF%BC%88%E4%BA%94%E8%BE%B9%E5%BD%A2%E6%95%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N\le 10^5，求整数N的划分数是多少，答案对10^9+7取模$ 分析： $这个东西就是五边形数，当然n^{1.5}的dp也可以，太神了不懂$$所以直接公式搞就好辣，时间复杂度也是O(n^{1.5})$$f(0)=1，f(n)=\displaystyle\sum_{k=1}(-1)^{k+1}\cdot \left( f(n-{k(3k-1)\over 2}) + f(n-{k(3k+1)\over 2})\right)$ 代码： // // Created by TaoSama on 2016-03-11 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:1024000000,1024000000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; //五边形数: f(n) = sum( (-1)^(k+1) [ P(n-k(3k-1)/2) + P(n-k(3k+1)/2)] ) int n, f[N]; void add(int&amp; x, int y) { x += y; x %= MOD; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); f[0] = 1; for(int i = 1; i &lt;= 1e5; ++i) { int sum = 0, delta = 1; for(int j = 1; ; ++j, delta = -delta) { int x = i - j * (3 * j - 1) / 2; int y = i - j * (3 * j + 1) / 2; if(x &lt; 0 &amp;&amp; y &lt; 0) break; if(x &gt;= 0) add(sum, delta * f[x]); if(y &gt;= 0) add(sum, delta * f[y]); } f[i] = (sum % MOD + MOD) % MOD; } int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { int n; scanf(&quot;%d&quot;, &amp;n); printf(&quot;%d\n&quot;, f[n]); } return 0; }]]></content>
      <categories>
        <category>数学</category>
        <category>组合数学</category>
      </categories>
      <tags>
        <tag>五边形数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4650 Minimum Average Weight Path（floyd）]]></title>
    <url>%2F2016%2F03%2F28%2FHDU%204650%20Minimum%20Average%20Weight%20Path%EF%BC%88floyd%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N\le 100，M\le 10^4，N个点，M条边的图，无重边，可能有自环$$所有节点对(u, v)的min\{\frac{dis(u, v)}{len(u, v)}\}，不连通输出NO$ 分析： $floyd求一发连通性，判断NO$$然后f[k][i][j]:=i到j长度为k的最短路$$floyd的循环顺序是可以换的嘛，把i拿到最外面去枚举，这样可以复用数组$$就变成f[k][j]:=i出发，长度为k到j的最短路$$然后更新答案，注意由于有环，那么判断可不可以经过环$$经过的话，环的答案如果比较小，显然可以无限绕环来逼近环长（极限思想嘛）$$时间复杂度O(n^4)$ 代码： // // Created by TaoSama on 2016-03-12 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:1024000000,1024000000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e2 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, m; int f[N][N], g[N][N], con[N][N]; double ans[N][N]; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) == 2) { memset(g, 0x3f, sizeof g); memset(con, 0, sizeof con); for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= n; ++j) ans[i][j] = 1e18; for(int i = 1; i &lt;= m; ++i) { int x, y, c; scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;c); g[x][y] = c; con[x][y] = 1; } for(int k = 1; k &lt;= n; ++k) for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= n; ++j) con[i][j] |= con[i][k] &amp; con[k][j]; for(int i = 1; i &lt;= n; ++i) { memset(f, 0x3f, sizeof f); f[0][i] = 0; for(int l = 1; l &lt;= n; ++l) for(int k = 1; k &lt;= n; ++k) for(int j = 1; j &lt;= n; ++j) f[l][j] = min(f[l][j], f[l - 1][k] + g[k][j]); for(int l = 1; l &lt;= n; ++l) for(int j = 1; j &lt;= n; ++j) ans[i][j] = min(ans[i][j], f[l][j] * 1. / l); } for(int i = 1; i &lt;= n; ++i) { for(int j = 1; j &lt;= n; ++j) { if(!con[i][j]) printf(&quot;NO%c&quot;, &quot; \n&quot;[j == n]); else { for(int k = 1; k &lt;= n; ++k) if(con[i][k] &amp; con[k][j]) ans[i][j] = min(ans[i][j], ans[k][k]); printf(&quot;%.3f%c&quot;, ans[i][j], &quot; \n&quot;[j == n]); } } } } return 0; }]]></content>
      <categories>
        <category>图论</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>floyd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4649 Professor Tian（概率dp）]]></title>
    <url>%2F2016%2F03%2F28%2FHDU%204649%20Professor%20Tian%EF%BC%88%E6%A6%82%E7%8E%87dp%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N\le 200个运算符的式子，给定每个运算符和数字A_i\le 2^{20}$$但是它俩有可能一起消失，消失的概率是p_i$$问算式的期望是多少$ 分析： $期望dp很多时候都可以转化成概率dp做的$$暴力作法f[i][2^{20}]:=前i个数，答案是j的期望，可以水过去$$其实按位就可以了，f[i][21][2]:=前i个数，答案j位是k的期望$$然后算出来，答案统计一下就好了$$时间复杂度O(n*20)$ 代码： // // Created by TaoSama on 2016-03-11 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:1024000000,1024000000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, a[205]; char s[205]; double p[205], f[205][21][2]; //前i个数运算的值, j位为0/1的概率 int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); while(scanf(&quot;%d&quot;, &amp;n) == 1) { ++n; for(int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, a + i); for(int i = 2; i &lt;= n; ++i) scanf(&quot; %c&quot;, s + i); for(int i = 2; i &lt;= n; ++i) scanf(&quot;%lf&quot;, p + i); memset(f, 0, sizeof f); for(int i = 0; i &lt; 21; ++i) f[1][i][a[1] &gt;&gt; i &amp; 1] = 1; for(int i = 2; i &lt;= n; ++i) { for(int j = 0; j &lt; 21; ++j) { int b = a[i] &gt;&gt; j &amp; 1; for(int k = 0; k &lt; 2; ++k) { f[i][j][k] += f[i - 1][j][k] * p[i]; if(s[i] == &#39;^&#39;) f[i][j][k ^ b] += f[i - 1][j][k] * (1 - p[i]); else if(s[i] == &#39;&amp;&#39;) f[i][j][k &amp; b] += f[i - 1][j][k] * (1 - p[i]); else f[i][j][k | b] += f[i - 1][j][k] * (1 - p[i]); } } } double ans = 0; for(int i = 0; i &lt; 21; ++i) ans += f[n][i][1] * (1 &lt;&lt; i); static int kase = 0; printf(&quot;Case %d:\n%.6f\n&quot;, ++kase, ans); } return 0; }]]></content>
      <categories>
        <category>动态规划</category>
        <category>概率/期望dp</category>
      </categories>
      <tags>
        <tag>概率dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4643 GSM（中垂线）]]></title>
    <url>%2F2016%2F03%2F28%2FHDU%204643%20GSM%EF%BC%88%E4%B8%AD%E5%9E%82%E7%BA%BF%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N，M\le 50，N个城市，M个基站，每个城市从最近的基站接收信号，K个询问$$u v：u\to v的直线路径中切换了几次基站$ 分析： $线段中垂线上的点到线段树两端点的距离相等$$所以可以求出所有的基站对的中垂线，然后求出与u\to v的交点$$看交点在不在线段上且是不是最近的基站，合法交点个数就是答案$$时间复杂度O(kn^2)，貌似这题k不大，大力出奇迹$ $黑点是基站的管辖范围，这样形成一个V图$$标程给了一个利用V图思想，二分u\to v中点找边界的做法，看2边各有几个$$每次看它们在不在一个颜色的区域，在就是0，不在就二分$$显然边界个数就是答案$ 暴力代码： // // Created by TaoSama on 2016-03-12 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:1024000000,1024000000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; const double EPS = 1e-7; int sgn(double x) { return x &lt; -EPS ? -1 : x &gt; EPS; } struct Point { double x, y; void read() {scanf(&quot;%lf%lf&quot;, &amp;x, &amp;y);} Point operator+(const Point&amp; p) { return {x + p.x, y + p.y}; } Point operator-(const Point&amp; p) { return {x - p.x, y - p.y}; } double operator*(const Point&amp; p) { return x * p.x + y * p.y; } Point operator*(const double&amp; t) { return {x * t, y * t}; } double operator^(const Point&amp; p) { return x * p.y - y * p.x; } double length() { return hypot(x, y); } } a[55], b[55]; typedef Point Vector; Point getLineIntersection(Point p, Vector v, Point q, Vector w) { Vector u = p - q; double t = (w ^ u) / (v ^ w); return p + v * t; } bool onSeg(Point p, Point a, Point b) { return !sgn((a - p) ^ (b - p)) &amp;&amp; sgn((a - p) * (b - p)) &lt; 0; } struct Line { Point p; Vector v; } l[55][55]; Line getMidLine(Point a, Point b) { Point m = (a + b) * 0.5; Vector u = b - a; return {m, { -u.y, u.x}}; } int n, m; bool check(Point o, double d) { for(int i = 1; i &lt;= m; ++i) if(sgn(d - (o - b[i]).length()) &gt; 0) return false; return true; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) == 2) { for(int i = 1; i &lt;= n; ++i) a[i].read(); for(int i = 1; i &lt;= m; ++i) { b[i].read(); for(int j = 1; j &lt; i; ++j) l[i][j] = getMidLine(b[i], b[j]); } int q; scanf(&quot;%d&quot;, &amp;q); while(q--) { int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); int ans = 0; for(int i = 1; i &lt;= m; ++i) { for(int j = 1; j &lt; i; ++j) { if(!sgn(l[i][j].v ^ (a[v] - a[u]))) continue; Point o = getLineIntersection(l[i][j].p, l[i][j].v, a[u], a[v] - a[u]); if(onSeg(o, a[u], a[v])) ans += check(o, (o - b[i]).length()); } } printf(&quot;%d\n&quot;, ans); } } return 0; }]]></content>
      <categories>
        <category>计算几何</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
        <tag>Voronoi图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVA 11402 Ahoy, Pirates!（线段树标记合并）]]></title>
    <url>%2F2016%2F03%2F28%2FUVA%2011402%20Ahoy%2C%20Pirates!%EF%BC%88%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%A0%87%E8%AE%B0%E5%90%88%E5%B9%B6%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $读入比较麻烦，N\le 1.1\times 10^6的01串，四种操作$$F a b：[a, b]变为1$$E a b：[a, b]变为0$$I a b：[a, b]01翻转，即0变1，1变0$$S a b：[a, b]中1有多少个$$输出S操作的结果，输出也很恶心$ 分析： $pushDown的时候可能儿子也有标记，这时候合并一下就好了$$get这种写标记合并函数的新姿势，其它都是裸的区间更新，区间查询$$别忘记更新的时候，合并标记哦$$时间复杂度O(nlogn)$ 代码： // // Created by TaoSama on 2016-03-26 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1.1e6 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; string str; struct Node { int l, r; int sum; Node() {} Node(int l, int r): l(l), r(r) {} int len() { return r - l + 1; } void set(int v) { if(v == -1) return; if(v == 2) sum = len() - sum; else sum = len() * v; } } dat[N &lt;&lt; 2]; int tag[N &lt;&lt; 2]; void pushUp(int rt) { dat[rt].sum = dat[rt &lt;&lt; 1].sum + dat[rt &lt;&lt; 1 | 1].sum; } void combineTag(int fa, int&amp; son) { if(fa == 2) { if(son == -1) son = 2; else if(son == 2) son = -1; else son ^= 1; // switch 0, 1 } else son = fa; //set 0, 1 } void pushDown(int rt) { if(tag[rt] == -1) return; int ls = rt &lt;&lt; 1, rs = ls | 1; dat[ls].set(tag[rt]); dat[rs].set(tag[rt]); combineTag(tag[rt], tag[ls]); combineTag(tag[rt], tag[rs]); tag[rt] = -1; } void build(int l, int r, int rt) { dat[rt] = Node(l, r); tag[rt] = -1; if(l == r) { dat[rt].sum = str[l] - &#39;0&#39;; return; } int m = l + r &gt;&gt; 1; build(l, m, rt &lt;&lt; 1); build(m + 1, r, rt &lt;&lt; 1 | 1); pushUp(rt); } void update(int L, int R, int v, int rt) { if(L &lt;= dat[rt].l &amp;&amp; dat[rt].r &lt;= R) { dat[rt].set(v); combineTag(v, tag[rt]); return; } pushDown(rt); int m = dat[rt].l + dat[rt].r &gt;&gt; 1; if(L &lt;= m) update(L, R, v, rt &lt;&lt; 1); if(R &gt; m) update(L, R, v, rt &lt;&lt; 1 | 1); pushUp(rt); } int query(int L, int R, int rt) { if(L &lt;= dat[rt].l &amp;&amp; dat[rt].r &lt;= R) return dat[rt].sum; pushDown(rt); int m = dat[rt].l + dat[rt].r &gt;&gt; 1; int ret = 0; if(L &lt;= m) ret += query(L, R, rt &lt;&lt; 1); if(R &gt; m) ret += query(L, R, rt &lt;&lt; 1 | 1); return ret; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { str.clear(); int m; scanf(&quot;%d&quot;, &amp;m); while(m--) { int cnt; char buf[105]; scanf(&quot;%d%s&quot;, &amp;cnt, buf); while(cnt--) str += buf; } build(0, str.size() - 1, 1); int q; scanf(&quot;%d&quot;, &amp;q); int qs = 0; static int kase = 0; printf(&quot;Case %d:\n&quot;, ++kase); while(q--) { char op[2]; int a, b; scanf(&quot;%s%d%d&quot;, op, &amp;a, &amp;b); if(*op == &#39;F&#39;) update(a, b, 1, 1); else if(*op == &#39;E&#39;) update(a, b, 0, 1); else if(*op == &#39;I&#39;) update(a, b, 2, 1); else printf(&quot;Q%d: %d\n&quot;, ++qs, query(a, b, 1)); } } return 0; }]]></content>
      <categories>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>标记合并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVA 10771 Barbarian tribes（思维 | 线段树模拟约瑟夫环）]]></title>
    <url>%2F2016%2F03%2F28%2FUVA%2010771%20Barbarian%20tribes%EF%BC%88%E6%80%9D%E7%BB%B4%20%20%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%A8%A1%E6%8B%9F%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $1\le N + M\le 2000，1\le K\le 1000，N+M个人围成环，前N为G，后M为K$$现在每轮：$$每K个各杀1个，杀2个，添加一个到第2个死的位置上，相同加G，不同加K$$也就是说每轮死1个，N+M-1轮后只剩1个，问是G还是K$ 分析： $线段树求K-th number的姿势直接暴力模拟$$需要注意的是，1个死了，当前名次要-1，1个没死不动就好$$时间复杂度为O((N+M)log(N+M))，跑了1.6s$$也就是说这题起码有1W组case。。。$$你特么不说一声，让我浪费时间写链表模拟。。O((N+M)K)直接T成sb了$ $其实有O(1)解法，设G为0，K为1，GG和KK变G，GK和KG变K$$这其实就是异或，然后异或满足交换律，显然有奇数个1答案才是K$$所以一行代码：$ puts(M &amp; 1 ? &quot;Keka&quot; : &quot;Gared&quot;); 线段树模拟代码： // // Created by TaoSama on 2016-03-26 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, m, k; int val[N &lt;&lt; 2], sum[N &lt;&lt; 2]; void build(int l, int r, int rt) { sum[rt] = r - l + 1; if(l == r) { val[rt] = l &lt;= n ? 1 : 2; return; } int m = l + r &gt;&gt; 1; build(l, m, rt &lt;&lt; 1); build(m + 1, r, rt &lt;&lt; 1 | 1); } pair&lt;int, int&gt; query(int k, int l, int r, int rt) { --sum[rt]; if(l == r) return make_pair(l, val[rt]); int m = l + r &gt;&gt; 1; if(sum[rt &lt;&lt; 1] &gt;= k) return query(k, l, m, rt &lt;&lt; 1); return query(k - sum[rt &lt;&lt; 1], m + 1, r, rt &lt;&lt; 1 | 1); } void update(int o, int v, int l, int r, int rt) { if(l == r) { val[rt] = v; sum[rt] = 1; return; } int m = l + r &gt;&gt; 1; if(o &lt;= m) update(o, v, l, m, rt &lt;&lt; 1); else update(o, v, m + 1, r, rt &lt;&lt; 1 | 1); sum[rt] = sum[rt &lt;&lt; 1] + sum[rt &lt;&lt; 1 | 1]; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); while(scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k) == 3 &amp;&amp; (n || m || k)) { build(1, n + m, 1); n += m; int rk = k; for(int i = 1; i &lt;= n - 1; ++i) { int lft = n - i; int last = query(rk, 1, n, 1).second; rk = (rk - 1 + k) % lft; if(rk == 0) rk = lft; pair&lt;int, int&gt; now = query(rk, 1, n, 1); int v = last == now.second ? 1 : 2; update(now.first, v, 1, n, 1); rk = (rk + k) % lft; if(rk == 0) rk = lft; } int ans = query(1, 1, n, 1).second; puts(ans == 1 ? &quot;Gared&quot; : &quot;Keka&quot;); } return 0; }]]></content>
      <categories>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>约瑟夫环</tag>
        <tag>思维</tag>
        <tag>异或</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CDOJ 1051 Eggs broken（期望dp）]]></title>
    <url>%2F2016%2F03%2F28%2FCDOJ%201051%20Eggs%20broken%EF%BC%88%E6%9C%9F%E6%9C%9Bdp%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $1\le N\le 1000层楼，1\le K\le 15个鸡蛋，选择楼投鸡蛋，已知N层楼必碎$$假设鸡蛋在[1, N]碎均匀分布，问知道在哪层碎的最小期望投掷次数$ 分析： $期望dp，f[n][k]:=n层楼，i个鸡蛋的最小期望次数$$显然边界是f[1][k]=0，1个的时候只能试蛋，f[n][1]=((1+n-1)(n-1)/2+(n-1))/n$$我们知道鸡蛋的多的时候，肯定二分嘛，少的时候先二分最后一个试蛋嘛（从下往上挨个来）$$这样太难写了，反正求最小期望次数，直接暴力枚举在哪一层投，取最小的$$如果当前投i碎了，那么就变成了子问题1\sim i，k-1个蛋投，即f[i][k-1]$$没碎，继续在上面投，看成子问题，1\sim n-i，k个蛋，即f[n-i][k]$$再乘上各自的概率，i/n和(n-i)/n$$这样复杂度是可以接受的，为O(n^2k)$ 代码： // // Created by TaoSama on 2016-03-28 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e3 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; double f[N][20]; bool vis[N][20]; double dfs(int n, int k) { double&amp; ret = f[n][k]; if(vis[n][k]) return ret; vis[n][k] = 1; if(n == 1) return ret = 0; if(k == 1) return ret = (1. * n * (n - 1) / 2 + n - 1) / n; ret = INF; for(int i = 1; i &lt; n; ++i) ret = min(ret, dfs(i, k - 1) * i / n + dfs(n - i, k) * (n - i) / n + 1); return ret; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); int n, k; scanf(&quot;%d%d&quot;, &amp;n, &amp;k); printf(&quot;%.5f\n&quot;, dfs(n, k)); return 0; }]]></content>
      <categories>
        <category>动态规划</category>
        <category>概率/期望dp</category>
      </categories>
      <tags>
        <tag>期望dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4642 Fliping game（博弈）]]></title>
    <url>%2F2016%2F03%2F26%2FHDU%204642%20Fliping%20game%EF%BC%88%E5%8D%9A%E5%BC%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N, M\le 100，N\times M的棋盘，每个值为0或者1$$A和B玩游戏，每次选择一个矩形区域把里面的01翻转，但要求选择的左上角必须为1$$谁不能操作了谁输，假设2个人采取最优策略，输出胜者$ 分析： $可以看出，每次翻转都会翻动最右下角的格子$$如果右下角刚开始为1，那么先手的人每次都翻动右下角的，使该格子变为0$$后手的翻其他矩形，肯定会使得最右下角的格子变为1$$这样先手每次都翻右下角这个格子，最后肯定是后手败$$如果右下角刚开始为0，同理后手可以通过这个策略来使自己必胜$$所以A_{nm}为1先手胜，否则后手胜$$时间复杂度为O(nm)$ 代码： // // Created by TaoSama on 2016-03-25 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, m; int a[105][105]; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= m; ++j) scanf(&quot;%d&quot;, a[i] + j); puts(a[n][m] ? &quot;Alice&quot; : &quot;Bob&quot;); } return 0; }]]></content>
      <categories>
        <category>数学</category>
        <category>博弈</category>
      </categories>
      <tags>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4638 Group（离线思想、BIT）]]></title>
    <url>%2F2016%2F03%2F26%2FHDU%204638%20Group%EF%BC%88%E7%A6%BB%E7%BA%BF%E6%80%9D%E6%83%B3%E3%80%81BIT%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N, Q\le 10^5，1\sim N的序列，Q次询问$$现有分组要求：组内的人id必须连续，假设人数为k，则价值为k^2$$询问区间[L,R]，问区间能获得的最大价值的组数是多少个$ 分析： $由于价值是平方，显然让每组人数达到最多，从大到小来贪心$$问题就转化成了，区间最少能分几组$$思考一下对于x这个数，显然只能向x-1，x+1连边，我们发现组数=区间大小-边数$$经典离线套路题了，询问右端点排序$$从左往右扫描每个数A_i（相当于固定了右端点）$$把A_i-1和A_i+1的位置添加到BIT中$$发现所有以i为右端点的询问[L,i]只要查询[L,i]的和就好了$$然后这个和就是我们想要的，ans(L,R)=R-L+1-sum(L,i)$$这里其实把BIT倒过来就可以完成了，向前更新，向后查询$$时间复杂度为O(nlogn)$ 代码： // // Created by TaoSama on 2016-03-25 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; struct BIT { int n, b[N]; void init(int _n) { n = _n; memset(b, 0, sizeof b); } void add(int i, int v) { for(; i; i -= i &amp; -i) b[i] += v; } int sum(int i) { int ret = 0; for(; i &lt;= n; i += i &amp; -i) ret += b[i]; return ret; } } bit; int n, q; int a[N], wh[N], ans[N]; vector&lt;pair&lt;int, int&gt; &gt; qs[N]; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%d%d&quot;, &amp;n, &amp;q); for(int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, a + i); for(int i = 1; i &lt;= n; ++i) qs[i].clear(); for(int i = 1; i &lt;= q; ++i) { int l, r; scanf(&quot;%d%d&quot;, &amp;l, &amp;r); qs[r].push_back({l, i}); } bit.init(n); memset(wh, 0, sizeof wh); for(int i = 1; i &lt;= n; ++i) { int x = a[i]; if(wh[x - 1]) bit.add(wh[x - 1], 1); if(wh[x + 1]) bit.add(wh[x + 1], 1); wh[x] = i; for(auto&amp; q : qs[i]) ans[q.second] = i - q.first + 1 - bit.sum(q.first); } for(int i = 1; i &lt;= q; ++i) printf(&quot;%d\n&quot;, ans[i]); } return 0; }]]></content>
      <categories>
        <category>思维</category>
        <category>离线思想</category>
      </categories>
      <tags>
        <tag>BIT</tag>
        <tag>离线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4635 Strongly connected（scc缩点）]]></title>
    <url>%2F2016%2F03%2F26%2FHDU%204635%20Strongly%20connected%EF%BC%88scc%E7%BC%A9%E7%82%B9%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N, M\le 10^5的简单有向图，无重边自环$$问最多添加多少条边使得这个图不成为强联通图，如果已经是输出-1$ 分析： $参考出题人题解啦$$图肯定可以分成两个部X和Y，只有X\to Y的边没有T\to X的边这样图就不强联通$$那么要使得边数尽可能的多，则X部肯定是一个完全图，Y部也是$$同时X部中每个点到Y部的每个点都有一条边$$假设X部有x个点，Y部有y个点，有x+y=N，同时边数E=xy+x(x-1)+y(y-1)$$整理得E=N^2-N-xy，当x+y为定值时，二者越接近，xy越大$$要使得边数最多，那么X部和Y部的点数的个数差距就要越大$$所以首先对于给定的有向图scc缩点$$对于缩点后的每个点，如果它的出度或者入度为0，那么它才有可能成为X部或者Y部$$所以只要求缩点之后的出度或者入度为0的点中，包含节点数最少的那个点$$令它为一个部，其它所有点加起来做另一个部，就可以得到最多边数的图了$$ans = E-M$$时间复杂度为O(N+M)$ 代码： // // Created by TaoSama on 2016-03-25 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; vector&lt;int&gt; G[N]; int dfn[N], low[N], in[N], id[N], scc, dfsNum; int stk[N], top; void tarjan(int u) { dfn[u] = low[u] = ++dfsNum; stk[++top] = u; in[u] = true; for(int v : G[u]) { if(!dfn[v]) { tarjan(v); low[u] = min(low[u], low[v]); } else if(in[v]) low[u] = min(low[u], dfn[v]); } if(low[u] == dfn[u]) { ++scc; while(true) { int v = stk[top--]; in[v] = false; id[v] = scc; if(v == u) break; } } } int n, m; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= n; ++i) G[i].clear(); for(int i = 1; i &lt;= m; ++i) { int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); G[u].push_back(v); } scc = dfsNum = 0; memset(dfn, 0, sizeof dfn); for(int i = 1; i &lt;= n; ++i) if(!dfn[i]) tarjan(i); static int kase = 0; if(scc == 1) {printf(&quot;Case %d: -1\n&quot;, ++kase); continue;} vector&lt;bool&gt; in(N, 0), out(N, 0); for(int i = 1; i &lt;= n; ++i) { int u = id[i]; for(int j : G[i]) { int v = id[j]; if(u == v) continue; out[u] = in[v] = true; } } vector&lt;int&gt; cnt(N, 0); for(int i = 1; i &lt;= n; ++i) ++cnt[id[i]]; int x = INF; for(int i = 1; i &lt;= scc; ++i) if(!in[i] || !out[i]) x = min(x, cnt[i]); int y = n - x; long long ans = 1LL * n * n - n - 1LL * x * y - m; printf(&quot;Case %d: %I64d\n&quot;, ++kase, ans); } return 0; }]]></content>
      <categories>
        <category>图论</category>
        <category>连通图</category>
      </categories>
      <tags>
        <tag>scc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网易游戏一面]]></title>
    <url>%2F2016%2F03%2F24%2F%E7%BD%91%E6%98%93%E6%B8%B8%E6%88%8F%E4%B8%80%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[前言 打$offer$收割编程赛，结果拿到了据说比$M\$、GG$还难进的网易游戏的面试机会非常尴尬啊，前几天上牛客看了一大波计网的东西，本想前一晚（昨晚）再看一遍cpp primer的蓝儿搞博客站内搜索搞的太久直接爆炸，没看，结局是今天炸锅 各种问题总的来说，把学的基础全部问了一遍，简历没写项目，就没问我这个 C++语言部分 int、long，long long位数，int*位数反正根据编译器位数和操作系统位数答一答就好了 你用过c++ stl么？讲道理，ACM选手天天用，顺序容器、关联容器总的开始，然后我就巴拉巴拉介绍一堆 c++ stl里map与unordered_map的区别？- - 也许面试官不知道ACM是干啥的，反正基本区别就是实现了，一个是RBTree，另一个是hashtable空间复杂度、时间复杂度的区别，BST有序啥的 快排是咋实现的？我会的东西当然说一点了，均摊复杂度$O(nlogn)$，最坏$O(n^2)$还多说了轴值选择对于复杂度的影响，以及std::sort内省式排序的实现 讲讲shared_ptr？第一次炸锅在这里，我明明知道会问auto ptr的东西，还tm再晚都一点没看cpp primer然后只能凭借一年前看的印象和经验答了，讲了下有引用计数，自动析构，。(可能有内存池管理啥的)然后就没啥说的了 虚函数是咋实现多态的？基类定义，派生类重载啦，然后说了下细节，虚表啥的，(这里好虚都忘的差不多了 派生类如何调用基类的函数？我忘记可以通过域访问符了，就答了强转，非常尴尬，说了下切片啥的，估计面试官可能忘了切片吧 dynamic_cast和static_cast的区别真的太久远了，实在是不记得了，就讲道理了一下 堆和栈的区别，不是标准库的那个就讲了堆存全局变量，静态变量，会初始化栈上局部变量，还有函数栈帧啥的，详细问了我栈我懵比所知有限啊，其实堆知道的多点吧，可是问的我栈。 好像还有别的记不起来了 数据库 事务和啥啥啥的区别忘记了，反正数据库全忘光，第二次炸锅 操作系统 进程线程区别，多线程编程 前者就讲道理答了一波，后者同步互斥啥的 计网 tcp和udp的区别这个大家都会吧 炫酷的问题：如果同时使用tcp和udp通过80端口发数据，会不会炸第三次炸锅，我说不行，讲道理答了一波，事后问同学发现炸了 设计模式 设计模式都有啥？我就记得工厂、单例、观察者了， 讲讲工厂模式我实在不知道具体咋说，其实我还是熟悉单例模式 - -然后就照着数据看过的一点点cocos2d-x的源码讲道理了一波 算法题 $N$大小的数组，只有$1\sim N-1$的数，只有一个重复出现了，找出来 显然的计数排序嘛 然后爆炸，想太多了（难题做多了？），然后想到鸽笼原理和异或发现没法做 其实之前有人跟我说个异或解法的 其实数组和减去$1\sim N-1$的和就完了，应该果断说不知道让提示的 应该意识到想歪了就不可能想出来的，唉，这彻底炸锅了 我想问的 就随便问了下网易游戏的情况，以及游戏咋开发的，你们有没有自己的引擎这种废话，面试官很健谈啊 我今天答的怎么样，你答的挺好的，（这是说你妥妥的跪了么） 后记第一次面试攒经验吧，专业课还是很重要的，- - 多看书吧，既然不能写项目就多看书吧，书才是知识的源泉啊]]></content>
      <categories>
        <category>Doing</category>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4631 Sad Love Story（离线思想、分治）]]></title>
    <url>%2F2016%2F03%2F23%2FHDU%204631%20Sad%20Love%20Story%EF%BC%88%E7%A6%BB%E7%BA%BF%E6%80%9D%E6%83%B3%E3%80%81%E5%88%86%E6%B2%BB%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N\le 5\times 10^5，给定二维平面上N个点，定义距离为欧氏距离的平方$$挨个加入每个点，对于i&gt;1的所有点，求[1,i]的最近点对距离，输出这些距离和$ 分析： $考虑离线，倒着做，求一次最近点对，假设得到的点为(p, q)，p &lt; q$$那么显然[q,n]的答案都是dis(p,q)$$去掉[q,n]这些点，做[1,q-1]的部分，成为子问题$$由于是随机数据，每次问题规模下降1/3，所以总体复杂度大概是O(nlog^2n)$ $其实还可以直接暴力，挨个添加点到set，设当前答案为d$$对于每个点，设坐标为(x,y)，暴力查询横坐标在[x-d, x+d]范围的点$$由于随机数据，答案下降的很快，所以跑的飞快$$时间复杂度大概在O(nlogn)$ 第一种解法代码： // // Created by TaoSama on 2016-03-18 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:1024000000,1024000000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 5e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n; typedef pair&lt;int, int&gt; P; typedef long long LL; P a[N]; int id[N]; pair&lt;LL, P&gt; dfs(int l, int r) { if(l == r) return {~0ull &gt;&gt; 2, { -1, -1}}; int m = l + r &gt;&gt; 1; LL x = a[id[m]].first; auto ret = min(dfs(l, m), dfs(m + 1, r)); inplace_merge(id + l, id + m + 1, id + r + 1, [](int x, int y) { return a[x].second &lt; a[y].second; }); vector&lt;int&gt; v; for(int i = l; i &lt;= r; ++i) { int p = id[i]; if((a[p].first - x) * (a[p].first - x) &gt;= ret.first) continue; for(int j = 0; j &lt; v.size(); ++j) { int q = v[v.size() - 1 - j]; LL dy = a[p].second - a[q].second; if(dy * dy &gt;= ret.first) break; LL dx = a[p].first - a[q].first; LL d = dx * dx + dy * dy; if(d &lt; ret.first) ret = {d, {p, q}}; } v.push_back(p); } return ret; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%d&quot;, &amp;n); int a1, b1, c1, a2, b2, c2; scanf(&quot;%d%d%d&quot;, &amp;a1, &amp;b1, &amp;c1); scanf(&quot;%d%d%d&quot;, &amp;a2, &amp;b2, &amp;c2); for(int i = 1; i &lt;= n; ++i) { a[i].first = (1LL * a1 * a[i - 1].first + b1) % c1; a[i].second = (1LL * a2 * a[i - 1].second + b2) % c2; } LL ans = 0; for(int r = n; r &gt; 1;) { for(int i = 1; i &lt;= r; ++i) id[i] = i; sort(id + 1, id + 1 + r, [](int x, int y) { return a[x] &lt; a[y]; }); auto cp = dfs(1, r); int nxt = max(cp.second.first, cp.second.second); ans += cp.first * (r - nxt + 1); r = nxt - 1; } printf(&quot;%I64d\n&quot;, ans); } return 0; }]]></content>
      <categories>
        <category>思维</category>
        <category>分治</category>
      </categories>
      <tags>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[平面最近点对问题]]></title>
    <url>%2F2016%2F03%2F23%2F%E5%B9%B3%E9%9D%A2%E6%9C%80%E8%BF%91%E7%82%B9%E5%AF%B9%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题简述 $给定二维平面上N个点，定义距离为欧氏距离$$对于N个点组成的所有点对(i, j)，i\ne j, i, j\in[1,N]$$求最小的(i,j)点对距离$ 暴力求解 显然暴力求解的时间复杂度是$O(n^2)$的，是否可以优化呢？存在带$log$的算法么？考虑一下分治法 分治法 由主定理我们可以知道：$T(n)=2T(n/2)+O(n)\Rightarrow O(nlogn)$ 这就需要我们尽可能的将原问题划分成2个相等的子问题 并且划分2个子问题，合并2个子问题，或者处理1个子问题对另1个子问题的影响不能超过$O(n)$ 划分如果将所有的点按照二维偏序（即横坐标$x$为第一关键字，纵坐标$y$为第二关键字）排序那么通过中间的那个点就可以将所有点划分成均等的2部分了这样我们以$O(nlogn)-O(1)$的时间复杂度做到了这一点 递归处理子问题假设均等的2部分的子问题的答案分别是$d_1,d_2$，显然当前答案就是$d=min(d_1,d_2)$$(1)$类型的答案为$d$，但是我们发现$(2)$类型的答案很有可能$\le d$即中间那个点，在它两边的点形成的点对很有可能也会是答案也就说1个子问题对另1个子问题产生了影响，接下来思考如何计算这一部分的答案 子问题间的影响 可能产生影响的点对于中间点p来说，显然左右横坐标距离d以内的才是要考虑的点即若p点坐标为$(x,y)$，那么要考虑的点的横坐标$x-d&lt;x’&lt;x+d$，其它的点显然不能产生影响找到了这些可能产生影响的点后，点最坏有$n$个，如果一一枚举还是$O(n^2)$难道就逃脱不了$n^2$的命运了么？ 能对一个点贡献答案的点对于其中一个点$p_1$，能产生答案的点只考虑$y$比它大的那部分（这样一对点不会重复枚举）即若$p_1$点坐标为$(x,y)$，那么要考虑的点的横坐标$x-d&lt;x’&lt;x+d$，纵坐标$y \le y’ \le y +d$也就是说对$p_1$贡献答案的点应该就是如图那样的矩形部分 矩形内至多有6个点我说矩形里至多有6个点你信不信！我们来证明一下：、将矩形$R$的长为$2d$的边三等分，宽为$d$的边二等分这样我们得到了6个$\frac{2d}{3}\times \frac{d}{2}$的小矩形假设位于中轴线两侧的4个小矩形中有多于2个点，设$u，v$是位于同一小矩形中的两个点，则$d(u,v)=\sqrt{(x_u - x_v) ^ 2 + (y_u-y_v) ^ 2 }\le \sqrt{(d / 2) ^ 2 + (2d / 3) ^ 2} = \sqrt{25 / 36 * d ^ 2}=\frac{5d}{6} &lt; d$因为递归已经算出两边子问题解为最优为$d$了，这显然是矛盾的，所以每个小矩形最多只能有1个点但是跨越中轴线的2个小矩形中可能会有多于2个点，但我们发现它们只能在中轴线上不然就与其他4个小矩形中的点构成了小于$d$的点对了，但是由于合法性最坏的点对如下图：这样最多就只有6个点了，重合点是非法的，因为会被分到2边，然后违法了$d$是最优解的条件$\blacksquare$ 时间复杂度分析有一个对$y$坐标排序，我们可以通过归并来实现，这样就还是$O(n)$总时间复杂度：$T(n)=2T(n/2)+O(6n)\Rightarrow O(nlogn)$ 分治法实现$UVA 10245 模版裸题：$ // // Created by TaoSama on 2016-03-18 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:1024000000,1024000000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e4 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n; typedef pair&lt;double, double&gt; P; P a[N]; double dfs(int l, int r) { if(l == r) return INF; int m = l + r &gt;&gt; 1; double x = a[m].first; double d = min(dfs(l, m), dfs(m + 1, r)); inplace_merge(a + l, a + m + 1, a + r + 1, [](P x, P y) { return x.second &lt; y.second; //按照y来归并2个数组 }); vector&lt;int&gt; v; for(int i = l; i &lt;= r; ++i) { if(abs(a[i].first - x) &gt;= d) continue; //距离中轴小于d点加入 for(int j = 0; j &lt; v.size(); ++j) { int k = v[v.size() - 1 - j]; //倒着检查y坐标相差小于d的点 double dy = a[i].second - a[k].second; if(dy &gt;= d) break; double dx = a[i].first - a[k].first; d = min(d, hypot(dx, dy)); } v.push_back(i); } return d; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); while(scanf(&quot;%d&quot;, &amp;n) == 1 &amp;&amp; n) { for(int i = 1; i &lt;= n; ++i) scanf(&quot;%lf%lf&quot;, &amp;a[i].first, &amp;a[i].second); sort(a + 1, a + 1 + n); double d = dfs(1, n); if(d &gt;= 1e4) {puts(&quot;INFINITY&quot;); continue;} printf(&quot;%.4f\n&quot;, d); } return 0; }]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ 2743 采花（离线思想、BIT）]]></title>
    <url>%2F2016%2F03%2F23%2FBZOJ%202743%20%E9%87%87%E8%8A%B1%EF%BC%88%E7%A6%BB%E7%BA%BF%E6%80%9D%E6%83%B3%E3%80%81BIT%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N，C，Q\le 10^6，C\le N，给定一个N大小序列，A_i\le C，Q次询问$$每次询问[L,R]区间有多少个出现至少2次的不同的整数$ 分析： $经典离线套路题了，询问右端点排序$$从左往右扫描每个数A_i（相当于固定了右端点）$$维护A_i出现的前一个位置为last_{i}，用BIT维护，只要单点更新last_{i}为1$$但是这样出现2次以上的就会多算，我们需要减去前一个位置的前一个位置$$也就是更新last_{last_i}为-1，这样扫描下去就不会多算了，每次只有当前的前一次出现的位置产生了贡献$$此时所有右端点为i的询问[L,i]的答案就是，ans(L,i)=sum(L,i)$$这里其实把BIT倒过来就可以完成了，向前更新，向后查询$$时间复杂度为O(nlogn)$ 代码： // // Created by TaoSama on 2016-03-23 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e6 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; struct BIT { int n, b[N]; void init(int _n) { n = _n; memset(b, 0, sizeof b); } void add(int i, int v) { for(; i; i -= i &amp; -i) b[i] += v; } int sum(int i) { int ret = 0; for(; i &lt;= n; i += i &amp; -i) ret += b[i]; return ret; } } bit; int n, c, q, a[N]; vector&lt;pair&lt;int, int&gt; &gt; qs[N]; int last[N], wh[N], ans[N]; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); scanf(&quot;%d%d%d&quot;, &amp;n, &amp;c, &amp;q); for(int i = 1; i &lt;= n; ++i) { scanf(&quot;%d&quot;, a + i); last[i] = wh[a[i]]; wh[a[i]] = i; } for(int i = 1; i &lt;= q; ++i) { int l, r; scanf(&quot;%d%d&quot;, &amp;l, &amp;r); qs[r].push_back(make_pair(l, i)); } bit.init(n); for(int i = 1; i &lt;= n; ++i) { if(last[i]) bit.add(last[i], 1); if(last[last[i]]) bit.add(last[last[i]], -1); for(int j = 0; j &lt; qs[i].size(); ++j) { pair&lt;int, int&gt;&amp; q = qs[i][j]; ans[q.second] = bit.sum(q.first); } } for(int i = 1; i &lt;= q; ++i) printf(&quot;%d\n&quot;, ans[i]); return 0; }]]></content>
      <categories>
        <category>思维</category>
        <category>离线思想</category>
      </categories>
      <tags>
        <tag>BIT</tag>
        <tag>离线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ 1878 HH的项链（离线思想、BIT）]]></title>
    <url>%2F2016%2F03%2F23%2FBZOJ%201878%20HH%E7%9A%84%E9%A1%B9%E9%93%BE%EF%BC%88%E7%A6%BB%E7%BA%BF%E6%80%9D%E6%83%B3%E3%80%81BIT%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N\le 5\times 10^4，Q\le 2\times 10^5，给定一个N大小序列，A_i\in[0,10^6]，Q次询问$$每次询问[L,R]区间有多少个不同的整数$ 分析： $经典离线套路题了，询问右端点排序$$从左往右扫描每个数A_i（相当于固定了右端点）$$维护A_i出现的前一个位置为last_{A_i}，用BIT维护，只要单点更新last_{A_i}为1$$发现所有以i为右端点的询问[L,i]中重复出现的数，查询[L,i]的区间和即可$$此时不同的整数的个数，ans(L,i)=i-L+1-sum(L,i)$$这里其实把BIT倒过来就可以完成了，向前更新，向后查询$$时间复杂度为O(nlogn)$ 代码： // // Created by TaoSama on 2016-03-23 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 2e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; struct BIT { int n, b[N]; void init(int _n) { n = _n; memset(b, 0, sizeof b); } void add(int i, int v) { for(; i; i -= i &amp; -i) b[i] += v; } int sum(int i) { int ret = 0; for(; i &lt;= n; i += i &amp; -i) ret += b[i]; return ret; } } bit; int n; int a[N]; int q, ans[N]; vector&lt;pair&lt;int, int&gt; &gt; qs[N]; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, a + i); scanf(&quot;%d&quot;, &amp;q); for(int i = 1; i &lt;= q; ++i) { int l, r; scanf(&quot;%d%d&quot;, &amp;l, &amp;r); qs[r].push_back(make_pair(l, i)); } bit.init(n); map&lt;int, int&gt; last; for(int i = 1; i &lt;= n; ++i) { int x = a[i]; if(last.count(x)) bit.add(last[x], 1); last[x] = i; for(int j = 0; j &lt; qs[i].size(); ++j) { pair&lt;int, int&gt;&amp; q = qs[i][j]; ans[q.second] = i - q.first + 1 - bit.sum(q.first); } } for(int i = 1; i &lt;= q; ++i) printf(&quot;%d\n&quot;, ans[i]); return 0; }]]></content>
      <categories>
        <category>思维</category>
        <category>离线思想</category>
      </categories>
      <tags>
        <tag>BIT</tag>
        <tag>离线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4630 No Pain No Game（离线思想、BIT）]]></title>
    <url>%2F2016%2F03%2F23%2FHDU%204630%20No%20Pain%20No%20Game%EF%BC%88%E7%A6%BB%E7%BA%BF%E6%80%9D%E6%83%B3%E3%80%81BIT%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N\le 5\times 10^4，Q\le 5\times 10^4，给定一个1\sim N的排列，Q次询问$$每次询问[L,R]区间任意2个数的gcd的最大值，规定1个数答案是0$ 分析： $经典离线套路题了，询问右端点排序$$从左往右扫描每个数A_i（相当于固定了右端点）$$对于每个数的约数x，维护它的倍数中的前一个位置为last_x$$用BIT维护，只要单点更新所有约数x的last_x为x$$发现所有以i为右端点的询问[L,i]只要查询[L,i]的最大值就好了$$这里其实把BIT倒过来就可以完成了，向前更新，向后查询$$筛法预处理1\sim N的约数，总时间复杂度为O(nlogn)$ 代码： // // Created by TaoSama on 2016-03-22 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 5e4 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; struct BIT { int n, b[N]; void init(int _n) { n = _n; memset(b, 0, sizeof b); } void add(int i, int v) { for(; i; i -= i &amp; -i) b[i] = max(b[i], v); } int sum(int i) { int ret = 0; for(; i &lt;= n; i += i &amp; -i) ret = max(ret, b[i]); return ret; } } bit; vector&lt;int&gt; divisors[N]; vector&lt;pair&lt;int, int&gt; &gt; qs[N]; int n, q, a[N], ans[N]; int last[N]; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); for(int i = 1; i &lt;= 5e4; ++i) for(int j = i; j &lt;= 5e4; j += i) divisors[j].push_back(i); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, a + i); scanf(&quot;%d&quot;, &amp;q); for(int i = 1; i &lt;= n; ++i) qs[i].clear(); for(int i = 1; i &lt;= q; ++i) { int l, r; scanf(&quot;%d%d&quot;, &amp;l, &amp;r); qs[r].push_back({l, i}); } bit.init(n); memset(last, 0, sizeof last); for(int i = 1; i &lt;= n; ++i) { int v = a[i]; for(int x : divisors[v]) { if(last[x]) bit.add(last[x], x); last[x] = i; } for(auto q : qs[i]) ans[q.second] = bit.sum(q.first); } for(int i = 1; i &lt;= q; ++i) printf(&quot;%d\n&quot;, ans[i]); } return 0; }]]></content>
      <categories>
        <category>思维</category>
        <category>离线思想</category>
      </categories>
      <tags>
        <tag>BIT</tag>
        <tag>离线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CROC 2016 - Elimination Round E. Intellectual Inquiry（贪心、dp）]]></title>
    <url>%2F2016%2F03%2F22%2FCROC%202016%20-%20Elimination%20Round%20E.%20Intellectual%20Inquiry%EF%BC%88%E8%B4%AA%E5%BF%83%E3%80%81dp%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N\le 10^6长度的字符串，给定字符集大小K\le26$$现在后面添加M \le10^6个字符，使得新的字符串的不同子序列个数最多$$输出这个个数，对10^9+7取模$ 分析： $先看没有添加字符的情况，考虑f[i]:=前i个字符形成的不同子序列个数$$如果这个字符之前没出现过，先累加之前的答案，然后添加这个字符，或者单独这个字符本身$$即f[i]=2\cdot f[i-1]+1$$如果这个字符之前出现过了，还是先累加之前的答案，然后添加这个字符$$但是这个字符出现过了，就不算单独本身了，之前算过了$$定义上一次出现的位置为pre，还要减去这个字符和pre-1这些字符重复的部分$$即f[i]=2\cdot f[i-1]-f[pre-1]$$对于后面新增加的字符，怎样才能让不同的字符最多，我们观察转移方程发现：$$答案是成倍递增的，所以要让一开始的大，也就是说减去的少，基于这样的贪心$$那么每次选择字符的时候都选上一次出现位置最早的$$其实也就是给pre数组排个序，周期性的添加嘛，每个周期都是一样的$$知道了添加的字符，继续做上面的dp就可以了$$时间复杂度O(N+M)$ 代码： // // Created by TaoSama on 2016-03-21 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 2e6 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, k; string s; int pre[26], rk[26], f[N]; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); cin &gt;&gt; n &gt;&gt; k &gt;&gt; s; memset(pre, -1, sizeof pre); for(int i = 0; i &lt; s.size(); ++i) pre[s[i] - &#39;a&#39;] = i; for(int i = 0; i &lt; k; ++i) rk[i] = i; sort(rk, rk + k, [](int x, int y) { return pre[x] &lt; pre[y]; }); for(int i = 0; i &lt; n; ++i) { int c = rk[i % k]; s += char(c + &#39;a&#39;); } memset(pre, -1, sizeof pre); for(int i = 0; i &lt; s.size(); ++i) { int c = s[i] - &#39;a&#39;; if(~pre[c]) f[i + 1] = (2 * f[i] % MOD - f[pre[c]] + MOD) % MOD; else f[i + 1] = (2 * f[i] + 1) % MOD; pre[c] = i; } int ans = (f[s.size()] + 1) % MOD; cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;; return 0; }]]></content>
      <categories>
        <category>动态规划</category>
        <category>线性dp</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>线性dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CROC 2016 - Elimination Round D. Robot Rapping Results Report（二分、拓扑排序）]]></title>
    <url>%2F2016%2F03%2F22%2FCROC%202016%20-%20Elimination%20Round%20D.%20Robot%20Rapping%20Results%20Report%EF%BC%88%E4%BA%8C%E5%88%86%E3%80%81%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $N\le 10^5个人，M\le 10^5条拓扑关系$$问最早第几条边加入的时候可以唯一确定拓扑关系$ 分析： $显然的二分答案啦$$拓扑排序每次取出一个顶点的时候看看这个顶点是不是唯一的就可以判断拓扑关系是否唯一了$$时间复杂度O((n+m)logm)$ 代码： // // Created by TaoSama on 2016-03-19 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:1024000000,1024000000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, m; int u[N], v[N]; vector&lt;int&gt; G[N]; bool check(int m) { for(int i = 1; i &lt;= n; ++i) G[i].clear(); vector&lt;int&gt; in(n + 1, 0); for(int i = 1; i &lt;= m; ++i) { G[u[i]].push_back(v[i]); ++in[v[i]]; } queue&lt;int&gt; q; for(int i = 1; i &lt;= n; ++i) if(!in[i]) q.push(i); while(q.size()) { int u = q.front(); q.pop(); if(q.size()) return false; for(int v : G[u]) if(--in[v] == 0) q.push(v); } return true; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= m; ++i) scanf(&quot;%d%d&quot;, u + i, v + i); int l = 1, r = m; while(l &lt;= r) { int m = l + r &gt;&gt; 1; if(check(m)) r = m - 1; else l = m + 1; } if(l == m + 1) l = -1; printf(&quot;%d\n&quot;, l); return 0; }]]></content>
      <categories>
        <category>图论</category>
        <category>拓扑排序</category>
      </categories>
      <tags>
        <tag>二分搜索</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IndiaHacks 2016 D. Delivery Bears（二分、最大流）]]></title>
    <url>%2F2016%2F03%2F21%2FIndiaHacks%202016%20D.%20Delivery%20Bears%EF%BC%88%E4%BA%8C%E5%88%86%E3%80%81%E6%9C%80%E5%A4%A7%E6%B5%81%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $给定N\le 50个城市，M\le 500条有向边，X\le10^5为熊的个数$$边描述为(u_i,v_i,c_i)，表示u_i\to v_i可以通过c_i物品$$现要求恰好用X只熊，且每只熊运送的物品多少相同$$求最多能从1到n运多少物品$ 分析： $首先很显然要二分每只熊运送多少物品，答案就是X*这个值$$接下来如何check可行，显然可以转换一下模型$$把每条边运送物品变为在当前的mid物品下，可以通过多少只熊$$所以check就变成了，1到n能否至少通过X只熊，建图后判断最大流是不是\ge X$$需要注意的是，容量可能会爆int$ 代码： // // Created by TaoSama on 2016-03-19 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:1024000000,1024000000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 50 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; const int M = 1000 + 10; int head[N], pnt[M], cap[M], nxt[M], cnt; void add_edge(int u, int v, int w) { pnt[cnt] = v; cap[cnt] = w; nxt[cnt] = head[u]; head[u] = cnt++; } void add_double(int u, int v, int w1, int w2 = 0) { add_edge(u, v, w1); add_edge(v, u, w2); } int lev[N], cur[N]; bool bfs(int s, int t) { queue&lt;int&gt; q; memset(lev, 0, sizeof lev); q.push(s); lev[s] = 1; while(q.size() &amp;&amp; !lev[t]) { int u = q.front(); q.pop(); for(int i = head[u]; ~i; i = nxt[i]) { int v = pnt[i]; if(cap[i] &gt; 0 &amp;&amp; !lev[v]) { lev[v] = lev[u] + 1; q.push(v); } } } return lev[t]; } int dfs(int u, int t, int delta) { if(u == t || !delta) return delta; int ret = 0; for(int i = cur[u]; ~i; i = nxt[i]) { int v = pnt[i]; if(cap[i] &gt; 0 &amp;&amp; lev[v] == lev[u] + 1) { int d = dfs(v, t, min(delta, cap[i])); cur[u] = i; ret += d; delta -= d; cap[i] -= d; cap[i ^ 1] += d; if(delta == 0) return ret; } } lev[u] = 0; return ret; } int dinic(int s, int t) { int ret = 0; while(bfs(s, t)) { for(int i = s; i &lt;= t; ++i) cur[i] = head[i]; ret += dfs(s, t, INF); } return ret; } int n, m, k; int u[M], v[M], c[M]; bool check(double x) { cnt = 0; memset(head, -1, sizeof head); for(int i = 1; i &lt;= m; ++i) add_double(u[i], v[i], min(c[i] / x, 1e9)); return dinic(1, n) &gt;= k; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k); for(int i = 1; i &lt;= m; ++i) scanf(&quot;%d%d%d&quot;, u + i, v + i, c + i); double l = 0, r = 1e6; for(int i = 1; i &lt;= 100; ++i) { double mid = (l + r) / 2; if(check(mid)) l = mid; else r = mid; } printf(&quot;%.12f\n&quot;, l * k); return 0; }]]></content>
      <categories>
        <category>图论</category>
        <category>网络流</category>
      </categories>
      <tags>
        <tag>二分搜索</tag>
        <tag>最大流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IndiaHacks 2016 C. Bear and Up-Down（暴力）]]></title>
    <url>%2F2016%2F03%2F21%2FIndiaHacks%202016%20C.%20Bear%20and%20Up-Down%EF%BC%88%E6%9A%B4%E5%8A%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $给定N\le 1.5\times10^5个整数，定义一个序列是漂亮的：$$所有奇数下标i，A_i &lt; A_{i+1}，所有偶数下标i，A_i &gt; A_{i+1}$$现给定一个不漂亮的序列，问有多少方法使得它变漂亮$ 分析： $可以发现，错误的位置不能超过4个，因为交换A_i和A_j最多只能影响i - 1, i, j - 1, j四个位置$$其实不用想那么多，反正这个位置不能很多$$然后直接暴力就可以了，枚举错误位置和序列里的数交换，判断是否满足要求$$统计完答案时候，要把和错误的换的容斥掉$$时间复杂度O(n)$ 代码： // // Created by TaoSama on 2016-03-19 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:1024000000,1024000000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 2e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, a[N]; bool check(int x) { if(x &amp; 1) { if(a[x - 1] &gt; a[x] &amp;&amp; a[x] &lt; a[x + 1]) return true; } else { if(a[x - 1] &lt; a[x] &amp;&amp; a[x] &gt; a[x + 1]) return true; } return false; } bool isLegal(vector&lt;int&gt;&amp; e) { for(int x : e) if(!check(x)) return false; return true; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); while(scanf(&quot;%d&quot;, &amp;n) == 1) { for(int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, a + i); a[0] = INF; a[n + 1] = n &amp; 1 ? INF : 0; vector&lt;int&gt; e; for(int i = 1; i &lt;= n; ++i) if(!check(i)) e.push_back(i); int ans = 0; if(e.size() &lt; 10) { for(int x : e) { for(int i = 1; i &lt;= n; ++i) { swap(a[x], a[i]); ans += check(i) &amp;&amp; isLegal(e); swap(a[x], a[i]); } } for(int i = 0; i &lt; e.size(); ++i) { int x = e[i]; for(int j = i + 1; j &lt; e.size(); ++j) { int y = e[j]; swap(a[x], a[y]); ans -= isLegal(e); swap(a[x], a[y]); } } } printf(&quot;%d\n&quot;, ans); } return 0; }]]></content>
      <categories>
        <category>暴力</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HihoCoder 1279 Rikka with Sequence（状压dp）]]></title>
    <url>%2F2016%2F03%2F21%2FHihoCoder%201279%20Rikka%20with%20Sequence%EF%BC%88%E7%8A%B6%E5%8E%8Bdp%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $给定N\le 50个整数，A_i\in[0,2^{13})$$从中选取若干个数(不为0)使得bitwise and的结果和bitwise xor的结果相同$$求方法数$ 分析： $首先根据and和xor运算的性质进行分析，如果要相等，以二进制位来看：$$为0的话，要有偶数个1，并且有至少1个0$$为1的话，要有奇数个1，并且没有0$$显然一眼状压dp，偶数个1，奇数个1，全为1还是不全为1，状态数4^{13}炸了$$考虑优化，反正我是想不到，三进制状压：$$0:=偶数个1且不全为1，1:=奇数个1且不全为1，2:=全为1$$再开1维，0/1:=选取了偶/奇数个数$$然后你奇妙的发现这包含了上面的四种状态，状态数3^{13}×2，完美$$f[i][S][0/1]:=前i个数，选取的数的状态是S，选取的数的个数是奇/偶的方法数$$转移就01背包转移就好了，这个数选还是不选$$由于转移是O(13)的，出题人说常数卡的好能过，窝折半预处理到O(1)特么的还是T了一晚上$$卡了半天常数才过，最后窝发现并不是卡常数，是特么的不滚动就要T，估计是MLE给搞T了$$能滚动就滚动吧，别偷懒了$$时间复杂度O(n×3^{13})$ 代码： // // Created by TaoSama on 2016-03-21 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:102400000,102400000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n; typedef long long LL; const int S = 1594323; //3^13 LL f[2][S][2]; // S: 0-&gt;偶数个1(不全是) 1-&gt;奇数个1(不全是) 2-&gt;全是1 // 0/1: 选取了偶/奇数个数 int sta[13]; inline void decode(int s, int n) { for(int i = 0; i &lt; n; ++i) { sta[i] = s % 3; s /= 3; } } inline int encode(int n) { int code = 0; for(int i = n - 1; ~i; --i) code = code * 3 + sta[i]; return code; } const int HS = 2187; //3^7 int trans[HS][1 &lt;&lt; 7][2]; int sHigh[S], sLow[S]; int th[13] = {1}; void gao() { for(int i = 1; i &lt; 13; ++i) th[i] = th[i - 1] * 3; for(int j = 0; j &lt; S; ++j) sHigh[j] = j / HS, sLow[j] = j % HS; for(int i = 0; i &lt; HS; ++i) { for(int j = 0; j &lt; 1 &lt;&lt; 7; ++j) { for(int p = 0; p &lt; 2; ++p) { int newS = i; for(int k = 0; k &lt; 7; ++k) { int b = i / th[k] % 3; if(j &gt;&gt; k &amp; 1) { //1 if(b != 2) { //sta[k] ^= 1; //奇偶互换 newS += (b ? -1 : 1) * th[k]; } } else { //0 if(b == 2) { //sta[k] = p; //不全是1了 newS += (p - 2) * th[k]; } } } //trans[i][j][p] = encode(7); trans[i][j][p] = newS; } } } } inline bool check(int s, int p) { decode(s, 13); //偶数个1(不全是) 同为0, 奇数个1(全是) 同为1 //非法的同理 for(int i = 0; i &lt; 13; ++i) if(sta[i] == 1 || !p &amp;&amp; sta[i] == 2) return false; return true; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); gao(); scanf(&quot;%d&quot;, &amp;n); int p = 0; f[p][S - 1][0] = 1; for(int i = 1; i &lt;= n; ++i) { int x; scanf(&quot;%d&quot;, &amp;x); int xHigh = x / (1 &lt;&lt; 7), xLow = x % (1 &lt;&lt; 7); memset(f[!p], 0, sizeof f[!p]); for(int j = 0; j &lt; S; ++j) { for(int k = 0; k &lt; 2; ++k) { if(!f[p][j][k]) continue; int newHigh = trans[sHigh[j]][xHigh][k]; int newLow = trans[sLow[j]][xLow][k]; int newS = newHigh * HS + newLow; f[!p][newS][k ^ 1] += f[p][j][k]; //选 // pr(i); pr(j); pr(k); prln(x); // pr(sLow); pr(xLow); pr(sHigh); prln(xHigh); // pr(newHigh); pr(newLow); prln(newS); // decode(j, 13); // for(int k = 0; k &lt; 13; ++k) printf(&quot;%d &quot;, sta[k]); puts(&quot;&quot;); // decode(newS, 13); // for(int k = 0; k &lt; 13; ++k) printf(&quot;%d &quot;, sta[k]); puts(&quot;&quot;); // if(i == n) printf(&quot;f[%d][%d]=%I64d\n&quot;, newS, k ^ 1, f[i][newS][k ^ 1]); f[!p][j][k] += f[p][j][k]; //不选 } } p = !p; } LL ans = 0; for(int i = 0; i &lt; S; ++i) for(int j = 0; j &lt; 2; ++j) if(f[p][i][j] &amp;&amp; check(i, j)) ans += f[p][i][j]; printf(&quot;%lld\n&quot;, ans); return 0; }]]></content>
      <categories>
        <category>动态规划</category>
        <category>状压dp</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>折半枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5305 Friends（dfs）]]></title>
    <url>%2F2016%2F03%2F18%2FHDU%205305%20Friends%EF%BC%88dfs%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $给定N\le 8，M\le N(N-1)/2的图$$现要给边染色，使得每个点的边一半是白，一半是黑$$求满足条件的方法数$ 分析： $如果枚举边的颜色的话，边数有28，复杂度是2^{28}会T$$考虑到一半一半，所以所有点的度数必须是偶数(一个剪枝)，边数是24$$但是没有根本的改变结果，考虑对每个点的所有边进行染色，由于边确定了$$下一个节点的一些边的颜色会被确定，会使得枚举的边变少，达不到24，现在就很快了$$至此问题解决，时间复杂度O(1s内可过)$ 代码： // // Created by TaoSama on 2016-03-17 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:1024000000,1024000000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; int n, m, ans; int g[10][10], deg[10]; vector&lt;vector&lt;int&gt; &gt; get(int u, int w) { vector&lt;vector&lt;int&gt; &gt; ret; vector&lt;int&gt; vec; if(w == 0) ret.push_back(vec); if(w == 1) { for(int i = 1; i &lt;= n; ++i) { if(g[u][i] != 1 || i == u) continue; vec.push_back(i); ret.push_back(vec); vec.pop_back(); } } if(w == 2) { for(int i = 1; i &lt;= n; ++i) { if(g[u][i] != 1 || i == u) continue; vec.push_back(i); for(int j = i + 1; j &lt;= n; ++j) { if(g[u][j] != 1 || j == u) continue; vec.push_back(j); ret.push_back(vec); vec.pop_back(); } vec.pop_back(); } } if(w == 3) { for(int i = 1; i &lt;= n; ++i) { if(g[u][i] != 1 || i == u) continue; vec.push_back(i); for(int j = i + 1; j &lt;= n; ++j) { if(g[u][j] != 1 || j == u) continue; vec.push_back(j); for(int k = j + 1; k &lt;= n; ++k) { if(g[u][k] != 1 || k == u) continue; vec.push_back(k); ret.push_back(vec); vec.pop_back(); } vec.pop_back(); } vec.pop_back(); } } return ret; } void dfs(int u) { if(u == n + 1) { ++ans; return; } int w = 0, b = 0; for(int v = 1; v &lt;= n; ++v) { if(g[u][v] == 2) ++w; if(g[u][v] == 3) ++b; } if(w &gt; deg[u] / 2 || b &gt; deg[u] / 2) return; vector&lt;vector&lt;int&gt; &gt; white = get(u, deg[u] / 2 - w); for(auto&amp; vec : white) { int tmp[10][10]; memcpy(tmp, g, sizeof g); for(int wh : vec) g[u][wh] = g[wh][u] = 2; for(int v = 1; v &lt;= n; ++v) if(g[u][v] == 1) g[u][v] = g[v][u] = 3; dfs(u + 1); memcpy(g, tmp, sizeof tmp); } } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); if(!m) {puts(&quot;1&quot;); continue;} memset(g, 0, sizeof g); memset(deg, 0, sizeof deg); for(int i = 1; i &lt;= m; ++i) { int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); g[u][v] = g[v][u] = 1; ++deg[u]; ++deg[v]; } bool ok = true; for(int i = 1; i &lt;= n; ++i) if(deg[i] &amp; 1) ok = false; if(!ok) {puts(&quot;0&quot;); continue;} ans = 0; dfs(1); printf(&quot;%d\n&quot;, ans); } return 0; }]]></content>
      <categories>
        <category>暴力</category>
        <category>搜索</category>
        <category>dfs/bfs</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5303 Delicious Apples（贪心）]]></title>
    <url>%2F2016%2F03%2F18%2FHDU%205303%20Delicious%20Apples%EF%BC%88%E8%B4%AA%E5%BF%83%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $给定L\le 10^9的环形路，家在0号点，N\le 10^5颗苹果树，每棵有A_i个苹果，\sum A_i \le 10^5$$现有一个K\le 10^5的篮子，求从家出发把所有的苹果装回家的最短路程$ 分析： $首先可以发现，肯定是先把近的苹果先拿走，如果拿了远的再拿近的再拿远的路程会交叉，就不优了$$其次再考虑会不会可能走一圈，发现是可以的，见下图：$$设起点到a的距离为l_1，到b的距离为l_2，且l_1, l_2 &gt; {L\over 4}, A_a+A_b\le k$$那么走一圈的路程是L，直接从最近的拿是2(l_1+l_2) &gt; L，此时显然走一圈更优$$更可以得出l_1,l_2\le {L\over 4}直接拿比较好$$问题来了，可不可能走多圈呢，还是上面的图，看2圈的情况：$$不过设A_a = x &lt; k, A_b = k + y, 且A_a+A_b \le 2k$$显然如果两边都是k的话，就不能绕圈了，所以可能走2圈一定是这样的$$直接拿的话是2(l_1+2l_2)&gt;{3L\over 2}，走2圈是2L，走1圈+先拿k是L+2l_2$$显然走2圈最差，其次L+2l_2 - (2(l_1+2l_2))=L - (2(l_1+l_2)) &lt; 0，走1圈+先拿k最优$$显然更多圈的情况其实都可以规约到2圈的情况$$由于苹果个数10^5，把苹果分开看，l[i]:=左边拿i个苹果的代价,r[i]同理$$所以问题解决了，只要枚举最后一次2边拿的让它走1圈就好了$$时间复杂度因为有排序所以是O(nlogn)$ 代码： // // Created by TaoSama on 2016-03-18 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:1024000000,1024000000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int L, n, k; typedef long long LL; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%d%d%d&quot;, &amp;L, &amp;n, &amp;k); vector&lt;LL&gt; l(1, 0), r(1, 0); //l[0] = r[0] = 0 for(int i = 1; i &lt;= n; ++i) { int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); while(y--) { if(x &lt;&lt; 1 &lt; L) l.push_back(x); else r.push_back(L - x); } } sort(l.begin(), l.end()); sort(r.begin(), r.end()); for(int i = k; i &lt; l.size(); ++i) l[i] += l[i - k]; for(int i = k; i &lt; r.size(); ++i) r[i] += r[i - k]; LL ans = l.back() + r.back() &lt;&lt; 1; for(int i = 0; i &lt;= k; ++i) { int a = max(0, (int)l.size() - 1 - i); int b = max(0, (int)r.size() - 1 - (k - i)); ans = min(ans, L + (l[a] + r[b] &lt;&lt; 1)); } printf(&quot;%I64d\n&quot;, ans); } return 0; }]]></content>
      <categories>
        <category>思维</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5301 Buildings（思维）]]></title>
    <url>%2F2016%2F03%2F18%2FHDU%205301%20Buildings%EF%BC%88%E6%80%9D%E7%BB%B4%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $给定N, M\le 10^8的矩形，其中有1个1*1的格子坏掉了$$现要把矩形切成多个小矩形，使得所有的小矩形都与原矩形边界相连$$并最小化最大的小矩形面积，求这个面积$ 分析： $可以发现，如果没有坏掉的格子，答案是中心点距离边界的最短距离$$不管中心点是1个、2个还是4个，我们总可以根据对称性发现中心点们的答案都是一样的$$所以中心点选一个就可以了$$问题来了，现在有坏掉的格子，有可能使得答案变大，所以坏掉的格子周围四个点也要考虑$$如果坏掉的格子占据了中心点呢$$无所谓，中心点的四邻点必然还有一个中心点$$(1个中心点的除外，考虑它的四邻点，但是我们已经考虑过啦，因为它也是坏掉的点嘛)$ 代码： // // Created by TaoSama on 2016-03-17 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:1024000000,1024000000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, m, x0, y0; int get(int x, int y) { if(x == x0 &amp;&amp; y == y0) return 0; int u = x, d = n - x + 1, l = y, r = m - y + 1; //cross the obstacle if(x == x0) { if(y &gt; y0) l = INF; else r = INF; } if(y == y0) { if(x &gt; x0) u = INF; else d = INF; } return min(min(u, d), min(l, r)); } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); while(scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;x0, &amp;y0) == 4) { //just one center, because of symmetric int ans = get(n + 1 &gt;&gt; 1, m + 1 &gt;&gt; 1); //even if the obstacle occupying the center, but we still ensure the answer //since iterating the 4 directions, one center must be included int d[][2] = { -1, 0, 0, -1, 1, 0, 0, 1}; for(int i = 0; i &lt; 4; ++i) { int x = x0 + d[i][0], y = y0 + d[i][1]; if(x &lt; 1 || x &gt; n || y &lt; 1 || y &gt; m) continue; ans = max(ans, get(x, y)); } printf(&quot;%d\n&quot;, ans); } return 0; }]]></content>
      <categories>
        <category>思维</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hihocoder 1273 清理海报（判断矩形相交）]]></title>
    <url>%2F2016%2F03%2F13%2FHihocoder%201273%20%E6%B8%85%E7%90%86%E6%B5%B7%E6%8A%A5%EF%BC%88%E5%88%A4%E6%96%AD%E7%9F%A9%E5%BD%A2%E7%9B%B8%E4%BA%A4%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： 中文题意 分析： $如果i可以被j覆盖就从i向j连一条边，判断矩形相交看代码吧$$覆盖的情况可以状压矩形的四个角，判断能不能撕开$$时间复杂度O(n^2)$ 代码： // // Created by TaoSama on 2016-03-13 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:1024000000,1024000000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e3 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; #define y1 asdasdasd int w, h, n; int x1[N], y1[N], x2[N], y2[N]; bool vis[N]; vector&lt;int&gt; G[N]; bool intersect(int i, int j) { int minx = max(x1[i], x1[j]); int maxx = min(x2[i], x2[j]); int miny = max(y1[i], y1[j]); int maxy = min(y2[i], y2[j]); if(minx &gt;= maxx || miny &gt;= maxy) return false; return true; } bool inside(int x, int y, int i) { return x &gt; x1[i] &amp;&amp; x &lt; x2[i] &amp;&amp; y &gt; y1[i] &amp;&amp; y &lt; y2[i]; } //i被j包含 int cover(int i, int j) { int ret = 0; if(inside(x1[i], y1[i], j)) ret |= 1; if(inside(x1[i], y2[i], j)) ret |= 2; if(inside(x2[i], y2[i], j)) ret |= 4; if(inside(x2[i], y1[i], j)) ret |= 8; return ret; } void dfs(int st, int u, int&amp; sta) { vis[u] = true; for(int v : G[u]) { if(vis[v]) continue; sta |= cover(st, v); dfs(st, v, sta); } } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); scanf(&quot;%d%d%d&quot;, &amp;w, &amp;h, &amp;n); for(int i = 1; i &lt;= n; ++i) { scanf(&quot;%d%d%d%d&quot;, x1 + i, y1 + i, x2 + i, y2 + i); } for(int i = 1; i &lt;= n; ++i) { for(int j = i + 1; j &lt;= n; ++j) if(intersect(i, j)) G[i].push_back(j); } // for(int i = 1; i &lt;= n; ++i){ // printf(&quot;%d: &quot;, i); // for(int v : G[i]) printf(&quot;%d &quot;, v); puts(&quot;&quot;); // } pair&lt;int, int&gt; ans = make_pair(0, 0); for(int i = 1; i &lt;= n; ++i) { memset(vis, false, sizeof vis); int sta = 0; dfs(i, i, sta); if(sta == 15) continue; int cnt = 0; for(int j = 1; j &lt;= n; ++j) cnt += vis[j]; if(cnt &gt; ans.first) ans = make_pair(cnt, i); } printf(&quot;%d %d\n&quot;, ans.first, ans.second); return 0; }]]></content>
      <categories>
        <category>计算几何</category>
      </categories>
      <tags>
        <tag>判断矩形相交</tag>
        <tag>状压</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hihocoder 1272 买零食（签到）]]></title>
    <url>%2F2016%2F03%2F13%2FHihocoder%201272%20%E4%B9%B0%E9%9B%B6%E9%A3%9F%EF%BC%88%E7%AD%BE%E5%88%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： 中文题意 分析： $忘记double可以+0.5了，sb了手动解析浮点数$$数据很小直接暴力C_n^1，C_n^2，C_n^3，更新答案就可以了$ 代码： // // Created by TaoSama on 2016-03-13 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:1024000000,1024000000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n; int a[55], b[55]; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; ++i) { char s[100]; scanf(&quot;%s%d&quot;, s, b + i); bool have = 0; int x = 0; for(int j = 0; s[j]; ++j) { if(s[j] == &#39;.&#39;) { have = true; if(s[j + 1]) x = x * 10 + s[j + 1] - &#39;0&#39;; else x = x * 10; break; } x = x * 10 + s[j] - &#39;0&#39;; } if(!have) x = x * 10; a[i] = x; } int ans = 0; for(int i = 1; i &lt;= n; ++i) if(a[i] % 50 == 0) ans = max(ans, b[i]); for(int i = 1; i &lt;= n; ++i) for(int j = i + 1; j &lt;= n; ++j) if((a[i] + a[j]) % 50 == 0) ans = max(ans, b[i] + b[j]); for(int i = 1; i &lt;= n; ++i) for(int j = i + 1; j &lt;= n; ++j) for(int k = j + 1; k &lt;= n; ++k) if((a[i] + a[j] + a[k]) % 50 == 0) ans = max(ans, b[i] + b[j] + b[k]); printf(&quot;%d\n&quot;, ans); } return 0; }]]></content>
      <categories>
        <category>暴力</category>
        <category>签到</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World —— 博客搭建历程]]></title>
    <url>%2F2016%2F03%2F09%2FHello%20World%20%E2%80%94%E2%80%94%20%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Updating 搭建博客使用hexo生成静态博客并架设在免费的github pages平台详情看这篇博客，零基础免费搭建个人博客-hexo+github 主题选择搞了半天，研究了jacman，next，...，最后发现还是自带的landscape挺好的，然后就用了landscape-plus准备在此基础上改改，借鉴了这个人的修改姿势，并自己添加了一些东西 修改归档挂件的时间格式：（左边为原图，右边为效果图） 路径: \themes\landscape-plus\layout\_widget\archive.ejs 第5行 &lt;%- list_archives({format: &#39;YYYY年 MM月&#39;}) %&gt; 修改归档页面的时间格式：（左边为原图，右边为效果图） 路径：\themes\landscape-plus\layout\_partial\archive-post.ejs 第4行 &lt;%- partial(&#39;post/date&#39;, {class_name: &#39;archive-article-date&#39;, date_format: &#39;MM-DD&#39;}) %&gt; 添加新挂件，推荐文章： 路径：\themes\landscape-plus\layout\_widget\archive\recent_comments.ejs 新文件&lt;% if (site.posts.length){ %&gt; &lt;div class=&quot;widget-wrap&quot;&gt; &lt;h3 class=&quot;widget-title&quot;&gt;&lt;%= __(&#39;recent_comments&#39;) %&gt;&lt;/h3&gt; &lt;div class=&quot;widget&quot;&gt; &lt;!-- 多说最新评论 start --&gt; &lt;div class=&quot;ds-recent-comments&quot; data-num-items=&quot;5&quot; data-show-avatars=&quot;0&quot; data-show-time=&quot;1&quot; data-show-title=&quot;1&quot; data-show-admin=&quot;1&quot; data-excerpt-length=&quot;70&quot;&gt;&lt;/div&gt; &lt;!-- 多说最新评论 end --&gt; &lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt; &lt;script type=&quot;text/javascript&quot;&gt; var duoshuoQuery = {short_name:&quot;Taos&quot;}; (function() { var ds = document.createElement(&#39;script&#39;); ds.type = &#39;text/javascript&#39;;ds.async = true; ds.src = (document.location.protocol == &#39;https:&#39; ? &#39;https:&#39; : &#39;http:&#39;) + &#39;//static.duoshuo.com/embed.js&#39;; ds.charset = &#39;UTF-8&#39;; (document.getElementsByTagName(&#39;head&#39;)[0] || document.getElementsByTagName(&#39;body&#39;)[0]).appendChild(ds); })(); &lt;/script&gt; &lt;!-- 多说公共JS代码 end --&gt; &lt;/div&gt; &lt;/div&gt; &lt;% } %&gt; 添加新挂件，最近评论： 路径：\themes\landscape-plus\layout\_widget\archive\recent_comments.ejs 新文件 &lt;% if (site.posts.length){ %&gt; &lt;div class=&quot;widget-wrap&quot;&gt; &lt;h3 class=&quot;widget-title&quot;&gt;&lt;%= __(&#39;recent_comments&#39;) %&gt;&lt;/h3&gt; &lt;div class=&quot;widget&quot;&gt; &lt;!-- 多说最新评论 start --&gt; &lt;div class=&quot;ds-recent-comments&quot; data-num-items=&quot;5&quot; data-show-avatars=&quot;0&quot; data-show-time=&quot;1&quot; data-show-title=&quot;1&quot; data-show-admin=&quot;1&quot; data-excerpt-length=&quot;70&quot;&gt;&lt;/div&gt; &lt;!-- 多说最新评论 end --&gt; &lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt; &lt;script type=&quot;text/javascript&quot;&gt; var duoshuoQuery = {short_name:&quot;Taos&quot;}; (function() { var ds = document.createElement(&#39;script&#39;); ds.type = &#39;text/javascript&#39;;ds.async = true; ds.src = (document.location.protocol == &#39;https:&#39; ? &#39;https:&#39; : &#39;http:&#39;) + &#39;//static.duoshuo.com/embed.js&#39;; ds.charset = &#39;UTF-8&#39;; (document.getElementsByTagName(&#39;head&#39;)[0] || document.getElementsByTagName(&#39;body&#39;)[0]).appendChild(ds); })(); &lt;/script&gt; &lt;!-- 多说公共JS代码 end --&gt; &lt;/div&gt; &lt;/div&gt; &lt;% } %&gt; 添加最近评论挂件样式表路径：\themes\landscape-plus\source\css\_partial\sidebar-aside.styl 末尾添加 .ds-recent-comments margin: -16px 0 0 0 a color: color-link 文章结尾增加声明文字： 路径：\themes\landscape-plus\layout\_partial\post\statement.ejs 新文件 &lt;% if (!index &amp;&amp; page.source != &#39;about/index.md&#39;){ %&gt; &lt;div class=&quot;article-statement&quot;&gt; &lt;hr&gt; &lt;!-- 内容 --&gt; &lt;/div&gt; &lt;% } %&gt; 添加声明文字样式表路径：\themes\landscape-plus\source\css\_partial\sidebar.styl 末尾添加 .article-statement font-size: 0.85em; line-height: 1.6em; margin: 0.5em 0; text-shadow: 0 1px #fff; color: #999; a &amp;:hover text-decoration: none; 页脚中添加访问统计、为超链接添加target=”_blank”属性： 路径：\themes\landscape-plus-bak\layout\_partial\footer.ejs 修改为&lt;footer id=&quot;footer&quot;&gt; &lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt; &lt;/script&gt; &lt;% if (theme.sidebar === &#39;bottom&#39;){ %&gt; &lt;%- partial(&#39;_partial/sidebar&#39;) %&gt; &lt;% } %&gt; &lt;div class=&quot;outer&quot;&gt; &lt;div id=&quot;footer-info&quot; class=&quot;inner&quot; align = &quot;center&quot;&gt; Copyright &amp;copy; &lt;%= date(new Date(), &#39;YYYY&#39;) %&gt; &lt;a href=&quot;/&quot; target=&quot;_blank&quot;&gt; &lt;%= config.author || config.title %&gt; &lt;/a&gt; &lt;br&gt; Powered by &lt;a href=&quot;https://hexo.io/zh-cn/docs/index.html&quot; target=&quot;_blank&quot;&gt;Hexo&lt;/a&gt; &amp;nbsp;|&amp;nbsp; Theme by &lt;a href=&quot;https://github.com/xiangming/landscape-plus&quot; target=&quot;_blank&quot;&gt;landscape-plus&lt;/a&gt; &amp;nbsp;|&amp;nbsp; &lt;span id=&quot;busuanzi_container_site_pv&quot;&gt; 总访问量 &lt;a href=&quot;http://service.ibruce.info/&quot; target=&quot;_blank&quot;&gt;&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;&lt;/a&gt; 次 &lt;/span&gt; &lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; &lt;a href=&quot;http://service.ibruce.info/&quot; target=&quot;_blank&quot;&gt;&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;&lt;/a&gt; 人 &lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 为超链接加上target=&#39;_blank&#39;属性 --&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function() { $(&#39;a[href^=&quot;http&quot;]&#39;).each(function() { $(this).attr(&#39;target&#39;, &#39;_blank&#39;); }); }); &lt;/script&gt; &lt;/footer&gt; 文章添加生成目录开关 路径：\themes\landscape-plus\layout\_partial\article.ejs 搜索&lt;%- post.content %&gt;前面添加 &lt;!-- Table of Contents --&gt; &lt;% if (!index &amp;&amp; post.toc){ %&gt; &lt;div id=&quot;toc&quot; class=&quot;toc-article&quot;&gt; &lt;strong class=&quot;toc-title&quot;&gt;Contents&lt;/strong&gt; &lt;%- toc(post.content) %&gt; &lt;/div&gt; &lt;% } %&gt; 添加目录样式表路径：\themes\landscape-plus\source\css\_partial\article.styl 末尾添加 .toc-article background #eee border 1px solid #bbb border-radius 10px margin 1.5em 0 0.3em 1.5em padding 1.2em 1em 0 1em max-width 28% .toc-title font-size 120% #toc line-height 1em font-size 0.9em float right .toc padding 0 margin 1em line-height 1.8em li list-style-type none .toc-child margin-left 1em 启用目录在需要添加文章目录的的博文md文件中添加开关toc: true如果不喜欢链接的颜色，可以编辑\themes\landscape-plus\source\css\_variables.styl 第6行 color-link = #E32D40 文章标题添加一条灰色分割线 路径：\themes\landscape-plus\source\css\_partial\article.styl 第26行.article-header padding: article-padding border-bottom: 2px solid color-border 问题处理 Marked渲染markdown与Mathjax渲染latex冲突路径：\node_modules\marked\lib\marked.js 第451行escape: /^\\([\\`*{}\[\]()# +\-.!_&gt;])/, 修改为： escape: /^\\([`*\[\]()# +\-.!_&gt;])/, 第854行return &#39;&lt;em&gt;&#39; + text + &#39;&lt;/em&gt;&#39;; 修改为： return &#39;_&#39; + text + &#39;_&#39;; 图床和云空间选择极简图床配合七牛云,感觉挺棒的]]></content>
      <categories>
        <category>Doing</category>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 345 (Div. 2) E. Table Compression（拓扑排序）]]></title>
    <url>%2F2016%2F03%2F08%2FCodeforces%20Round%20345%20(Div.%202)%20E.%20Table%20Compression%EF%BC%88%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $n*m \le 10^6的矩阵，现在要压缩矩阵里的数字的大小，使得最大的数字尽量小$$压缩的要求是，保证每行或者每列的相对数字大小不变，并且每行或者每列的相等的数字压缩后还相等$ 分析： $大小关系是一种拓扑关系，所以我们可以建图拓扑排序$$由于每行或者每列的相等数字大小不变，所以先把它们用并查集缩点$$如果暴力向比它大的数字连边的话，边数将是n^3级别的，会爆炸$$考虑拓扑关系具有传递性，只需要向第一个比它大的连边即可，这样边数就是n^2级别了$$我们只要将每行或者每列排序，二分查找这个数就可以了$$时间复杂度O(nmlognm)$ 代码： // // Created by TaoSama on 2016-03-08 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:1024000000,1024000000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 1e6 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, m; struct DSU { int n, p[N]; void init(int _n) { n = _n; for(int i = 0; i &lt; n; ++i) p[i] = i; } int find(int x) { return p[x] = p[x] == x ? x : find(p[x]); } void unite(int x, int y) { x = find(x), y = find(y); if(x == y) return; p[x] = y; } } dsu; typedef pair&lt;int, int&gt; P; void merge(vector&lt;P&gt;&amp; tmp) { sort(tmp.begin(), tmp.end()); int sz = tmp.size(); for(int j = 0; j &lt; sz; ++j) { int p = j; while(j + 1 &lt; sz &amp;&amp; tmp[j + 1].first == tmp[p].first) { dsu.unite(tmp[j + 1].second, tmp[p].second); ++j; } } } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); vector&lt;vector&lt;P&gt; &gt; a(n, vector&lt;P&gt;(m)), b(m, vector&lt;P&gt;(n)); for(int i = 0; i &lt; n; ++i) { for(int j = 0; j &lt; m; ++j) { int x; scanf(&quot;%d&quot;, &amp;x); a[i][j] = {x, i * m + j}; b[j][i] = {x, i * m + j}; } } dsu.init(n * m); //merge row equal values for(int i = 0; i &lt; n; ++i) merge(a[i]); //merge column equal values for(int i = 0; i &lt; m; ++i) merge(b[i]); //new graph vector&lt;int&gt; in(n * m, 0); vector&lt;vector&lt;int&gt; &gt; g(n * m); for(int i = 0; i &lt; n; ++i) { vector&lt;P&gt;&amp; cur = a[i]; for(int j = 0; j &lt; m; ++j) { auto iter = upper_bound(cur.begin(), cur.end(), P(cur[j].first, INF)); if(iter == cur.end()) continue; int u = dsu.find(cur[j].second), v = dsu.find(iter-&gt;second); g[u].push_back(v); ++in[v]; for(int p = j; j &lt; m &amp;&amp; cur[j + 1].first == cur[p].first; ++j); } } for(int i = 0; i &lt; m; ++i) { vector&lt;P&gt;&amp; cur = b[i]; for(int j = 0; j &lt; n; ++j) { auto iter = upper_bound(cur.begin(), cur.end(), P(cur[j].first, INF)); if(iter == cur.end()) continue; int u = dsu.find(cur[j].second), v = dsu.find(iter-&gt;second); g[u].push_back(v); ++in[v]; for(int p = j; j &lt; n &amp;&amp; cur[j + 1].first == cur[p].first; ++j); } } queue&lt;int&gt; q; vector&lt;int&gt; ans(n * m, 0); for(int i = 0; i &lt; n * m; ++i) { if(in[i]) continue; q.push(i); ans[i] = 1; } while(q.size()) { int u = q.front(); q.pop(); for(int v : g[u]) { ans[v] = max(ans[v], ans[u] + 1); if(--in[v] == 0) q.push(v); } } for(int i = 0; i &lt; n; ++i) for(int j = 0; j &lt; m; ++j) printf(&quot;%d%c&quot;, ans[dsu.find(i * m + j)], &quot; \n&quot;[j == m - 1]); return 0; }]]></content>
      <categories>
        <category>图论</category>
        <category>拓扑排序</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 345 (Div. 2) D. Image Preview（二分搜索）]]></title>
    <url>%2F2016%2F03%2F08%2FCodeforces%20Round%20345%20(Div.%202)%20D.%20Image%20Preview%EF%BC%88%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $n\le 5\times 10^5手机图片，每种图片可能是h的也可能是w的，w要观看的话就要有旋转花费b$$观看一张图片需要1单位时间，手机图片显示是个环，滑动切换的花费是a$$初始在第一张图片，切换到的图片必须要观看$$给定T\le 10^9时间，问最多能看多少图片$ 分析： $特判第一张图片，预处理出前缀观看时间，和后缀观看时间$$向右枚举一次，然后二分倒着能看多少，两者加起来，同理向左枚举，二分顺着能看多少$$注意细节和边界$ 代码： // // Created by TaoSama on 2016-03-07 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:1024000000,1024000000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 5e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, a, b, T; int pre[N], suf[N]; char s[N]; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); while(scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;a, &amp;b, &amp;T) == 4) { scanf(&quot;%s&quot;, s + 1); pre[1] = suf[n + 1] = 0; for(int i = 2; i &lt;= n; ++i) pre[i] = pre[i - 1] + a + (s[i] == &#39;w&#39; ? b : 0) + 1; for(int i = n; i; --i) suf[i] = suf[i + 1] + a + (s[i] == &#39;w&#39; ? b : 0) + 1; reverse(suf + 1, suf + 1 + n); int first = (s[1] == &#39;w&#39; ? b : 0) + 1; int ans = first &lt;= T; for(int i = 2; i &lt;= n; ++i) { if(pre[i] + first &gt; T) break; int leave = T - pre[i] - first - (i - 1) * a; int can = upper_bound(suf + 1, suf + 1 + n, leave) - suf - 1; ans = max(ans, i + can); } for(int i = 1; i &lt;= n; ++i) { if(suf[i] + first &gt; T) break; int leave = T - suf[i] - first - i * a; int can = upper_bound(pre + 2, pre + 1 + n, leave) - pre - 2; ans = max(ans, i + can + 1); } ans = min(ans, n); printf(&quot;%d\n&quot;, ans); } return 0; }]]></content>
      <categories>
        <category>暴力</category>
        <category>搜索</category>
        <category>二/三分搜索</category>
      </categories>
      <tags>
        <tag>二分搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4609 3-idiots（FFT）]]></title>
    <url>%2F2016%2F03%2F07%2FHDU%204609%203-idiots%EF%BC%88FFT%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： $n\le 10^5条线段，每条长度A_i \le 10^5，问随机取3个，可以组成三角形的概率$ 分析： $cnt_i:=长度为i的线段有几个，然后卷积一下就是2个线段之和为i的方法数有多少$$之后枚举最长边，累加答案就好了$$要减去一些不符合的，首先自己+自己的减去，还要除2，去掉重复的$$枚举的是最长边，所以累加答案的时候要减掉一些非法的情况$ 代码： // // Created by TaoSama on 2016-03-07 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:1024000000,1024000000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;complex&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 4e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; const double PI = acos(-1); typedef complex&lt;double&gt; Complex; void rader(Complex *y, int len) { for(int i = 1, j = len / 2; i &lt; len - 1; i++) { if(i &lt; j) swap(y[i], y[j]); int k = len / 2; while(j &gt;= k) {j -= k; k /= 2;} if(j &lt; k) j += k; } } void fft(Complex *y, int len, int op) { rader(y, len); for(int h = 2; h &lt;= len; h &lt;&lt;= 1) { double ang = op * 2 * PI / h; Complex wn(cos(ang), sin(ang)); for(int j = 0; j &lt; len; j += h) { Complex w(1, 0); for(int k = j; k &lt; j + h / 2; k++) { Complex u = y[k]; Complex t = w * y[k + h / 2]; y[k] = u + t; y[k + h / 2] = u - t; w = w * wn; } } } if(op == -1) for(int i = 0; i &lt; len; i++) y[i] /= len; } Complex A[N]; typedef long long LL; int n, a[N]; LL cnt[N]; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%d&quot;, &amp;n); memset(cnt, 0, sizeof cnt); for(int i = 1; i &lt;= n; ++i) { scanf(&quot;%d&quot;, a + i); ++cnt[a[i]]; } sort(a + 1, a + 1 + n); int len = 1; while(len &lt;= a[n] &lt;&lt; 1) len &lt;&lt;= 1; for(int i = 0; i &lt; len; ++i) A[i] = Complex(cnt[i], 0); fft(A, len, 1); for(int i = 0; i &lt; len; ++i) A[i] *= A[i]; fft(A, len, -1); for(int i = 0; i &lt; len; ++i) cnt[i] = A[i].real() + 0.5; for(int i = 1; i &lt;= n; ++i) --cnt[a[i] &lt;&lt; 1]; len = a[n] &lt;&lt; 1; for(int i = 1; i &lt;= len; ++i) cnt[i] &gt;&gt;= 1; for(int i = 1; i &lt;= len; ++i) cnt[i] += cnt[i - 1]; LL sum = 0; for(int i = 1; i &lt;= n; ++i) { sum += cnt[len] - cnt[a[i]]; sum -= n - 1; //{self, other} &gt; self sum -= 1LL * (i - 1) * (n - i); // {small, large} &gt; self sum -= 1LL * (n - i) * (n - i - 1) / 2; //{large, large} &gt; self; } double ans = 1. * sum / (1. * n * (n - 1) * (n - 2) / 6); printf(&quot;%.7f\n&quot;, ans); } return 0; }]]></content>
      <categories>
        <category>数学</category>
        <category>FFT/NTT/FWT</category>
      </categories>
      <tags>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 9 F. Magic Matrix（离线暴力、bitset）]]></title>
    <url>%2F2016%2F03%2F07%2FEducational%20Codeforces%20Round%209%20F.%20Magic%20Matrix%EF%BC%88%E7%A6%BB%E7%BA%BF%E6%9A%B4%E5%8A%9B%E3%80%81bitset%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意: $给你一个n*n, n\le 2500的矩阵，判断这个矩阵是不是魔力矩阵$$魔力矩阵的定义为：$$1.对角线都为0$$2.矩阵对称, 即a_{ij}=a_{ji}$$3.对于任意一个格子(i,j)满足,\forall k，a[i][j]\le max(a[i][k],a[j][k])$ 分析: $bitset[i]:=维护i行比当前这个数小的列的状态$$把矩阵所有元素对于值进行排序, 然后对于当前这个a_{ij}询问, 添加进去所有比它小的值到bitset中$$回答询问的时候只要看, bitset[i]和bitset[j]中有没有交集, 即存在一个k使得max(a[i][k],a[j][k])&lt;a[i][j]$$对于1,2条件就很简单了$$时间复杂度O(n^3/64),其实是水过了$ 代码: // // Created by TaoSama on 2016-03-07 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:1024000000,1024000000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; #include &lt;bitset&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 2500, INF = 0x3f3f3f3f, MOD = 1e9 + 7; int n, a[N][N]; bitset&lt;N&gt; b[N]; pair&lt;int, pair&lt;int, int&gt; &gt; q[N * N]; int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); scanf(&quot;%d&quot;, &amp;n); for(int i = 0; i &lt; n; ++i) { for(int j = 0; j &lt; n; ++j) { scanf(&quot;%d&quot;, a[i] + j); q[i * n + j] = {a[i][j], {i, j}}; } } sort(q, q + n * n); for(int i = 0; i &lt; n; ++i) for(int j = 0; j &lt; n; ++j) if(i == j &amp;&amp; a[i][j] || a[i][j] != a[j][i]) return puts(&quot;NOT MAGIC&quot;); int idx = 0; for(int i = 0; i &lt; n * n; ++i) { auto wh = q[i].second; int x = wh.first, y = wh.second; while(q[idx].first &lt; a[x][y]) { wh = q[idx].second; b[wh.first][wh.second] = 1; ++idx; } if((b[x] &amp; b[y]).any()) return puts(&quot;NOT MAGIC&quot;); } puts(&quot;MAGIC&quot;); return 0; }]]></content>
      <categories>
        <category>思维</category>
        <category>离线思想</category>
      </categories>
      <tags>
        <tag>bitset</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 9 E. Thief in a Shop（FFT）]]></title>
    <url>%2F2016%2F03%2F06%2FEducational%20Codeforces%20Round%209%20E.%20Thief%20in%20a%20Shop%EF%BC%88FFT%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意: $给定N,K\le 10^3,N种物品,价值A_i\le 10^3, 必须装K个物品的背包$$求所有能装的价值，从小到大输出$ 分析: $其实就是长度为1000的物品价值向量的k次幂,存在该价值就为1否则为0$$然后用fft求k次卷积就好了$$用bool数组可以降低精度误差, 同时不要直接把fft的len设置成10^6， 可以优化下常数$$时间复杂度是O(WlogWlogk), W=10^6$ 代码: // // Created by TaoSama on 2016-03-06 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:1024000000,1024000000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;complex&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = (1 &lt;&lt; 21) + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; const double PI = acos(-1); typedef complex&lt;double&gt; Complex; void rader(Complex *y, int len) { for(int i = 1, j = len / 2; i &lt; len - 1; i++) { if(i &lt; j) swap(y[i], y[j]); int k = len / 2; while(j &gt;= k) {j -= k; k /= 2;} if(j &lt; k) j += k; } } void fft(Complex *y, int len, int op) { rader(y, len); for(int h = 2; h &lt;= len; h &lt;&lt;= 1) { double ang = op * 2 * PI / h; Complex wn(cos(ang), sin(ang)); for(int j = 0; j &lt; len; j += h) { Complex w(1, 0); for(int k = j; k &lt; j + h / 2; k++) { Complex u = y[k]; Complex t = w * y[k + h / 2]; y[k] = u + t; y[k + h / 2] = u - t; w = w * wn; } } } if(op == -1) for(int i = 0; i &lt; len; i++) y[i] /= len; } int n, m, k; Complex A[N], B[N]; bool p[N], q[N]; void multiply(bool *p, int &amp;n, bool *q, int m) { int len = 1; while(len &lt;= n + m) len &lt;&lt;= 1; for(int i = 0; i &lt; len; ++i) A[i] = Complex(i &lt;= n ? p[i] : 0, 0); for(int i = 0; i &lt; len; ++i) B[i] = Complex(i &lt;= m ? q[i] : 0, 0); fft(A, len, 1); fft(B, len, 1); for(int i = 0; i &lt; len; ++i) A[i] *= B[i]; fft(A, len, -1); for(int i = 0; i &lt;= n + m; ++i) p[i] = A[i].real() &gt; 0.5; n += m; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); scanf(&quot;%d%d&quot;, &amp;n, &amp;k); for(int i = 1; i &lt;= n; ++i) { int x; scanf(&quot;%d&quot;, &amp;x); q[x] = 1; } m = 1000; n = 0; p[0] = 1; while(k) { if(k &amp; 1) multiply(p, n, q, m); if(k &gt; 1) multiply(q, m, q, m); k &gt;&gt;= 1; } for(int i = 1; i &lt;= n; ++i) if(p[i]) printf(&quot;%d &quot;, i); puts(&quot;&quot;); return 0; }]]></content>
      <categories>
        <category>数学</category>
        <category>FFT/NTT/FWT</category>
      </categories>
      <tags>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4606 Occupy Cities （计算几何、最短路、最小路径覆盖）]]></title>
    <url>%2F2016%2F03%2F01%2FHDU%204606%20Occupy%20Cities%20%EF%BC%88%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E3%80%81%E6%9C%80%E7%9F%AD%E8%B7%AF%E3%80%81%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E8%A6%86%E7%9B%96%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： 给出$n\le 100$个城市需要去占领，有$m\le 100$条线段是障碍物，有$p\le 100$个士兵可以用占领城市有个先后顺序，每个士兵有个背包，占领城市之后，仅能补给一次背包问背包容量最少是多少，可以用这$p$个士兵完成任务，起点任意 分析： 枚举城市以及障碍的顶点，需要特判是某个障碍的$2$个端点的情况，求一下距离，判断是否与线段相交然后$floyd$预处理最短路二分背包容量，根据占领的先后顺序建边，跑二分图最小路径覆盖判断是否$p$个士兵可以占领 代码： // // Created by TaoSama on 2016-03-01 // Copyright (c) 2016 TaoSama. All rights reserved. // #pragma comment(linker, &quot;/STACK:1024000000,1024000000&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot; #define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl const int N = 3e2 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7; const double EPS = 1e-8; int sgn(double x) { return x &lt; -EPS ? -1 : x &gt; EPS; } int n, m, p, schedule[N]; double d[N][N]; struct Point { double x, y; void read() {scanf(&quot;%lf%lf&quot;, &amp;x, &amp;y);} Point operator-(const Point&amp; p) { return {x - p.x, y - p.y}; } double operator*(const Point&amp; p) { return x * p.x + y * p.y; } double operator^(const Point&amp; p) { return x * p.y - y * p.x; } double length() { return sqrt(*this **this); } } ps[N]; bool segmentProperIntersection(Point a1, Point a2, Point b1, Point b2) { double c1 = (a2 - a1) ^ (b1 - a1), c2 = (a2 - a1) ^ (b2 - a1); double c3 = (b2 - b1) ^ (a1 - b1), c4 = (b2 - b1) ^ (a2 - b1); return sgn(c1) * sgn(c2) &lt; 0 &amp;&amp; sgn(c3) * sgn(c4) &lt; 0; } bool vis[N]; int match[N]; vector&lt;int&gt; G[N]; bool dfs(int u) { for(int v : G[u]) { if(vis[v]) continue; vis[v] = true; if(!match[v] || dfs(match[v])) { match[v] = u; return true; } } return false; } bool check(double x) { for(int i = 1; i &lt;= n; ++i) G[i].clear(); for(int i = 1; i &lt;= n; ++i) { int u = schedule[i]; for(int j = i + 1; j &lt;= n; ++j) { int v = schedule[j]; if(sgn(x - d[u][v]) &gt;= 0) G[u].push_back(v); } } int matches = 0; memset(match, 0, sizeof match); for(int i = 1; i &lt;= n; ++i) { memset(vis, 0, sizeof vis); matches += dfs(i); } return n - matches &lt;= p; } int main() { #ifdef LOCAL freopen(&quot;C:\\Users\\TaoSama\\Desktop\\in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;C:\\Users\\TaoSama\\Desktop\\out.txt&quot;,&quot;w&quot;,stdout); #endif ios_base::sync_with_stdio(0); int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;p); for(int i = 1; i &lt;= n; ++i) ps[i].read(); for(int i = 1; i &lt;= m; ++i) { ps[n + i].read(); ps[n + m + i].read(); } for(int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, schedule + i); for(int i = 1; i &lt;= n + 2 * m; ++i) for(int j = 1; j &lt;= n + 2 * m; ++j) d[i][j] = i == j ? 0 : 1e18; for(int i = 1; i &lt;= n + 2 * m; ++i) { for(int j = i + 1; j &lt;= n + 2 * m; ++j) { if(i &gt; n &amp;&amp; j - i == m) continue; //same barrier&#39;s two ends bool can = true; for(int k = 1; k &lt;= m; ++k) { if(segmentProperIntersection(ps[i], ps[j], ps[n + k], ps[n + m + k])) { can = false; break; } } if(can) d[i][j] = d[j][i] = (ps[i] - ps[j]).length(); } } //Floyd for(int k = 1; k &lt;= n + 2 * m; ++k) for(int i = 1; i &lt;= n + 2 * m; ++i) for(int j = 1; j &lt;= n + 2 * m; ++j) d[i][j] = min(d[i][j], d[i][k] + d[k][j]); double l = 0, r = 1e5; for(int i = 1; i &lt;= 100; ++i) { double m = (l + r) / 2; if(check(m)) r = m; else l = m; } printf(&quot;%.2f\n&quot;, l); } return 0; }]]></content>
      <categories>
        <category>图论</category>
        <category>二分图</category>
      </categories>
      <tags>
        <tag>最小路径覆盖</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[About]]></title>
    <url>%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[老顽童 TaoSama 迷茫的搬砖工 / 永不退役的ACMer]]></content>
  </entry>
  <entry>
    <title><![CDATA[categories]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Project]]></title>
    <url>%2Fproject%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Tags]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
